{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst ms_rest_js_1 = require(\"@azure/ms-rest-js\");\n\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nconst adal_node_1 = require(\"adal-node\");\n\nclass TokenCredentialsBase {\n  constructor(clientId, domain, tokenAudience, environment = ms_rest_azure_env_1.Environment.AzureCloud, tokenCache = new adal_node_1.MemoryCache()) {\n    this.clientId = clientId;\n    this.domain = domain;\n    this.tokenAudience = tokenAudience;\n    this.environment = environment;\n    this.tokenCache = tokenCache;\n\n    if (!clientId || typeof clientId.valueOf() !== \"string\") {\n      throw new Error(\"clientId must be a non empty string.\");\n    }\n\n    if (!domain || typeof domain.valueOf() !== \"string\") {\n      throw new Error(\"domain must be a non empty string.\");\n    }\n\n    if (this.tokenAudience === \"graph\" && this.domain.toLowerCase() === \"common\") {\n      throw new Error(`${'If the tokenAudience is specified as \"graph\" then \"domain\" cannot be defaulted to \"common\" tenant.\\\r\n        It must be the actual tenant (preferably a string in a guid format).'}`);\n    }\n\n    const authorityUrl = this.environment.activeDirectoryEndpointUrl + this.domain;\n    this.authContext = new adal_node_1.AuthenticationContext(authorityUrl, this.environment.validateAuthority, this.tokenCache);\n  }\n\n  setDomain(domain) {\n    this.domain = domain;\n    const authorityUrl = this.environment.activeDirectoryEndpointUrl + this.domain;\n    this.authContext = new adal_node_1.AuthenticationContext(authorityUrl, this.environment.validateAuthority, this.tokenCache);\n  }\n\n  getActiveDirectoryResourceId() {\n    let resource = this.environment.activeDirectoryResourceId;\n\n    if (this.tokenAudience) {\n      resource = this.tokenAudience;\n\n      if (this.tokenAudience.toLowerCase() === \"graph\") {\n        resource = this.environment.activeDirectoryGraphResourceId;\n      } else if (this.tokenAudience.toLowerCase() === \"batch\") {\n        resource = this.environment.batchResourceId;\n      }\n    }\n\n    return resource;\n  }\n\n  getTokenFromCache(username) {\n    const self = this;\n    const resource = this.getActiveDirectoryResourceId();\n    return new Promise((resolve, reject) => {\n      self.authContext.acquireToken(resource, username, self.clientId, (error, tokenResponse) => {\n        if (error) {\n          return reject(error);\n        }\n\n        if (tokenResponse.error || tokenResponse.errorDescription) {\n          return reject(tokenResponse);\n        }\n\n        return resolve(tokenResponse);\n      });\n    });\n  }\n  /**\r\n   * Signs a request with the Authentication header.\r\n   *\r\n   * @param webResource - The WebResource to be signed.\r\n   */\n\n\n  signRequest(webResource) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tokenResponse = yield this.getToken();\n      webResource.headers.set(ms_rest_js_1.Constants.HeaderConstants.AUTHORIZATION, `${tokenResponse.tokenType} ${tokenResponse.accessToken}`);\n      return webResource;\n    });\n  }\n\n}\n\nexports.TokenCredentialsBase = TokenCredentialsBase;","map":{"version":3,"sources":["../../../lib/credentials/tokenCredentialsBase.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst ms_rest_js_1 = require(\"@azure/ms-rest-js\");\r\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\r\nconst adal_node_1 = require(\"adal-node\");\r\nclass TokenCredentialsBase {\r\n    constructor(clientId, domain, tokenAudience, environment = ms_rest_azure_env_1.Environment.AzureCloud, tokenCache = new adal_node_1.MemoryCache()) {\r\n        this.clientId = clientId;\r\n        this.domain = domain;\r\n        this.tokenAudience = tokenAudience;\r\n        this.environment = environment;\r\n        this.tokenCache = tokenCache;\r\n        if (!clientId || typeof clientId.valueOf() !== \"string\") {\r\n            throw new Error(\"clientId must be a non empty string.\");\r\n        }\r\n        if (!domain || typeof domain.valueOf() !== \"string\") {\r\n            throw new Error(\"domain must be a non empty string.\");\r\n        }\r\n        if (this.tokenAudience === \"graph\" && this.domain.toLowerCase() === \"common\") {\r\n            throw new Error(`${'If the tokenAudience is specified as \"graph\" then \"domain\" cannot be defaulted to \"common\" tenant.\\\r\n        It must be the actual tenant (preferably a string in a guid format).'}`);\r\n        }\r\n        const authorityUrl = this.environment.activeDirectoryEndpointUrl + this.domain;\r\n        this.authContext = new adal_node_1.AuthenticationContext(authorityUrl, this.environment.validateAuthority, this.tokenCache);\r\n    }\r\n    setDomain(domain) {\r\n        this.domain = domain;\r\n        const authorityUrl = this.environment.activeDirectoryEndpointUrl + this.domain;\r\n        this.authContext = new adal_node_1.AuthenticationContext(authorityUrl, this.environment.validateAuthority, this.tokenCache);\r\n    }\r\n    getActiveDirectoryResourceId() {\r\n        let resource = this.environment.activeDirectoryResourceId;\r\n        if (this.tokenAudience) {\r\n            resource = this.tokenAudience;\r\n            if (this.tokenAudience.toLowerCase() === \"graph\") {\r\n                resource = this.environment.activeDirectoryGraphResourceId;\r\n            }\r\n            else if (this.tokenAudience.toLowerCase() === \"batch\") {\r\n                resource = this.environment.batchResourceId;\r\n            }\r\n        }\r\n        return resource;\r\n    }\r\n    getTokenFromCache(username) {\r\n        const self = this;\r\n        const resource = this.getActiveDirectoryResourceId();\r\n        return new Promise((resolve, reject) => {\r\n            self.authContext.acquireToken(resource, username, self.clientId, (error, tokenResponse) => {\r\n                if (error) {\r\n                    return reject(error);\r\n                }\r\n                if (tokenResponse.error || tokenResponse.errorDescription) {\r\n                    return reject(tokenResponse);\r\n                }\r\n                return resolve(tokenResponse);\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Signs a request with the Authentication header.\r\n     *\r\n     * @param webResource - The WebResource to be signed.\r\n     */\r\n    signRequest(webResource) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const tokenResponse = yield this.getToken();\r\n            webResource.headers.set(ms_rest_js_1.Constants.HeaderConstants.AUTHORIZATION, `${tokenResponse.tokenType} ${tokenResponse.accessToken}`);\r\n            return webResource;\r\n        });\r\n    }\r\n}\r\nexports.TokenCredentialsBase = TokenCredentialsBase;\r\n//# sourceMappingURL=tokenCredentialsBase.js.map"]},"metadata":{},"sourceType":"script"}