{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar _toConsumableArray = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar adal = require(\"adal-node\");\n\nvar msRest = require(\"@azure/ms-rest-js\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar fs_1 = require(\"fs\");\n\nvar ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nvar applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\n\nvar applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\n\nvar deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\n\nvar userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\n\nvar authConstants_1 = require(\"./util/authConstants\");\n\nvar subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\n\nvar msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\n\nvar msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\r\n * Urls for management plane token\r\n * audience across different azure environments.\r\n */\n\n\nvar managementPlaneTokenAudiences = [\"https://management.core.windows.net/\", \"https://management.core.chinacloudapi.cn/\", \"https://management.core.usgovcloudapi.net/\", \"https://management.core.cloudapi.de/\", \"https://management.azure.com/\", \"https://management.core.windows.net\", \"https://management.core.chinacloudapi.cn\", \"https://management.core.usgovcloudapi.net\", \"https://management.core.cloudapi.de\", \"https://management.azure.com\"];\n\nfunction turnOnLogging() {\n  var log = adal.Logging;\n  log.setLoggingOptions({\n    level: 3,\n    log: function log(level, message, error) {\n      level;\n      console.info(message);\n\n      if (error) {\n        console.error(error);\n      }\n    }\n  });\n}\n\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n  turnOnLogging();\n}\n/**\r\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\r\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\r\n *\r\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param username - The user name for the Organization Id account.\r\n * @param password - The password for the Organization Id account.\r\n * @param options - Object representing optional parameters.\r\n * @param options.clientId - The active directory application client id.\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.domain - The domain or tenant Id containing this application. Default value \"common\".\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\r\n */\n\n\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var creds, tokenResponse, tenantList, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment, options.tokenCache);\n            _context.next = 7;\n            return creds.getToken();\n\n          case 7:\n            tokenResponse = _context.sent;\n            _context.next = 10;\n            return subscriptionUtils_1.buildTenantList(creds);\n\n          case 10:\n            tenantList = _context.sent;\n\n            if (tenantList.length === 0 && tokenResponse.tenantId) {\n              tenantList = [tokenResponse.tenantId];\n            }\n\n            _context.next = 14;\n            return _getSubscriptions(creds, tenantList, options.tokenAudience);\n\n          case 14:\n            subscriptionList = _context.sent;\n            return _context.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 16:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\r\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param secret - The application secret for the service principal.\r\n * @param domain - The domain or tenant Id containing this application.\r\n * @param options - Object representing optional parameters.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\n\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment, options.tokenCache);\n            _context2.next = 5;\n            return creds.getToken();\n\n          case 5:\n            _context2.next = 7;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 7:\n            subscriptionList = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\r\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param certificateStringOrFilePath - A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\r\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\r\n * - CertificateFilePath: **Absolute** file path of the .pem file.\r\n * @param domain - The domain or tenant Id containing this application.\r\n * @param options - Object representing optional parameters.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\n\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var creds, subscriptionList;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n            _context3.next = 5;\n            return creds.getToken();\n\n          case 5:\n            _context3.next = 7;\n            return _getSubscriptions(creds, [domain], options.tokenAudience);\n\n          case 7:\n            subscriptionList = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptionList\n            });\n\n          case 9:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n}\n\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\n\nfunction validateAuthFileContent(credsObj, filePath) {\n  if (!credsObj) {\n    throw new Error(\"Please provide a credsObj to validate.\");\n  }\n\n  if (!filePath) {\n    throw new Error(\"Please provide a filePath.\");\n  }\n\n  if (!credsObj.clientId) {\n    throw new Error(\"\\\"clientId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n    throw new Error(\"Either \\\"clientSecret\\\" or \\\"clientCertificate\\\" must be present in the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.subscriptionId) {\n    throw new Error(\"\\\"subscriptionId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.tenantId) {\n    throw new Error(\"\\\"tenantId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryEndpointUrl) {\n    throw new Error(\"\\\"activeDirectoryEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.resourceManagerEndpointUrl) {\n    throw new Error(\"\\\"resourceManagerEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.activeDirectoryGraphResourceId) {\n    throw new Error(\"\\\"activeDirectoryGraphResourceId\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n\n  if (!credsObj.sqlManagementEndpointUrl) {\n    throw new Error(\"\\\"sqlManagementEndpointUrl\\\" is missing from the auth file: \".concat(filePath, \".\"));\n  }\n}\n\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n  if (!authFileUrl || authFileUrl && typeof authFileUrl.valueOf() !== \"string\") {\n    throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  if (!envUrl || envUrl && typeof envUrl.valueOf() !== \"string\") {\n    throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n  envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n  return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\r\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\r\n * If you want to create the sp for a different cloud/environment then please execute:\r\n * 1. az cloud list\r\n * 2. az cloud set –n <name of the environment>\r\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\r\n *  **OR**\r\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\r\n * If the service principal is already created then login with service principal info:\r\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\r\n * 5. az account show --sdk-auth > auth.json\r\n *\r\n * Authenticates using the service principal information provided in the auth file. This method will set\r\n * the subscriptionId from the auth file to the user provided environment variable in the options\r\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\r\n *\r\n * @param options - Optional parameters\r\n * @param options.filePath - Absolute file path to the auth file. If not provided\r\n * then please set the environment variable AZURE_AUTH_LOCATION.\r\n * @param options.subscriptionEnvVariableName - The subscriptionId environment variable\r\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\r\n * @param optionalCallback - The optional callback.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\n\n\nfunction withAuthFileWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n    var filePath, subscriptionEnvVariableName, msg, content, credsObj, optionsForSp, envFound, envNames, i, env, environmentObj, envParams, keys, _i, key;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (!options) options = {\n              filePath: \"\"\n            };\n            filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n            subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n\n            if (filePath) {\n              _context4.next = 6;\n              break;\n            }\n\n            msg = \"Either provide an absolute file path to the auth file or set/export the environment variable - \".concat(authConstants_1.AuthConstants.AZURE_AUTH_LOCATION, \".\");\n            throw new Error(msg);\n\n          case 6:\n            credsObj = {};\n            optionsForSp = {};\n            content = fs_1.readFileSync(filePath, {\n              encoding: \"utf8\"\n            });\n            credsObj = JSON.parse(content);\n            validateAuthFileContent(credsObj, filePath);\n\n            if (!credsObj.managementEndpointUrl) {\n              credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n            } // setting the subscriptionId from auth file to the environment variable\n\n\n            process.env[subscriptionEnvVariableName] = credsObj.subscriptionId; // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n\n            envFound = {\n              name: \"\"\n            };\n            envNames = Object.keys(ms_rest_azure_env_1.Environment);\n            i = 0;\n\n          case 16:\n            if (!(i < envNames.length)) {\n              _context4.next = 25;\n              break;\n            }\n\n            env = envNames[i];\n            environmentObj = ms_rest_azure_env_1.Environment[env];\n\n            if (!(environmentObj && environmentObj.managementEndpointUrl && foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl))) {\n              _context4.next = 22;\n              break;\n            }\n\n            envFound.name = environmentObj.name;\n            return _context4.abrupt(\"break\", 25);\n\n          case 22:\n            i++;\n            _context4.next = 16;\n            break;\n\n          case 25:\n            if (envFound.name) {\n              optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n            } else {\n              // create a new environment with provided info.\n              envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n              };\n              keys = Object.keys(credsObj);\n\n              for (_i = 0; _i < keys.length; _i++) {\n                key = keys[_i];\n\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/gi) === null) {\n                  if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                    envParams[key] = credsObj[key] + \"/\";\n                  } else {\n                    envParams[key] = credsObj[key];\n                  }\n                }\n              }\n\n              if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n              }\n\n              if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n              }\n\n              optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n            }\n\n            if (!credsObj.clientSecret) {\n              _context4.next = 28;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp));\n\n          case 28:\n            return _context4.abrupt(\"return\", withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp));\n\n          case 29:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n}\n\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\r\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param options - Object representing optional parameters.\r\n *\r\n * @param options.clientId - The active directory application client id.\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n *\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\r\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\r\n *\r\n * @param options.domain - The domain or tenant Id containing this application. Default value is \"common\".\r\n *\r\n * @param options.environment - The azure environment to authenticate with. Default environment is \"Public Azure\".\r\n *\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @param options.language - The language code specifying how the message should be localized to. Default value \"en-us\".\r\n *\r\n * @param options.userCodeResponseLogger - A logger that logs the user code response message required for interactive login. When\r\n * this option is specified the usercode response message will not be logged to console.\r\n *\r\n * @param optionalCallback - The optional callback.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\n\nfunction withInteractiveWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n    var interactiveOptions, authorityUrl, authContext, tryAcquireToken, getUserCode, userCodeResponse, creds, tenants, subscriptions;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            tryAcquireToken = function _tryAcquireToken(interactiveOptions, resolve, reject) {\n              authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, function (err, userCodeRes) {\n                if (err) {\n                  if (err.error === \"authorization_pending\") {\n                    setTimeout(function () {\n                      tryAcquireToken(interactiveOptions, resolve, reject);\n                    }, 1000);\n                  } else {\n                    reject(err);\n                  }\n\n                  return;\n                }\n\n                if (interactiveOptions.userCodeResponseLogger) {\n                  interactiveOptions.userCodeResponseLogger(userCodeRes.message);\n                } else {\n                  console.log(userCodeRes.message);\n                }\n\n                return resolve(userCodeRes);\n              });\n            };\n\n            if (!options) {\n              options = {};\n            }\n\n            if (!options.environment) {\n              options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n            }\n\n            if (!options.domain) {\n              options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n            }\n\n            if (!options.clientId) {\n              options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n            }\n\n            if (!options.tokenCache) {\n              options.tokenCache = new adal.MemoryCache();\n            }\n\n            if (!options.language) {\n              options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n            }\n\n            if (!options.tokenAudience) {\n              options.tokenAudience = options.environment.activeDirectoryResourceId;\n            }\n\n            interactiveOptions = {};\n            interactiveOptions.tokenAudience = options.tokenAudience;\n            interactiveOptions.environment = options.environment;\n            interactiveOptions.domain = options.domain;\n            interactiveOptions.clientId = options.clientId;\n            interactiveOptions.tokenCache = options.tokenCache;\n            interactiveOptions.language = options.language;\n            interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n            authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n            authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n            interactiveOptions.context = authContext;\n            getUserCode = new Promise(function (resolve, reject) {\n              return tryAcquireToken(interactiveOptions, resolve, reject);\n            });\n            _context5.next = 22;\n            return getUserCode;\n\n          case 22:\n            userCodeResponse = _context5.sent;\n            _context5.next = 25;\n            return new Promise(function (resolve, reject) {\n              return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, function (error, tokenResponse) {\n                if (error) {\n                  return reject(error);\n                }\n\n                var response = tokenResponse;\n                interactiveOptions.userName = response.userId;\n                interactiveOptions.authorizationScheme = response.tokenType;\n                var creds;\n\n                try {\n                  creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                } catch (err) {\n                  return reject(err);\n                }\n\n                return resolve(creds);\n              });\n            });\n\n          case 25:\n            creds = _context5.sent;\n            _context5.next = 28;\n            return subscriptionUtils_1.buildTenantList(creds);\n\n          case 28:\n            tenants = _context5.sent;\n            _context5.next = 31;\n            return _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n\n          case 31:\n            subscriptions = _context5.sent;\n            return _context5.abrupt(\"return\", {\n              credentials: creds,\n              subscriptions: subscriptions\n            });\n\n          case 33:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\n\nfunction withAuthFile(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withAuthFileWithAuthResponse(options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withAuthFileWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withAuthFile = withAuthFile;\n\nfunction interactive(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withInteractiveWithAuthResponse(options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withInteractiveWithAuthResponse(options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.interactive = interactive;\n\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\n\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\n\nfunction withUsernamePassword(username, password, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return withUsernamePasswordWithAuthResponse(username, password, options).then(function (authRes) {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))(function (err, authRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withUsernamePassword = withUsernamePassword;\n/**\r\n * We only need to get the subscription list if the tokenAudience is for a management client.\r\n */\n\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n  if (tokenAudience && !managementPlaneTokenAudiences.some(function (item) {\n    return item === tokenAudience.toLowerCase();\n  })) {\n    return Promise.resolve([]);\n  }\n\n  return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\r\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\r\n *\r\n * @param domain - - required. The tenant id.\r\n * @param options - - Optional parameters\r\n * @param options.port - port on which the MSI service is running on the host VM. Default port is 50342\r\n * @param options.resource - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\r\n * @param options.aadEndpoint - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\r\n * @param callback - - the callback function.\r\n */\n\n\nfunction _withMSI(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n    var creds;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n            _context6.next = 4;\n            return creds.getToken();\n\n          case 4:\n            return _context6.abrupt(\"return\", creds);\n\n          case 5:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n}\n\nfunction loginWithVmMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withMSI(options);\n  } else {\n    msRest.promiseToCallback(_withMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\r\n * Private method\r\n */\n\nfunction _withAppServiceMSI(options) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n    var creds;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            if (!options) {\n              options = {};\n            }\n\n            creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n            _context7.next = 4;\n            return creds.getToken();\n\n          case 4:\n            return _context7.abrupt(\"return\", creds);\n\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n}\n\nfunction loginWithAppServiceMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  var cb = callback;\n\n  if (!callback) {\n    return _withAppServiceMSI(options);\n  } else {\n    msRest.promiseToCallback(_withAppServiceMSI(options))(function (err, tokenRes) {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\r\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\r\n * not return anything or a `JSON object` if the command did return something.\r\n * @param cmdArguments Arguments to the az cli command to execute.\r\n */\n\nfunction execAz(cmdArguments) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n    var azCmd;\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            azCmd = process.platform === \"win32\" ? \"az.cmd\" : \"az\";\n            return _context8.abrupt(\"return\", new Promise(function (resolve, reject) {\n              child_process_1.execFile(azCmd, [].concat(_toConsumableArray(cmdArguments), [\"--out\", \"json\"]), {\n                encoding: \"utf8\"\n              }, function (error, stdout) {\n                if (error) {\n                  return reject(error);\n                }\n\n                try {\n                  return resolve(JSON.parse(stdout));\n                } catch (err) {\n                  var msg = \"An error occurred while parsing the output \\\"\".concat(stdout, \"\\\", of \") + \"the cmd az \\\"\".concat(cmdArguments, \"\\\": \").concat(err.stack, \".\");\n                  return reject(new Error(msg));\n                }\n              });\n            }));\n\n          case 2:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8);\n  }));\n}\n\nexports.execAz = execAz;","map":{"version":3,"sources":["../../lib/login.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst adal = require(\"adal-node\");\r\nconst msRest = require(\"@azure/ms-rest-js\");\r\nconst child_process_1 = require(\"child_process\");\r\nconst fs_1 = require(\"fs\");\r\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\r\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\r\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\r\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\r\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\r\nconst authConstants_1 = require(\"./util/authConstants\");\r\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\r\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\r\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\r\n/**\r\n * Urls for management plane token\r\n * audience across different azure environments.\r\n */\r\nconst managementPlaneTokenAudiences = [\r\n    \"https://management.core.windows.net/\",\r\n    \"https://management.core.chinacloudapi.cn/\",\r\n    \"https://management.core.usgovcloudapi.net/\",\r\n    \"https://management.core.cloudapi.de/\",\r\n    \"https://management.azure.com/\",\r\n    \"https://management.core.windows.net\",\r\n    \"https://management.core.chinacloudapi.cn\",\r\n    \"https://management.core.usgovcloudapi.net\",\r\n    \"https://management.core.cloudapi.de\",\r\n    \"https://management.azure.com\"\r\n];\r\nfunction turnOnLogging() {\r\n    const log = adal.Logging;\r\n    log.setLoggingOptions({\r\n        level: 3,\r\n        log: function (level, message, error) {\r\n            level;\r\n            console.info(message);\r\n            if (error) {\r\n                console.error(error);\r\n            }\r\n        }\r\n    });\r\n}\r\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\r\n    turnOnLogging();\r\n}\r\n/**\r\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\r\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\r\n *\r\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param username - The user name for the Organization Id account.\r\n * @param password - The password for the Organization Id account.\r\n * @param options - Object representing optional parameters.\r\n * @param options.clientId - The active directory application client id.\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.domain - The domain or tenant Id containing this application. Default value \"common\".\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\r\n */\r\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (!options.clientId) {\r\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\r\n        }\r\n        if (!options.domain) {\r\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\r\n        }\r\n        if (!options.environment) {\r\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\r\n        }\r\n        const creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment, options.tokenCache);\r\n        const tokenResponse = yield creds.getToken();\r\n        // The token cache gets propulated for all the tenants as a part of building the tenantList.\r\n        let tenantList = yield subscriptionUtils_1.buildTenantList(creds);\r\n        if (tenantList.length === 0 && tokenResponse.tenantId) {\r\n            tenantList = [tokenResponse.tenantId];\r\n        }\r\n        const subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\r\n        return { credentials: creds, subscriptions: subscriptionList };\r\n    });\r\n}\r\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\r\n/**\r\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param secret - The application secret for the service principal.\r\n * @param domain - The domain or tenant Id containing this application.\r\n * @param options - Object representing optional parameters.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\r\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (!options.environment) {\r\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\r\n        }\r\n        const creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment, options.tokenCache);\r\n        yield creds.getToken();\r\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\r\n        return { credentials: creds, subscriptions: subscriptionList };\r\n    });\r\n}\r\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\r\n/**\r\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n * @param certificateStringOrFilePath - A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\r\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\r\n * - CertificateFilePath: **Absolute** file path of the .pem file.\r\n * @param domain - The domain or tenant Id containing this application.\r\n * @param options - Object representing optional parameters.\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\r\n * @param options.environment - The azure environment to authenticate with.\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\r\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (!options.environment) {\r\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\r\n        }\r\n        const creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\r\n        yield creds.getToken();\r\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\r\n        return { credentials: creds, subscriptions: subscriptionList };\r\n    });\r\n}\r\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\r\nfunction validateAuthFileContent(credsObj, filePath) {\r\n    if (!credsObj) {\r\n        throw new Error(\"Please provide a credsObj to validate.\");\r\n    }\r\n    if (!filePath) {\r\n        throw new Error(\"Please provide a filePath.\");\r\n    }\r\n    if (!credsObj.clientId) {\r\n        throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.clientSecret && !credsObj.clientCertificate) {\r\n        throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.subscriptionId) {\r\n        throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.tenantId) {\r\n        throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.activeDirectoryEndpointUrl) {\r\n        throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.resourceManagerEndpointUrl) {\r\n        throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.activeDirectoryGraphResourceId) {\r\n        throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n    if (!credsObj.sqlManagementEndpointUrl) {\r\n        throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\r\n    }\r\n}\r\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\r\n    if (!authFileUrl || (authFileUrl && typeof authFileUrl.valueOf() !== \"string\")) {\r\n        throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\r\n    }\r\n    if (!envUrl || (envUrl && typeof envUrl.valueOf() !== \"string\")) {\r\n        throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\r\n    }\r\n    authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\r\n    envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\r\n    return authFileUrl.toLowerCase() === envUrl.toLowerCase();\r\n}\r\n/**\r\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\r\n * If you want to create the sp for a different cloud/environment then please execute:\r\n * 1. az cloud list\r\n * 2. az cloud set –n <name of the environment>\r\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\r\n *  **OR**\r\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\r\n * If the service principal is already created then login with service principal info:\r\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\r\n * 5. az account show --sdk-auth > auth.json\r\n *\r\n * Authenticates using the service principal information provided in the auth file. This method will set\r\n * the subscriptionId from the auth file to the user provided environment variable in the options\r\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\r\n *\r\n * @param options - Optional parameters\r\n * @param options.filePath - Absolute file path to the auth file. If not provided\r\n * then please set the environment variable AZURE_AUTH_LOCATION.\r\n * @param options.subscriptionEnvVariableName - The subscriptionId environment variable\r\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\r\n * @param optionalCallback - The optional callback.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\r\nfunction withAuthFileWithAuthResponse(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options)\r\n            options = { filePath: \"\" };\r\n        const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\r\n        const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\r\n        if (!filePath) {\r\n            const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\r\n            throw new Error(msg);\r\n        }\r\n        let content, credsObj = {};\r\n        const optionsForSp = {};\r\n        content = fs_1.readFileSync(filePath, { encoding: \"utf8\" });\r\n        credsObj = JSON.parse(content);\r\n        validateAuthFileContent(credsObj, filePath);\r\n        if (!credsObj.managementEndpointUrl) {\r\n            credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\r\n        }\r\n        // setting the subscriptionId from auth file to the environment variable\r\n        process.env[subscriptionEnvVariableName] = credsObj.subscriptionId;\r\n        // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\r\n        const envFound = {\r\n            name: \"\"\r\n        };\r\n        const envNames = Object.keys(ms_rest_azure_env_1.Environment);\r\n        for (let i = 0; i < envNames.length; i++) {\r\n            const env = envNames[i];\r\n            const environmentObj = ms_rest_azure_env_1.Environment[env];\r\n            if (environmentObj &&\r\n                environmentObj.managementEndpointUrl &&\r\n                foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\r\n                envFound.name = environmentObj.name;\r\n                break;\r\n            }\r\n        }\r\n        if (envFound.name) {\r\n            optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\r\n        }\r\n        else {\r\n            // create a new environment with provided info.\r\n            const envParams = {\r\n                // try to find a logical name or set the filepath as the env name.\r\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\r\n            };\r\n            const keys = Object.keys(credsObj);\r\n            for (let i = 0; i < keys.length; i++) {\r\n                const key = keys[i];\r\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/gi) === null) {\r\n                    if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\r\n                        envParams[key] = credsObj[key] + \"/\";\r\n                    }\r\n                    else {\r\n                        envParams[key] = credsObj[key];\r\n                    }\r\n                }\r\n            }\r\n            if (!envParams.activeDirectoryResourceId) {\r\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\r\n            }\r\n            if (!envParams.portalUrl) {\r\n                envParams.portalUrl = \"https://portal.azure.com\";\r\n            }\r\n            optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\r\n        }\r\n        if (credsObj.clientSecret) {\r\n            return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\r\n        }\r\n        return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\r\n    });\r\n}\r\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\r\n/**\r\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\r\n *\r\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\r\n *\r\n * @param options - Object representing optional parameters.\r\n *\r\n * @param options.clientId - The active directory application client id.\r\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n * for an example.\r\n *\r\n * @param options.tokenAudience - The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\r\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\r\n *\r\n * @param options.domain - The domain or tenant Id containing this application. Default value is \"common\".\r\n *\r\n * @param options.environment - The azure environment to authenticate with. Default environment is \"Public Azure\".\r\n *\r\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n *\r\n * @param options.language - The language code specifying how the message should be localized to. Default value \"en-us\".\r\n *\r\n * @param options.userCodeResponseLogger - A logger that logs the user code response message required for interactive login. When\r\n * this option is specified the usercode response message will not be logged to console.\r\n *\r\n * @param optionalCallback - The optional callback.\r\n *\r\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\r\n */\r\nfunction withInteractiveWithAuthResponse(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (!options.environment) {\r\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\r\n        }\r\n        if (!options.domain) {\r\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\r\n        }\r\n        if (!options.clientId) {\r\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\r\n        }\r\n        if (!options.tokenCache) {\r\n            options.tokenCache = new adal.MemoryCache();\r\n        }\r\n        if (!options.language) {\r\n            options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\r\n        }\r\n        if (!options.tokenAudience) {\r\n            options.tokenAudience = options.environment.activeDirectoryResourceId;\r\n        }\r\n        const interactiveOptions = {};\r\n        interactiveOptions.tokenAudience = options.tokenAudience;\r\n        interactiveOptions.environment = options.environment;\r\n        interactiveOptions.domain = options.domain;\r\n        interactiveOptions.clientId = options.clientId;\r\n        interactiveOptions.tokenCache = options.tokenCache;\r\n        interactiveOptions.language = options.language;\r\n        interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\r\n        const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\r\n        const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\r\n        interactiveOptions.context = authContext;\r\n        function tryAcquireToken(interactiveOptions, resolve, reject) {\r\n            authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\r\n                if (err) {\r\n                    if (err.error === \"authorization_pending\") {\r\n                        setTimeout(() => {\r\n                            tryAcquireToken(interactiveOptions, resolve, reject);\r\n                        }, 1000);\r\n                    }\r\n                    else {\r\n                        reject(err);\r\n                    }\r\n                    return;\r\n                }\r\n                if (interactiveOptions.userCodeResponseLogger) {\r\n                    interactiveOptions.userCodeResponseLogger(userCodeRes.message);\r\n                }\r\n                else {\r\n                    console.log(userCodeRes.message);\r\n                }\r\n                return resolve(userCodeRes);\r\n            });\r\n        }\r\n        const getUserCode = new Promise((resolve, reject) => {\r\n            return tryAcquireToken(interactiveOptions, resolve, reject);\r\n        });\r\n        const userCodeResponse = yield getUserCode;\r\n        const creds = yield new Promise((resolve, reject) => {\r\n            return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\r\n                if (error) {\r\n                    return reject(error);\r\n                }\r\n                const response = tokenResponse;\r\n                interactiveOptions.userName = response.userId;\r\n                interactiveOptions.authorizationScheme = response.tokenType;\r\n                let creds;\r\n                try {\r\n                    creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\r\n                }\r\n                catch (err) {\r\n                    return reject(err);\r\n                }\r\n                return resolve(creds);\r\n            });\r\n        });\r\n        const tenants = yield subscriptionUtils_1.buildTenantList(creds);\r\n        const subscriptions = yield _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\r\n        return { credentials: creds, subscriptions: subscriptions };\r\n    });\r\n}\r\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\r\nfunction withAuthFile(options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return withAuthFileWithAuthResponse(options).then((authRes) => {\r\n            return authRes.credentials;\r\n        });\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\r\n        });\r\n    }\r\n}\r\nexports.withAuthFile = withAuthFile;\r\nfunction interactive(options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return withInteractiveWithAuthResponse(options).then((authRes) => {\r\n            return authRes.credentials;\r\n        });\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\r\n        });\r\n    }\r\n}\r\nexports.interactive = interactive;\r\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then((authRes) => {\r\n            return authRes.credentials;\r\n        });\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\r\n        });\r\n    }\r\n}\r\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\r\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then((authRes) => {\r\n            return authRes.credentials;\r\n        });\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\r\n        });\r\n    }\r\n}\r\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\r\nfunction withUsernamePassword(username, password, options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = undefined;\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return withUsernamePasswordWithAuthResponse(username, password, options).then((authRes) => {\r\n            return authRes.credentials;\r\n        });\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\r\n        });\r\n    }\r\n}\r\nexports.withUsernamePassword = withUsernamePassword;\r\n/**\r\n * We only need to get the subscription list if the tokenAudience is for a management client.\r\n */\r\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\r\n    if (tokenAudience &&\r\n        !managementPlaneTokenAudiences.some((item) => {\r\n            return item === tokenAudience.toLowerCase();\r\n        })) {\r\n        return Promise.resolve([]);\r\n    }\r\n    return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\r\n}\r\n/**\r\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\r\n *\r\n * @param domain - - required. The tenant id.\r\n * @param options - - Optional parameters\r\n * @param options.port - port on which the MSI service is running on the host VM. Default port is 50342\r\n * @param options.resource - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\r\n * @param options.aadEndpoint - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\r\n * @param callback - - the callback function.\r\n */\r\nfunction _withMSI(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\r\n        yield creds.getToken();\r\n        return creds;\r\n    });\r\n}\r\nfunction loginWithVmMSI(options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return _withMSI(options);\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, tokenRes);\r\n        });\r\n    }\r\n}\r\nexports.loginWithVmMSI = loginWithVmMSI;\r\n/**\r\n * Private method\r\n */\r\nfunction _withAppServiceMSI(options) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\r\n        yield creds.getToken();\r\n        return creds;\r\n    });\r\n}\r\nfunction loginWithAppServiceMSI(options, callback) {\r\n    if (!callback && typeof options === \"function\") {\r\n        callback = options;\r\n        options = {};\r\n    }\r\n    const cb = callback;\r\n    if (!callback) {\r\n        return _withAppServiceMSI(options);\r\n    }\r\n    else {\r\n        msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\r\n            if (err) {\r\n                return cb(err);\r\n            }\r\n            return cb(undefined, tokenRes);\r\n        });\r\n    }\r\n}\r\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\r\n/**\r\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\r\n * not return anything or a `JSON object` if the command did return something.\r\n * @param cmdArguments Arguments to the az cli command to execute.\r\n */\r\nfunction execAz(cmdArguments) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        const azCmd = process.platform === \"win32\" ? \"az.cmd\" : \"az\";\r\n        return new Promise((resolve, reject) => {\r\n            child_process_1.execFile(azCmd, [...cmdArguments, \"--out\", \"json\"], { encoding: \"utf8\" }, (error, stdout) => {\r\n                if (error) {\r\n                    return reject(error);\r\n                }\r\n                try {\r\n                    return resolve(JSON.parse(stdout));\r\n                }\r\n                catch (err) {\r\n                    const msg = `An error occurred while parsing the output \"${stdout}\", of ` +\r\n                        `the cmd az \"${cmdArguments}\": ${err.stack}.`;\r\n                    return reject(new Error(msg));\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.execAz = execAz;\r\n//# sourceMappingURL=login.js.map"]},"metadata":{},"sourceType":"script"}