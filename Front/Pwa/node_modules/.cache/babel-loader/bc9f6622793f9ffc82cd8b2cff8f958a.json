{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar tls = _interopRequireWildcard(require(\"tls\"));\n\nvar _events = require(\"events\");\n\nvar _message = _interopRequireDefault(require(\"./message\"));\n\nvar _packet = require(\"./packet\");\n\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\n\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n} // eslint-disable-next-line @typescript-eslint/no-var-requires\n\n\nconst DuplexPair = require('native-duplexpair');\n\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = void 0;\n    this.debug = void 0;\n    this.tlsNegotiationComplete = void 0;\n    this.incomingMessageStream = void 0;\n    this.outgoingMessageStream = void 0;\n    this.securePair = void 0;\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageStream.on('data', message => {\n      this.emit('data', message);\n    });\n    this.incomingMessageStream.on('error', message => {\n      this.emit('error', message);\n    });\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  }\n\n  startTls(secureContext, hostname, trustServerCertificate) {\n    const duplexpair = new DuplexPair();\n    const securePair = this.securePair = {\n      cleartext: tls.connect({\n        socket: duplexpair.socket1,\n        servername: hostname,\n        secureContext: secureContext,\n        rejectUnauthorized: !trustServerCertificate\n      }),\n      encrypted: duplexpair.socket2\n    }; // If an error happens in the TLS layer, there is nothing we can do about it.\n    // Forward the error to the socket so the connection gets properly cleaned up.\n\n    securePair.cleartext.on('error', err => {\n      // Streams in node.js versions before 8.0.0 don't support `.destroy`\n      if (typeof securePair.encrypted.destroy === 'function') {\n        securePair.encrypted.destroy();\n      }\n\n      this.socket.destroy(err);\n    });\n    securePair.cleartext.on('secureConnect', () => {\n      const cipher = securePair.cleartext.getCipher();\n\n      if (cipher) {\n        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n      }\n\n      this.emit('secure', securePair.cleartext);\n      this.encryptAllFutureTraffic();\n    });\n    securePair.encrypted.on('data', data => {\n      this.sendMessage(_packet.TYPE.PRELOGIN, data, false);\n    });\n  }\n\n  encryptAllFutureTraffic() {\n    const securePair = this.securePair;\n    securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    securePair.encrypted.removeAllListeners('data');\n    this.outgoingMessageStream.unpipe(this.socket);\n    this.socket.unpipe(this.incomingMessageStream);\n    this.socket.pipe(securePair.encrypted);\n    securePair.encrypted.pipe(this.socket);\n    securePair.cleartext.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(securePair.cleartext);\n    this.tlsNegotiationComplete = true;\n  }\n\n  tlsHandshakeData(data) {\n    const securePair = this.securePair;\n    securePair.encrypted.write(data);\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  } // Temporarily suspends the flow of incoming packets.\n\n\n  pause() {\n    this.incomingMessageStream.pause();\n  } // Resumes the flow of incoming packets.\n\n\n  resume() {\n    this.incomingMessageStream.resume();\n  }\n\n}\n\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;","map":{"version":3,"sources":["B:/Duoc/Portafolio_de_titulo/Git/Turismo-Real/Front/Pwa/node_modules/mssql/node_modules/tedious/lib/message-io.js"],"names":["Object","defineProperty","exports","value","default","tls","_interopRequireWildcard","require","_events","_message","_interopRequireDefault","_packet","_incomingMessageStream","_outgoingMessageStream","obj","__esModule","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","DuplexPair","MessageIO","EventEmitter","constructor","socket","packetSize","debug","tlsNegotiationComplete","incomingMessageStream","outgoingMessageStream","securePair","on","message","emit","pipe","args","length","log","cleartext","setMaxSendFragment","startTls","secureContext","hostname","trustServerCertificate","duplexpair","connect","socket1","servername","rejectUnauthorized","encrypted","socket2","err","destroy","cipher","getCipher","name","version","encryptAllFutureTraffic","data","sendMessage","TYPE","PRELOGIN","removeAllListeners","unpipe","tlsHandshakeData","write","packetType","resetConnection","type","end","pause","resume","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = void 0;\r\n\r\nvar tls = _interopRequireWildcard(require(\"tls\"));\r\n\r\nvar _events = require(\"events\");\r\n\r\nvar _message = _interopRequireDefault(require(\"./message\"));\r\n\r\nvar _packet = require(\"./packet\");\r\n\r\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\r\n\r\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\r\n\r\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-var-requires\r\nconst DuplexPair = require('native-duplexpair');\r\n\r\nclass MessageIO extends _events.EventEmitter {\r\n  constructor(socket, packetSize, debug) {\r\n    super();\r\n    this.socket = void 0;\r\n    this.debug = void 0;\r\n    this.tlsNegotiationComplete = void 0;\r\n    this.incomingMessageStream = void 0;\r\n    this.outgoingMessageStream = void 0;\r\n    this.securePair = void 0;\r\n    this.socket = socket;\r\n    this.debug = debug;\r\n    this.tlsNegotiationComplete = false;\r\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\r\n    this.incomingMessageStream.on('data', message => {\r\n      this.emit('data', message);\r\n    });\r\n    this.incomingMessageStream.on('error', message => {\r\n      this.emit('error', message);\r\n    });\r\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\r\n      packetSize: packetSize\r\n    });\r\n    this.socket.pipe(this.incomingMessageStream);\r\n    this.outgoingMessageStream.pipe(this.socket);\r\n  }\r\n\r\n  packetSize(...args) {\r\n    if (args.length > 0) {\r\n      const packetSize = args[0];\r\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\r\n      this.outgoingMessageStream.packetSize = packetSize;\r\n    }\r\n\r\n    if (this.securePair) {\r\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\r\n    }\r\n\r\n    return this.outgoingMessageStream.packetSize;\r\n  }\r\n\r\n  startTls(secureContext, hostname, trustServerCertificate) {\r\n    const duplexpair = new DuplexPair();\r\n    const securePair = this.securePair = {\r\n      cleartext: tls.connect({\r\n        socket: duplexpair.socket1,\r\n        servername: hostname,\r\n        secureContext: secureContext,\r\n        rejectUnauthorized: !trustServerCertificate\r\n      }),\r\n      encrypted: duplexpair.socket2\r\n    }; // If an error happens in the TLS layer, there is nothing we can do about it.\r\n    // Forward the error to the socket so the connection gets properly cleaned up.\r\n\r\n    securePair.cleartext.on('error', err => {\r\n      // Streams in node.js versions before 8.0.0 don't support `.destroy`\r\n      if (typeof securePair.encrypted.destroy === 'function') {\r\n        securePair.encrypted.destroy();\r\n      }\r\n\r\n      this.socket.destroy(err);\r\n    });\r\n    securePair.cleartext.on('secureConnect', () => {\r\n      const cipher = securePair.cleartext.getCipher();\r\n\r\n      if (cipher) {\r\n        this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\r\n      }\r\n\r\n      this.emit('secure', securePair.cleartext);\r\n      this.encryptAllFutureTraffic();\r\n    });\r\n    securePair.encrypted.on('data', data => {\r\n      this.sendMessage(_packet.TYPE.PRELOGIN, data, false);\r\n    });\r\n  }\r\n\r\n  encryptAllFutureTraffic() {\r\n    const securePair = this.securePair;\r\n    securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\r\n    securePair.encrypted.removeAllListeners('data');\r\n    this.outgoingMessageStream.unpipe(this.socket);\r\n    this.socket.unpipe(this.incomingMessageStream);\r\n    this.socket.pipe(securePair.encrypted);\r\n    securePair.encrypted.pipe(this.socket);\r\n    securePair.cleartext.pipe(this.incomingMessageStream);\r\n    this.outgoingMessageStream.pipe(securePair.cleartext);\r\n    this.tlsNegotiationComplete = true;\r\n  }\r\n\r\n  tlsHandshakeData(data) {\r\n    const securePair = this.securePair;\r\n    securePair.encrypted.write(data);\r\n  } // TODO listen for 'drain' event when socket.write returns false.\r\n  // TODO implement incomplete request cancelation (2.2.1.6)\r\n\r\n\r\n  sendMessage(packetType, data, resetConnection) {\r\n    const message = new _message.default({\r\n      type: packetType,\r\n      resetConnection: resetConnection\r\n    });\r\n    message.end(data);\r\n    this.outgoingMessageStream.write(message);\r\n    return message;\r\n  } // Temporarily suspends the flow of incoming packets.\r\n\r\n\r\n  pause() {\r\n    this.incomingMessageStream.pause();\r\n  } // Resumes the flow of incoming packets.\r\n\r\n\r\n  resume() {\r\n    this.incomingMessageStream.resume();\r\n  }\r\n\r\n}\r\n\r\nvar _default = MessageIO;\r\nexports.default = _default;\r\nmodule.exports = MessageIO;"]},"metadata":{},"sourceType":"script"}