{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar PendingOperation_1 = require(\"./PendingOperation\");\n\nvar Resource_1 = require(\"./Resource\");\n\nvar utils_1 = require(\"./utils\");\n\nvar events_1 = require(\"events\");\n\nvar timers_1 = require(\"timers\");\n\nvar Pool = /*#__PURE__*/function () {\n  function Pool(opt) {\n    _classCallCheck(this, Pool);\n\n    this.destroyed = false;\n    this.emitter = new events_1.EventEmitter();\n    opt = opt || {};\n\n    if (!opt.create) {\n      throw new Error('Tarn: opt.create function most be provided');\n    }\n\n    if (!opt.destroy) {\n      throw new Error('Tarn: opt.destroy function most be provided');\n    }\n\n    if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\n      throw new Error('Tarn: opt.min must be an integer >= 0');\n    }\n\n    if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\n      throw new Error('Tarn: opt.max must be an integer > 0');\n    }\n\n    if (opt.min > opt.max) {\n      throw new Error('Tarn: opt.max is smaller than opt.min');\n    }\n\n    if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\n      throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\n    }\n\n    if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\n      throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' + JSON.stringify(opt.createRetryIntervalMillis));\n    }\n\n    var allowedKeys = {\n      create: true,\n      validate: true,\n      destroy: true,\n      log: true,\n      min: true,\n      max: true,\n      acquireTimeoutMillis: true,\n      createTimeoutMillis: true,\n      destroyTimeoutMillis: true,\n      idleTimeoutMillis: true,\n      reapIntervalMillis: true,\n      createRetryIntervalMillis: true,\n      propagateCreateError: true\n    };\n\n    for (var _i = 0, _Object$keys = Object.keys(opt); _i < _Object$keys.length; _i++) {\n      var key = _Object$keys[_i];\n\n      if (!allowedKeys[key]) {\n        throw new Error(\"Tarn: unsupported option opt.\".concat(key));\n      }\n    }\n\n    this.creator = opt.create;\n    this.destroyer = opt.destroy;\n    this.validate = typeof opt.validate === 'function' ? opt.validate : function () {\n      return true;\n    };\n\n    this.log = opt.log || function () {};\n\n    this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\n    this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\n    this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\n    this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\n    this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\n    this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\n    this.propagateCreateError = !!opt.propagateCreateError;\n    this.min = opt.min;\n    this.max = opt.max; // All the resources, which are either already acquired or which are\n    // considered for being passed to acquire in async validation phase.\n\n    this.used = []; // All the resources, which are either just created and free or returned\n    // back to pool after using.\n\n    this.free = [];\n    this.pendingCreates = [];\n    this.pendingAcquires = [];\n    this.pendingDestroys = []; // When acquire is pending, but also still in validation phase\n\n    this.pendingValidations = [];\n    this.destroyed = false;\n    this.interval = null;\n    this.eventId = 1;\n  }\n\n  _createClass(Pool, [{\n    key: \"numUsed\",\n    value: function numUsed() {\n      return this.used.length;\n    }\n  }, {\n    key: \"numFree\",\n    value: function numFree() {\n      return this.free.length;\n    }\n  }, {\n    key: \"numPendingAcquires\",\n    value: function numPendingAcquires() {\n      return this.pendingAcquires.length;\n    }\n  }, {\n    key: \"numPendingValidations\",\n    value: function numPendingValidations() {\n      return this.pendingValidations.length;\n    }\n  }, {\n    key: \"numPendingCreates\",\n    value: function numPendingCreates() {\n      return this.pendingCreates.length;\n    }\n  }, {\n    key: \"acquire\",\n    value: function acquire() {\n      var _this = this;\n\n      var eventId = this.eventId++;\n\n      this._executeEventHandlers('acquireRequest', eventId);\n\n      var pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\n      this.pendingAcquires.push(pendingAcquire); // If the acquire fails for whatever reason\n      // remove it from the pending queue.\n\n      pendingAcquire.promise = pendingAcquire.promise.then(function (resource) {\n        _this._executeEventHandlers('acquireSuccess', eventId, resource);\n\n        return resource;\n      }).catch(function (err) {\n        _this._executeEventHandlers('acquireFail', eventId, err);\n\n        remove(_this.pendingAcquires, pendingAcquire);\n        return Promise.reject(err);\n      });\n\n      this._tryAcquireOrCreate();\n\n      return pendingAcquire;\n    }\n  }, {\n    key: \"release\",\n    value: function release(resource) {\n      this._executeEventHandlers('release', resource);\n\n      for (var i = 0, l = this.used.length; i < l; ++i) {\n        var used = this.used[i];\n\n        if (used.resource === resource) {\n          this.used.splice(i, 1);\n          this.free.push(used.resolve());\n\n          this._tryAcquireOrCreate();\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return [this.numFree(), this.numUsed(), this.numPendingAcquires(), this.numPendingValidations(), this.numPendingCreates()].reduce(function (total, value) {\n        return total + value;\n      }) === 0;\n    }\n    /**\r\n     * Reaping cycle.\r\n     */\n\n  }, {\n    key: \"check\",\n    value: function check() {\n      var _this2 = this;\n\n      var timestamp = utils_1.now();\n      var newFree = [];\n      var minKeep = this.min - this.used.length;\n      var maxDestroy = this.free.length - minKeep;\n      var numDestroyed = 0;\n      this.free.forEach(function (free) {\n        if (utils_1.duration(timestamp, free.timestamp) >= _this2.idleTimeoutMillis && numDestroyed < maxDestroy) {\n          numDestroyed++;\n\n          _this2._destroy(free.resource);\n        } else {\n          newFree.push(free);\n        }\n      });\n      this.free = newFree; // Pool is completely empty, stop reaping.\n      // Next .acquire will start reaping interval again.\n\n      if (this.isEmpty()) {\n        this._stopReaping();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var _this3 = this;\n\n      var eventId = this.eventId++;\n\n      this._executeEventHandlers('poolDestroyRequest', eventId);\n\n      this._stopReaping();\n\n      this.destroyed = true; // First wait for all the pending creates get ready.\n\n      return utils_1.reflect(Promise.all(this.pendingCreates.map(function (create) {\n        return utils_1.reflect(create.promise);\n      })).then(function () {\n        // eslint-disable-next-line\n        return new Promise(function (resolve, reject) {\n          // poll every 100ms and wait that all validations are ready\n          if (_this3.numPendingValidations() === 0) {\n            resolve();\n            return;\n          }\n\n          var interval = setInterval(function () {\n            if (_this3.numPendingValidations() === 0) {\n              timers_1.clearInterval(interval);\n              resolve();\n            }\n          }, 100);\n        });\n      }).then(function () {\n        // Wait for all the used resources to be freed.\n        return Promise.all(_this3.used.map(function (used) {\n          return utils_1.reflect(used.promise);\n        }));\n      }).then(function () {\n        // Abort all pending acquires.\n        return Promise.all(_this3.pendingAcquires.map(function (acquire) {\n          acquire.abort();\n          return utils_1.reflect(acquire.promise);\n        }));\n      }).then(function () {\n        // Now we can destroy all the freed resources.\n        return Promise.all(_this3.free.map(function (free) {\n          return utils_1.reflect(_this3._destroy(free.resource));\n        }));\n      }).then(function () {\n        // Also wait rest of the pending destroys to finish\n        return Promise.all(_this3.pendingDestroys.map(function (pd) {\n          return pd.promise;\n        }));\n      }).then(function () {\n        _this3.free = [];\n        _this3.pendingAcquires = [];\n      })).then(function (res) {\n        _this3._executeEventHandlers('poolDestroySuccess', eventId);\n\n        _this3.emitter.removeAllListeners();\n\n        return res;\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, listener) {\n      this.emitter.on(event, listener);\n    }\n  }, {\n    key: \"removeListener\",\n    value: function removeListener(event, listener) {\n      this.emitter.removeListener(event, listener);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners(event) {\n      this.emitter.removeAllListeners(event);\n    }\n    /**\r\n     * The most important method that is called always when resources\r\n     * are created / destroyed / acquired / released. In other words\r\n     * every time when resources are moved from used to free or vice\r\n     * versa.\r\n     *\r\n     * Either assigns free resources to pendingAcquires or creates new\r\n     * resources if there is room for it in the pool.\r\n     */\n\n  }, {\n    key: \"_tryAcquireOrCreate\",\n    value: function _tryAcquireOrCreate() {\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this._hasFreeResources()) {\n        this._doAcquire();\n      } else if (this._shouldCreateMoreResources()) {\n        this._doCreate();\n      }\n    }\n  }, {\n    key: \"_hasFreeResources\",\n    value: function _hasFreeResources() {\n      return this.free.length > 0;\n    }\n  }, {\n    key: \"_doAcquire\",\n    value: function _doAcquire() {\n      var _this4 = this;\n\n      var _loop = function _loop() {\n        // To allow async validation, we actually need to move free resource\n        // and pending acquire temporary from their respective arrays and depending\n        // on validation result to either leave the free resource to used resources array\n        // or destroy the free resource if validation did fail.\n        var pendingAcquire = _this4.pendingAcquires.shift();\n\n        var free = _this4.free.pop();\n\n        if (free === undefined || pendingAcquire === undefined) {\n          var errMessage = 'this.free was empty while trying to acquire resource';\n\n          _this4.log(\"Tarn: \".concat(errMessage), 'warn');\n\n          throw new Error(\"Internal error, should never happen. \".concat(errMessage));\n        } // Make sure that pendingAcquire that is being validated is not lost and\n        // can be freed when pool is destroyed.\n\n\n        _this4.pendingValidations.push(pendingAcquire); // Must be added here pre-emptively to prevent logic that decides\n        // if new resources are created will keep on working correctly.\n\n\n        _this4.used.push(free); // if acquire fails also pending validation, must be aborted so that pre reserved\n        // resource will be returned to free resources immediately\n\n\n        var abortAbleValidation = new PendingOperation_1.PendingOperation(_this4.acquireTimeoutMillis); // eslint-disable-next-line\n\n        pendingAcquire.promise.catch(function (err) {\n          abortAbleValidation.abort();\n        });\n        abortAbleValidation.promise.catch(function (err) {\n          // There's nothing we can do here but log the error. This would otherwise\n          // leak out as an unhandled exception.\n          _this4.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\n\n          return false;\n        }).then(function (validationSuccess) {\n          try {\n            if (validationSuccess) {\n              // At least one active resource exist, start reaping.\n              _this4._startReaping();\n\n              pendingAcquire.resolve(free.resource);\n            } else {\n              remove(_this4.used, free);\n\n              _this4._destroy(free.resource); // is acquire was canceled, failed or timed out already\n              // no need to return it to pending queries\n\n\n              if (!pendingAcquire.isRejected) {\n                _this4.pendingAcquires.unshift(pendingAcquire);\n              } // Since we destroyed an invalid resource and were not able to fulfill\n              // all the pending acquires, we may need to create new ones or at\n              // least run this acquire loop again to verify it. But not immediately\n              // to prevent starving event loop.\n\n\n              setTimeout(function () {\n                _this4._tryAcquireOrCreate();\n              }, 0);\n            }\n          } finally {\n            remove(_this4.pendingValidations, pendingAcquire);\n          }\n        }); // try to validate\n\n        _this4._validateResource(free.resource).then(function (validationSuccess) {\n          abortAbleValidation.resolve(validationSuccess);\n        }).catch(function (err) {\n          abortAbleValidation.reject(err);\n        });\n      };\n\n      // Acquire as many pending acquires as possible concurrently\n      while (this._canAcquire()) {\n        _loop();\n      }\n    }\n  }, {\n    key: \"_canAcquire\",\n    value: function _canAcquire() {\n      return this.free.length > 0 && this.pendingAcquires.length > 0;\n    }\n  }, {\n    key: \"_validateResource\",\n    value: function _validateResource(resource) {\n      try {\n        return Promise.resolve(this.validate(resource));\n      } catch (err) {\n        // prevent leaking of sync exception\n        return Promise.reject(err);\n      }\n    }\n  }, {\n    key: \"_shouldCreateMoreResources\",\n    value: function _shouldCreateMoreResources() {\n      return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;\n    }\n  }, {\n    key: \"_doCreate\",\n    value: function _doCreate() {\n      var _this5 = this;\n\n      var pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\n\n      var pendingCreate = this._create();\n\n      pendingCreate.promise.then(function () {\n        // Not returned on purpose.\n        _this5._tryAcquireOrCreate();\n\n        return null;\n      }).catch(function (err) {\n        if (_this5.propagateCreateError && _this5.pendingAcquires.length !== 0) {\n          // If propagateCreateError is true, we don't retry the create\n          // but reject the first pending acquire immediately. Intentionally\n          // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\n          // in case some acquires in pendingAcquiresBeforeCreate have already\n          // been resolved.\n          _this5.pendingAcquires[0].reject(err);\n        } // Save the create error to all pending acquires so that we can use it\n        // as the error to reject the acquire if it times out.\n\n\n        pendingAcquiresBeforeCreate.forEach(function (pendingAcquire) {\n          pendingAcquire.possibleTimeoutCause = err;\n        }); // Not returned on purpose.\n\n        utils_1.delay(_this5.createRetryIntervalMillis).then(function () {\n          return _this5._tryAcquireOrCreate();\n        });\n      });\n    }\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _this6 = this;\n\n      var eventId = this.eventId++;\n\n      this._executeEventHandlers('createRequest', eventId);\n\n      var pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis); // If an error occurs (likely a create timeout) remove this creation from\n      // the list of pending creations so we try to create a new one.\n\n      pendingCreate.promise = pendingCreate.promise.catch(function (err) {\n        if (remove(_this6.pendingCreates, pendingCreate)) {\n          // TODO: figure out more consistent way for different error handlers in next rewrite\n          _this6._executeEventHandlers('createFail', eventId, err);\n        }\n\n        throw err;\n      });\n      this.pendingCreates.push(pendingCreate);\n      callbackOrPromise(this.creator).then(function (resource) {\n        if (pendingCreate.isRejected) {\n          _this6.destroyer(resource);\n\n          return null;\n        }\n\n        remove(_this6.pendingCreates, pendingCreate);\n\n        _this6.free.push(new Resource_1.Resource(resource)); // Not returned on purpose.\n\n\n        pendingCreate.resolve(resource);\n\n        _this6._executeEventHandlers('createSuccess', eventId, resource);\n\n        return null;\n      }).catch(function (err) {\n        if (pendingCreate.isRejected) {\n          return null;\n        }\n\n        if (remove(_this6.pendingCreates, pendingCreate)) {\n          _this6._executeEventHandlers('createFail', eventId, err);\n        } // Not returned on purpose.\n\n\n        pendingCreate.reject(err);\n        return null;\n      });\n      return pendingCreate;\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(resource) {\n      var _this7 = this;\n\n      var eventId = this.eventId++;\n\n      this._executeEventHandlers('destroyRequest', eventId, resource); // this.destroyer can be both synchronous and asynchronous.\n      // so we wrap it to promise to get all exceptions through same pipeline\n\n\n      var pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\n      var retVal = Promise.resolve().then(function () {\n        return _this7.destroyer(resource);\n      });\n      retVal.then(function () {\n        pendingDestroy.resolve(resource);\n      }).catch(function (err) {\n        pendingDestroy.reject(err);\n      });\n      this.pendingDestroys.push(pendingDestroy); // In case of an error there's nothing we can do here but log it.\n\n      return pendingDestroy.promise.then(function (res) {\n        _this7._executeEventHandlers('destroySuccess', eventId, resource);\n\n        return res;\n      }).catch(function (err) {\n        return _this7._logDestroyerError(eventId, resource, err);\n      }).then(function (res) {\n        var index = _this7.pendingDestroys.findIndex(function (pd) {\n          return pd === pendingDestroy;\n        });\n\n        _this7.pendingDestroys.splice(index, 1);\n\n        return res;\n      });\n    }\n  }, {\n    key: \"_logDestroyerError\",\n    value: function _logDestroyerError(eventId, resource, err) {\n      this._executeEventHandlers('destroyFail', eventId, resource, err);\n\n      this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\n    }\n  }, {\n    key: \"_startReaping\",\n    value: function _startReaping() {\n      var _this8 = this;\n\n      if (!this.interval) {\n        this._executeEventHandlers('startReaping');\n\n        this.interval = setInterval(function () {\n          return _this8.check();\n        }, this.reapIntervalMillis);\n      }\n    }\n  }, {\n    key: \"_stopReaping\",\n    value: function _stopReaping() {\n      if (this.interval !== null) {\n        this._executeEventHandlers('stopReaping');\n\n        timers_1.clearInterval(this.interval);\n      }\n\n      this.interval = null;\n    }\n  }, {\n    key: \"_executeEventHandlers\",\n    value: function _executeEventHandlers(eventName) {\n      var _this9 = this;\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var listeners = this.emitter.listeners(eventName); // just calling .emit() would stop running rest of the listeners if one them fails\n\n      listeners.forEach(function (listener) {\n        try {\n          listener.apply(void 0, args);\n        } catch (err) {\n          // There's nothing we can do here but log the error. This would otherwise\n          // leak out as an unhandled exception.\n          _this9.log(\"Tarn: event handler \\\"\".concat(eventName, \"\\\" threw an exception \").concat(err.stack), 'warn');\n        }\n      });\n    }\n  }]);\n\n  return Pool;\n}();\n\nexports.Pool = Pool;\n\nfunction remove(arr, item) {\n  var idx = arr.indexOf(item);\n\n  if (idx === -1) {\n    return false;\n  } else {\n    arr.splice(idx, 1);\n    return true;\n  }\n}\n\nfunction callbackOrPromise(func) {\n  return new Promise(function (resolve, reject) {\n    var callback = function callback(err, resource) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(resource);\n      }\n    };\n\n    utils_1.tryPromise(function () {\n      return func(callback);\n    }).then(function (res) {\n      // If the result is falsy, we assume that the callback will\n      // be called instead of interpreting the falsy value as a\n      // result value.\n      if (res) {\n        resolve(res);\n      }\n    }).catch(function (err) {\n      reject(err);\n    });\n  });\n}","map":{"version":3,"sources":["C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/tarn/dist/Pool.js"],"names":["Object","defineProperty","exports","value","PendingOperation_1","require","Resource_1","utils_1","events_1","timers_1","Pool","opt","destroyed","emitter","EventEmitter","create","Error","destroy","min","Math","round","max","checkOptionalTime","acquireTimeoutMillis","JSON","stringify","createTimeoutMillis","destroyTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","createRetryIntervalMillis","allowedKeys","validate","log","propagateCreateError","keys","key","creator","destroyer","used","free","pendingCreates","pendingAcquires","pendingDestroys","pendingValidations","interval","eventId","length","_executeEventHandlers","pendingAcquire","PendingOperation","push","promise","then","resource","catch","err","remove","Promise","reject","_tryAcquireOrCreate","i","l","splice","resolve","numFree","numUsed","numPendingAcquires","numPendingValidations","numPendingCreates","reduce","total","timestamp","now","newFree","minKeep","maxDestroy","numDestroyed","forEach","duration","_destroy","isEmpty","_stopReaping","reflect","all","map","setInterval","clearInterval","acquire","abort","pd","res","removeAllListeners","event","listener","on","removeListener","_hasFreeResources","_doAcquire","_shouldCreateMoreResources","_doCreate","shift","pop","undefined","errMessage","abortAbleValidation","stack","validationSuccess","_startReaping","isRejected","unshift","setTimeout","_validateResource","_canAcquire","pendingAcquiresBeforeCreate","slice","pendingCreate","_create","possibleTimeoutCause","delay","callbackOrPromise","Resource","pendingDestroy","retVal","_logDestroyerError","index","findIndex","check","eventName","args","listeners","arr","item","idx","indexOf","func","callback","tryPromise"],"mappings":"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","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst PendingOperation_1 = require(\"./PendingOperation\");\r\nconst Resource_1 = require(\"./Resource\");\r\nconst utils_1 = require(\"./utils\");\r\nconst events_1 = require(\"events\");\r\nconst timers_1 = require(\"timers\");\r\nclass Pool {\r\n    constructor(opt) {\r\n        this.destroyed = false;\r\n        this.emitter = new events_1.EventEmitter();\r\n        opt = opt || {};\r\n        if (!opt.create) {\r\n            throw new Error('Tarn: opt.create function most be provided');\r\n        }\r\n        if (!opt.destroy) {\r\n            throw new Error('Tarn: opt.destroy function most be provided');\r\n        }\r\n        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {\r\n            throw new Error('Tarn: opt.min must be an integer >= 0');\r\n        }\r\n        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {\r\n            throw new Error('Tarn: opt.max must be an integer > 0');\r\n        }\r\n        if (opt.min > opt.max) {\r\n            throw new Error('Tarn: opt.max is smaller than opt.min');\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {\r\n            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {\r\n            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));\r\n        }\r\n        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {\r\n            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +\r\n                JSON.stringify(opt.createRetryIntervalMillis));\r\n        }\r\n        const allowedKeys = {\r\n            create: true,\r\n            validate: true,\r\n            destroy: true,\r\n            log: true,\r\n            min: true,\r\n            max: true,\r\n            acquireTimeoutMillis: true,\r\n            createTimeoutMillis: true,\r\n            destroyTimeoutMillis: true,\r\n            idleTimeoutMillis: true,\r\n            reapIntervalMillis: true,\r\n            createRetryIntervalMillis: true,\r\n            propagateCreateError: true\r\n        };\r\n        for (const key of Object.keys(opt)) {\r\n            if (!allowedKeys[key]) {\r\n                throw new Error(`Tarn: unsupported option opt.${key}`);\r\n            }\r\n        }\r\n        this.creator = opt.create;\r\n        this.destroyer = opt.destroy;\r\n        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;\r\n        this.log = opt.log || (() => { });\r\n        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;\r\n        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;\r\n        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;\r\n        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;\r\n        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;\r\n        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;\r\n        this.propagateCreateError = !!opt.propagateCreateError;\r\n        this.min = opt.min;\r\n        this.max = opt.max;\r\n        // All the resources, which are either already acquired or which are\r\n        // considered for being passed to acquire in async validation phase.\r\n        this.used = [];\r\n        // All the resources, which are either just created and free or returned\r\n        // back to pool after using.\r\n        this.free = [];\r\n        this.pendingCreates = [];\r\n        this.pendingAcquires = [];\r\n        this.pendingDestroys = [];\r\n        // When acquire is pending, but also still in validation phase\r\n        this.pendingValidations = [];\r\n        this.destroyed = false;\r\n        this.interval = null;\r\n        this.eventId = 1;\r\n    }\r\n    numUsed() {\r\n        return this.used.length;\r\n    }\r\n    numFree() {\r\n        return this.free.length;\r\n    }\r\n    numPendingAcquires() {\r\n        return this.pendingAcquires.length;\r\n    }\r\n    numPendingValidations() {\r\n        return this.pendingValidations.length;\r\n    }\r\n    numPendingCreates() {\r\n        return this.pendingCreates.length;\r\n    }\r\n    acquire() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('acquireRequest', eventId);\r\n        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\r\n        this.pendingAcquires.push(pendingAcquire);\r\n        // If the acquire fails for whatever reason\r\n        // remove it from the pending queue.\r\n        pendingAcquire.promise = pendingAcquire.promise\r\n            .then(resource => {\r\n            this._executeEventHandlers('acquireSuccess', eventId, resource);\r\n            return resource;\r\n        })\r\n            .catch(err => {\r\n            this._executeEventHandlers('acquireFail', eventId, err);\r\n            remove(this.pendingAcquires, pendingAcquire);\r\n            return Promise.reject(err);\r\n        });\r\n        this._tryAcquireOrCreate();\r\n        return pendingAcquire;\r\n    }\r\n    release(resource) {\r\n        this._executeEventHandlers('release', resource);\r\n        for (let i = 0, l = this.used.length; i < l; ++i) {\r\n            const used = this.used[i];\r\n            if (used.resource === resource) {\r\n                this.used.splice(i, 1);\r\n                this.free.push(used.resolve());\r\n                this._tryAcquireOrCreate();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    isEmpty() {\r\n        return ([\r\n            this.numFree(),\r\n            this.numUsed(),\r\n            this.numPendingAcquires(),\r\n            this.numPendingValidations(),\r\n            this.numPendingCreates()\r\n        ].reduce((total, value) => total + value) === 0);\r\n    }\r\n    /**\r\n     * Reaping cycle.\r\n     */\r\n    check() {\r\n        const timestamp = utils_1.now();\r\n        const newFree = [];\r\n        const minKeep = this.min - this.used.length;\r\n        const maxDestroy = this.free.length - minKeep;\r\n        let numDestroyed = 0;\r\n        this.free.forEach(free => {\r\n            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&\r\n                numDestroyed < maxDestroy) {\r\n                numDestroyed++;\r\n                this._destroy(free.resource);\r\n            }\r\n            else {\r\n                newFree.push(free);\r\n            }\r\n        });\r\n        this.free = newFree;\r\n        // Pool is completely empty, stop reaping.\r\n        // Next .acquire will start reaping interval again.\r\n        if (this.isEmpty()) {\r\n            this._stopReaping();\r\n        }\r\n    }\r\n    destroy() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('poolDestroyRequest', eventId);\r\n        this._stopReaping();\r\n        this.destroyed = true;\r\n        // First wait for all the pending creates get ready.\r\n        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))\r\n            .then(() => {\r\n            // eslint-disable-next-line\r\n            return new Promise((resolve, reject) => {\r\n                // poll every 100ms and wait that all validations are ready\r\n                if (this.numPendingValidations() === 0) {\r\n                    resolve();\r\n                    return;\r\n                }\r\n                const interval = setInterval(() => {\r\n                    if (this.numPendingValidations() === 0) {\r\n                        timers_1.clearInterval(interval);\r\n                        resolve();\r\n                    }\r\n                }, 100);\r\n            });\r\n        })\r\n            .then(() => {\r\n            // Wait for all the used resources to be freed.\r\n            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));\r\n        })\r\n            .then(() => {\r\n            // Abort all pending acquires.\r\n            return Promise.all(this.pendingAcquires.map(acquire => {\r\n                acquire.abort();\r\n                return utils_1.reflect(acquire.promise);\r\n            }));\r\n        })\r\n            .then(() => {\r\n            // Now we can destroy all the freed resources.\r\n            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));\r\n        })\r\n            .then(() => {\r\n            // Also wait rest of the pending destroys to finish\r\n            return Promise.all(this.pendingDestroys.map(pd => pd.promise));\r\n        })\r\n            .then(() => {\r\n            this.free = [];\r\n            this.pendingAcquires = [];\r\n        })).then(res => {\r\n            this._executeEventHandlers('poolDestroySuccess', eventId);\r\n            this.emitter.removeAllListeners();\r\n            return res;\r\n        });\r\n    }\r\n    on(event, listener) {\r\n        this.emitter.on(event, listener);\r\n    }\r\n    removeListener(event, listener) {\r\n        this.emitter.removeListener(event, listener);\r\n    }\r\n    removeAllListeners(event) {\r\n        this.emitter.removeAllListeners(event);\r\n    }\r\n    /**\r\n     * The most important method that is called always when resources\r\n     * are created / destroyed / acquired / released. In other words\r\n     * every time when resources are moved from used to free or vice\r\n     * versa.\r\n     *\r\n     * Either assigns free resources to pendingAcquires or creates new\r\n     * resources if there is room for it in the pool.\r\n     */\r\n    _tryAcquireOrCreate() {\r\n        if (this.destroyed) {\r\n            return;\r\n        }\r\n        if (this._hasFreeResources()) {\r\n            this._doAcquire();\r\n        }\r\n        else if (this._shouldCreateMoreResources()) {\r\n            this._doCreate();\r\n        }\r\n    }\r\n    _hasFreeResources() {\r\n        return this.free.length > 0;\r\n    }\r\n    _doAcquire() {\r\n        // Acquire as many pending acquires as possible concurrently\r\n        while (this._canAcquire()) {\r\n            // To allow async validation, we actually need to move free resource\r\n            // and pending acquire temporary from their respective arrays and depending\r\n            // on validation result to either leave the free resource to used resources array\r\n            // or destroy the free resource if validation did fail.\r\n            const pendingAcquire = this.pendingAcquires.shift();\r\n            const free = this.free.pop();\r\n            if (free === undefined || pendingAcquire === undefined) {\r\n                const errMessage = 'this.free was empty while trying to acquire resource';\r\n                this.log(`Tarn: ${errMessage}`, 'warn');\r\n                throw new Error(`Internal error, should never happen. ${errMessage}`);\r\n            }\r\n            // Make sure that pendingAcquire that is being validated is not lost and\r\n            // can be freed when pool is destroyed.\r\n            this.pendingValidations.push(pendingAcquire);\r\n            // Must be added here pre-emptively to prevent logic that decides\r\n            // if new resources are created will keep on working correctly.\r\n            this.used.push(free);\r\n            // if acquire fails also pending validation, must be aborted so that pre reserved\r\n            // resource will be returned to free resources immediately\r\n            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);\r\n            // eslint-disable-next-line\r\n            pendingAcquire.promise.catch(err => {\r\n                abortAbleValidation.abort();\r\n            });\r\n            abortAbleValidation.promise\r\n                .catch(err => {\r\n                // There's nothing we can do here but log the error. This would otherwise\r\n                // leak out as an unhandled exception.\r\n                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');\r\n                return false;\r\n            })\r\n                .then(validationSuccess => {\r\n                try {\r\n                    if (validationSuccess) {\r\n                        // At least one active resource exist, start reaping.\r\n                        this._startReaping();\r\n                        pendingAcquire.resolve(free.resource);\r\n                    }\r\n                    else {\r\n                        remove(this.used, free);\r\n                        this._destroy(free.resource);\r\n                        // is acquire was canceled, failed or timed out already\r\n                        // no need to return it to pending queries\r\n                        if (!pendingAcquire.isRejected) {\r\n                            this.pendingAcquires.unshift(pendingAcquire);\r\n                        }\r\n                        // Since we destroyed an invalid resource and were not able to fulfill\r\n                        // all the pending acquires, we may need to create new ones or at\r\n                        // least run this acquire loop again to verify it. But not immediately\r\n                        // to prevent starving event loop.\r\n                        setTimeout(() => {\r\n                            this._tryAcquireOrCreate();\r\n                        }, 0);\r\n                    }\r\n                }\r\n                finally {\r\n                    remove(this.pendingValidations, pendingAcquire);\r\n                }\r\n            });\r\n            // try to validate\r\n            this._validateResource(free.resource)\r\n                .then(validationSuccess => {\r\n                abortAbleValidation.resolve(validationSuccess);\r\n            })\r\n                .catch(err => {\r\n                abortAbleValidation.reject(err);\r\n            });\r\n        }\r\n    }\r\n    _canAcquire() {\r\n        return this.free.length > 0 && this.pendingAcquires.length > 0;\r\n    }\r\n    _validateResource(resource) {\r\n        try {\r\n            return Promise.resolve(this.validate(resource));\r\n        }\r\n        catch (err) {\r\n            // prevent leaking of sync exception\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n    _shouldCreateMoreResources() {\r\n        return (this.used.length + this.pendingCreates.length < this.max &&\r\n            this.pendingCreates.length < this.pendingAcquires.length);\r\n    }\r\n    _doCreate() {\r\n        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();\r\n        const pendingCreate = this._create();\r\n        pendingCreate.promise\r\n            .then(() => {\r\n            // Not returned on purpose.\r\n            this._tryAcquireOrCreate();\r\n            return null;\r\n        })\r\n            .catch(err => {\r\n            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {\r\n                // If propagateCreateError is true, we don't retry the create\r\n                // but reject the first pending acquire immediately. Intentionally\r\n                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`\r\n                // in case some acquires in pendingAcquiresBeforeCreate have already\r\n                // been resolved.\r\n                this.pendingAcquires[0].reject(err);\r\n            }\r\n            // Save the create error to all pending acquires so that we can use it\r\n            // as the error to reject the acquire if it times out.\r\n            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {\r\n                pendingAcquire.possibleTimeoutCause = err;\r\n            });\r\n            // Not returned on purpose.\r\n            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());\r\n        });\r\n    }\r\n    _create() {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('createRequest', eventId);\r\n        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);\r\n        // If an error occurs (likely a create timeout) remove this creation from\r\n        // the list of pending creations so we try to create a new one.\r\n        pendingCreate.promise = pendingCreate.promise.catch(err => {\r\n            if (remove(this.pendingCreates, pendingCreate)) {\r\n                // TODO: figure out more consistent way for different error handlers in next rewrite\r\n                this._executeEventHandlers('createFail', eventId, err);\r\n            }\r\n            throw err;\r\n        });\r\n        this.pendingCreates.push(pendingCreate);\r\n        callbackOrPromise(this.creator)\r\n            .then(resource => {\r\n            if (pendingCreate.isRejected) {\r\n                this.destroyer(resource);\r\n                return null;\r\n            }\r\n            remove(this.pendingCreates, pendingCreate);\r\n            this.free.push(new Resource_1.Resource(resource));\r\n            // Not returned on purpose.\r\n            pendingCreate.resolve(resource);\r\n            this._executeEventHandlers('createSuccess', eventId, resource);\r\n            return null;\r\n        })\r\n            .catch(err => {\r\n            if (pendingCreate.isRejected) {\r\n                return null;\r\n            }\r\n            if (remove(this.pendingCreates, pendingCreate)) {\r\n                this._executeEventHandlers('createFail', eventId, err);\r\n            }\r\n            // Not returned on purpose.\r\n            pendingCreate.reject(err);\r\n            return null;\r\n        });\r\n        return pendingCreate;\r\n    }\r\n    _destroy(resource) {\r\n        const eventId = this.eventId++;\r\n        this._executeEventHandlers('destroyRequest', eventId, resource);\r\n        // this.destroyer can be both synchronous and asynchronous.\r\n        // so we wrap it to promise to get all exceptions through same pipeline\r\n        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);\r\n        const retVal = Promise.resolve().then(() => this.destroyer(resource));\r\n        retVal\r\n            .then(() => {\r\n            pendingDestroy.resolve(resource);\r\n        })\r\n            .catch((err) => {\r\n            pendingDestroy.reject(err);\r\n        });\r\n        this.pendingDestroys.push(pendingDestroy);\r\n        // In case of an error there's nothing we can do here but log it.\r\n        return pendingDestroy.promise\r\n            .then(res => {\r\n            this._executeEventHandlers('destroySuccess', eventId, resource);\r\n            return res;\r\n        })\r\n            .catch(err => this._logDestroyerError(eventId, resource, err))\r\n            .then(res => {\r\n            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);\r\n            this.pendingDestroys.splice(index, 1);\r\n            return res;\r\n        });\r\n    }\r\n    _logDestroyerError(eventId, resource, err) {\r\n        this._executeEventHandlers('destroyFail', eventId, resource, err);\r\n        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');\r\n    }\r\n    _startReaping() {\r\n        if (!this.interval) {\r\n            this._executeEventHandlers('startReaping');\r\n            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);\r\n        }\r\n    }\r\n    _stopReaping() {\r\n        if (this.interval !== null) {\r\n            this._executeEventHandlers('stopReaping');\r\n            timers_1.clearInterval(this.interval);\r\n        }\r\n        this.interval = null;\r\n    }\r\n    _executeEventHandlers(eventName, ...args) {\r\n        const listeners = this.emitter.listeners(eventName);\r\n        // just calling .emit() would stop running rest of the listeners if one them fails\r\n        listeners.forEach(listener => {\r\n            try {\r\n                listener(...args);\r\n            }\r\n            catch (err) {\r\n                // There's nothing we can do here but log the error. This would otherwise\r\n                // leak out as an unhandled exception.\r\n                this.log(`Tarn: event handler \"${eventName}\" threw an exception ${err.stack}`, 'warn');\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.Pool = Pool;\r\nfunction remove(arr, item) {\r\n    const idx = arr.indexOf(item);\r\n    if (idx === -1) {\r\n        return false;\r\n    }\r\n    else {\r\n        arr.splice(idx, 1);\r\n        return true;\r\n    }\r\n}\r\nfunction callbackOrPromise(func) {\r\n    return new Promise((resolve, reject) => {\r\n        const callback = (err, resource) => {\r\n            if (err) {\r\n                reject(err);\r\n            }\r\n            else {\r\n                resolve(resource);\r\n            }\r\n        };\r\n        utils_1.tryPromise(() => func(callback))\r\n            .then(res => {\r\n            // If the result is falsy, we assume that the callback will\r\n            // be called instead of interpreting the falsy value as a\r\n            // result value.\r\n            if (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n            .catch(err => {\r\n            reject(err);\r\n        });\r\n    });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}