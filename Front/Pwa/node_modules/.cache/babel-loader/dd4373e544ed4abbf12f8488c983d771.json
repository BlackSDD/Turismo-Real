{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst adal = require(\"adal-node\");\n\nconst msRest = require(\"@azure/ms-rest-js\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs_1 = require(\"fs\");\n\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\n\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\n\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\n\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\n\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\n\nconst authConstants_1 = require(\"./util/authConstants\");\n\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\n\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\n\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * Urls for management plane token\n * audience across different azure environments.\n */\n\n\nconst managementPlaneTokenAudiences = [\"https://management.core.windows.net/\", \"https://management.core.chinacloudapi.cn/\", \"https://management.core.usgovcloudapi.net/\", \"https://management.core.cloudapi.de/\", \"https://management.azure.com/\", \"https://management.core.windows.net\", \"https://management.core.chinacloudapi.cn\", \"https://management.core.usgovcloudapi.net\", \"https://management.core.cloudapi.de\", \"https://management.azure.com\"];\n\nfunction turnOnLogging() {\n  const log = adal.Logging;\n  log.setLoggingOptions({\n    level: 3,\n    log: function (level, message, error) {\n      level;\n      console.info(message);\n\n      if (error) {\n        console.error(error);\n      }\n    }\n  });\n}\n\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n  turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param username - The user name for the Organization Id account.\n * @param password - The password for the Organization Id account.\n * @param options - Object representing optional parameters.\n * @param options.clientId - The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.domain - The domain or tenant Id containing this application. Default value \"common\".\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\n */\n\n\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.clientId) {\n      options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n    }\n\n    if (!options.domain) {\n      options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    const creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment, options.tokenCache);\n    const tokenResponse = yield creds.getToken(); // The token cache gets propulated for all the tenants as a part of building the tenantList.\n\n    let tenantList = yield subscriptionUtils_1.buildTenantList(creds);\n\n    if (tenantList.length === 0 && tokenResponse.tenantId) {\n      tenantList = [tokenResponse.tenantId];\n    }\n\n    const subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\n    return {\n      credentials: creds,\n      subscriptions: subscriptionList\n    };\n  });\n}\n\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param secret - The application secret for the service principal.\n * @param domain - The domain or tenant Id containing this application.\n * @param options - Object representing optional parameters.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    const creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment, options.tokenCache);\n    yield creds.getToken();\n    const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n    return {\n      credentials: creds,\n      subscriptions: subscriptionList\n    };\n  });\n}\n\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param certificateStringOrFilePath - A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param domain - The domain or tenant Id containing this application.\n * @param options - Object representing optional parameters.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    const creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n    yield creds.getToken();\n    const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n    return {\n      credentials: creds,\n      subscriptions: subscriptionList\n    };\n  });\n}\n\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\n\nfunction validateAuthFileContent(credsObj, filePath) {\n  if (!credsObj) {\n    throw new Error(\"Please provide a credsObj to validate.\");\n  }\n\n  if (!filePath) {\n    throw new Error(\"Please provide a filePath.\");\n  }\n\n  if (!credsObj.clientId) {\n    throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n    throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.subscriptionId) {\n    throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.tenantId) {\n    throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.activeDirectoryEndpointUrl) {\n    throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.resourceManagerEndpointUrl) {\n    throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.activeDirectoryGraphResourceId) {\n    throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\n  }\n\n  if (!credsObj.sqlManagementEndpointUrl) {\n    throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\n  }\n}\n\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n  if (!authFileUrl || authFileUrl && typeof authFileUrl.valueOf() !== \"string\") {\n    throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  if (!envUrl || envUrl && typeof envUrl.valueOf() !== \"string\") {\n    throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n  }\n\n  authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n  envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n  return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set â€“n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param options - Optional parameters\n * @param options.filePath - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param options.subscriptionEnvVariableName - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param optionalCallback - The optional callback.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\n\nfunction withAuthFileWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) options = {\n      filePath: \"\"\n    };\n    const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n    const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n\n    if (!filePath) {\n      const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\n      throw new Error(msg);\n    }\n\n    let content,\n        credsObj = {};\n    const optionsForSp = {};\n    content = fs_1.readFileSync(filePath, {\n      encoding: \"utf8\"\n    });\n    credsObj = JSON.parse(content);\n    validateAuthFileContent(credsObj, filePath);\n\n    if (!credsObj.managementEndpointUrl) {\n      credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n    } // setting the subscriptionId from auth file to the environment variable\n\n\n    process.env[subscriptionEnvVariableName] = credsObj.subscriptionId; // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n\n    const envFound = {\n      name: \"\"\n    };\n    const envNames = Object.keys(ms_rest_azure_env_1.Environment);\n\n    for (let i = 0; i < envNames.length; i++) {\n      const env = envNames[i];\n      const environmentObj = ms_rest_azure_env_1.Environment[env];\n\n      if (environmentObj && environmentObj.managementEndpointUrl && foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\n        envFound.name = environmentObj.name;\n        break;\n      }\n    }\n\n    if (envFound.name) {\n      optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n    } else {\n      // create a new environment with provided info.\n      const envParams = {\n        // try to find a logical name or set the filepath as the env name.\n        name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n      };\n      const keys = Object.keys(credsObj);\n\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n\n        if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/gi) === null) {\n          if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n            envParams[key] = credsObj[key] + \"/\";\n          } else {\n            envParams[key] = credsObj[key];\n          }\n        }\n      }\n\n      if (!envParams.activeDirectoryResourceId) {\n        envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n      }\n\n      if (!envParams.portalUrl) {\n        envParams.portalUrl = \"https://portal.azure.com\";\n      }\n\n      optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n    }\n\n    if (credsObj.clientSecret) {\n      return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\n    }\n\n    return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\n  });\n}\n\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param options - Object representing optional parameters.\n *\n * @param options.clientId - The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param options.tokenAudience - The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\n *\n * @param options.domain - The domain or tenant Id containing this application. Default value is \"common\".\n *\n * @param options.environment - The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @param options.language - The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param options.userCodeResponseLogger - A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param optionalCallback - The optional callback.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\n\nfunction withInteractiveWithAuthResponse(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    if (!options.environment) {\n      options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n    }\n\n    if (!options.domain) {\n      options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n    }\n\n    if (!options.clientId) {\n      options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n    }\n\n    if (!options.tokenCache) {\n      options.tokenCache = new adal.MemoryCache();\n    }\n\n    if (!options.language) {\n      options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n    }\n\n    if (!options.tokenAudience) {\n      options.tokenAudience = options.environment.activeDirectoryResourceId;\n    }\n\n    const interactiveOptions = {};\n    interactiveOptions.tokenAudience = options.tokenAudience;\n    interactiveOptions.environment = options.environment;\n    interactiveOptions.domain = options.domain;\n    interactiveOptions.clientId = options.clientId;\n    interactiveOptions.tokenCache = options.tokenCache;\n    interactiveOptions.language = options.language;\n    interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n    const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n    const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n    interactiveOptions.context = authContext;\n\n    function tryAcquireToken(interactiveOptions, resolve, reject) {\n      authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\n        if (err) {\n          if (err.error === \"authorization_pending\") {\n            setTimeout(() => {\n              tryAcquireToken(interactiveOptions, resolve, reject);\n            }, 1000);\n          } else {\n            reject(err);\n          }\n\n          return;\n        }\n\n        if (interactiveOptions.userCodeResponseLogger) {\n          interactiveOptions.userCodeResponseLogger(userCodeRes.message);\n        } else {\n          console.log(userCodeRes.message);\n        }\n\n        return resolve(userCodeRes);\n      });\n    }\n\n    const getUserCode = new Promise((resolve, reject) => {\n      return tryAcquireToken(interactiveOptions, resolve, reject);\n    });\n    const userCodeResponse = yield getUserCode;\n    const creds = yield new Promise((resolve, reject) => {\n      return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\n        if (error) {\n          return reject(error);\n        }\n\n        const response = tokenResponse;\n        interactiveOptions.userName = response.userId;\n        interactiveOptions.authorizationScheme = response.tokenType;\n        let creds;\n\n        try {\n          creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n        } catch (err) {\n          return reject(err);\n        }\n\n        return resolve(creds);\n      });\n    });\n    const tenants = yield subscriptionUtils_1.buildTenantList(creds);\n    const subscriptions = yield _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n    return {\n      credentials: creds,\n      subscriptions: subscriptions\n    };\n  });\n}\n\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\n\nfunction withAuthFile(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withAuthFileWithAuthResponse(options).then(authRes => {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withAuthFile = withAuthFile;\n\nfunction interactive(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withInteractiveWithAuthResponse(options).then(authRes => {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.interactive = interactive;\n\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then(authRes => {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\n\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then(authRes => {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\n\nfunction withUsernamePassword(username, password, options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = undefined;\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return withUsernamePasswordWithAuthResponse(username, password, options).then(authRes => {\n      return authRes.credentials;\n    });\n  } else {\n    msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, authRes.credentials, authRes.subscriptions);\n    });\n  }\n}\n\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\n\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n  if (tokenAudience && !managementPlaneTokenAudiences.some(item => {\n    return item === tokenAudience.toLowerCase();\n  })) {\n    return Promise.resolve([]);\n  }\n\n  return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param domain - - required. The tenant id.\n * @param options - - Optional parameters\n * @param options.port - port on which the MSI service is running on the host VM. Default port is 50342\n * @param options.resource - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param options.aadEndpoint - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param callback - - the callback function.\n */\n\n\nfunction _withMSI(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n    yield creds.getToken();\n    return creds;\n  });\n}\n\nfunction loginWithVmMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return _withMSI(options);\n  } else {\n    msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\n\nfunction _withAppServiceMSI(options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!options) {\n      options = {};\n    }\n\n    const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n    yield creds.getToken();\n    return creds;\n  });\n}\n\nfunction loginWithAppServiceMSI(options, callback) {\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  const cb = callback;\n\n  if (!callback) {\n    return _withAppServiceMSI(options);\n  } else {\n    msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\n      if (err) {\n        return cb(err);\n      }\n\n      return cb(undefined, tokenRes);\n    });\n  }\n}\n\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmdArguments Arguments to the az cli command to execute.\n */\n\nfunction execAz(cmdArguments) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const azCmd = process.platform === \"win32\" ? \"az.cmd\" : \"az\";\n    return new Promise((resolve, reject) => {\n      child_process_1.execFile(azCmd, [...cmdArguments, \"--out\", \"json\"], {\n        encoding: \"utf8\"\n      }, (error, stdout) => {\n        if (error) {\n          return reject(error);\n        }\n\n        try {\n          return resolve(JSON.parse(stdout));\n        } catch (err) {\n          const msg = `An error occurred while parsing the output \"${stdout}\", of ` + `the cmd az \"${cmdArguments}\": ${err.stack}.`;\n          return reject(new Error(msg));\n        }\n      });\n    });\n  });\n}\n\nexports.execAz = execAz;","map":{"version":3,"sources":["../../lib/login.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst adal = require(\"adal-node\");\nconst msRest = require(\"@azure/ms-rest-js\");\nconst child_process_1 = require(\"child_process\");\nconst fs_1 = require(\"fs\");\nconst ms_rest_azure_env_1 = require(\"@azure/ms-rest-azure-env\");\nconst applicationTokenCredentials_1 = require(\"./credentials/applicationTokenCredentials\");\nconst applicationTokenCertificateCredentials_1 = require(\"./credentials/applicationTokenCertificateCredentials\");\nconst deviceTokenCredentials_1 = require(\"./credentials/deviceTokenCredentials\");\nconst userTokenCredentials_1 = require(\"./credentials/userTokenCredentials\");\nconst authConstants_1 = require(\"./util/authConstants\");\nconst subscriptionUtils_1 = require(\"./subscriptionManagement/subscriptionUtils\");\nconst msiVmTokenCredentials_1 = require(\"./credentials/msiVmTokenCredentials\");\nconst msiAppServiceTokenCredentials_1 = require(\"./credentials/msiAppServiceTokenCredentials\");\n/**\n * Urls for management plane token\n * audience across different azure environments.\n */\nconst managementPlaneTokenAudiences = [\n    \"https://management.core.windows.net/\",\n    \"https://management.core.chinacloudapi.cn/\",\n    \"https://management.core.usgovcloudapi.net/\",\n    \"https://management.core.cloudapi.de/\",\n    \"https://management.azure.com/\",\n    \"https://management.core.windows.net\",\n    \"https://management.core.chinacloudapi.cn\",\n    \"https://management.core.usgovcloudapi.net\",\n    \"https://management.core.cloudapi.de\",\n    \"https://management.azure.com\"\n];\nfunction turnOnLogging() {\n    const log = adal.Logging;\n    log.setLoggingOptions({\n        level: 3,\n        log: function (level, message, error) {\n            level;\n            console.info(message);\n            if (error) {\n                console.error(error);\n            }\n        }\n    });\n}\nif (process.env[\"AZURE_ADAL_LOGGING_ENABLED\"]) {\n    turnOnLogging();\n}\n/**\n * Provides a UserTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n * This method is applicable only for organizational ids that are not 2FA enabled otherwise please use interactive login.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param username - The user name for the Organization Id account.\n * @param password - The password for the Organization Id account.\n * @param options - Object representing optional parameters.\n * @param options.clientId - The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.domain - The domain or tenant Id containing this application. Default value \"common\".\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains `credentials` and an optional `subscriptions` array, and rejects with an Error.\n */\nfunction withUsernamePasswordWithAuthResponse(username, password, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = new userTokenCredentials_1.UserTokenCredentials(options.clientId, options.domain, username, password, options.tokenAudience, options.environment, options.tokenCache);\n        const tokenResponse = yield creds.getToken();\n        // The token cache gets propulated for all the tenants as a part of building the tenantList.\n        let tenantList = yield subscriptionUtils_1.buildTenantList(creds);\n        if (tenantList.length === 0 && tokenResponse.tenantId) {\n            tenantList = [tokenResponse.tenantId];\n        }\n        const subscriptionList = yield _getSubscriptions(creds, tenantList, options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withUsernamePasswordWithAuthResponse = withUsernamePasswordWithAuthResponse;\n/**\n * Provides an ApplicationTokenCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param secret - The application secret for the service principal.\n * @param domain - The domain or tenant Id containing this application.\n * @param options - Object representing optional parameters.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = new applicationTokenCredentials_1.ApplicationTokenCredentials(clientId, domain, secret, options.tokenAudience, options.environment, options.tokenCache);\n        yield creds.getToken();\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withServicePrincipalSecretWithAuthResponse = withServicePrincipalSecretWithAuthResponse;\n/**\n * Provides an ApplicationTokenCertificateCredentials object and the list of subscriptions associated with that servicePrincipalId/clientId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param clientId - The active directory application client Id also known as the SPN (ServicePrincipal Name).\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n * @param certificateStringOrFilePath - A PEM encoded certificate and private key OR an absolute filepath to the .pem file containing that information. For example:\n * - CertificateString: \"-----BEGIN PRIVATE KEY-----\\n<xxxxx>\\n-----END PRIVATE KEY-----\\n-----BEGIN CERTIFICATE-----\\n<yyyyy>\\n-----END CERTIFICATE-----\\n\"\n * - CertificateFilePath: **Absolute** file path of the .pem file.\n * @param domain - The domain or tenant Id containing this application.\n * @param options - Object representing optional parameters.\n * @param options.tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\n * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferably in a guid format).\n * @param options.environment - The azure environment to authenticate with.\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        const creds = applicationTokenCertificateCredentials_1.ApplicationTokenCertificateCredentials.create(clientId, certificateStringOrFilePath, domain, options);\n        yield creds.getToken();\n        const subscriptionList = yield _getSubscriptions(creds, [domain], options.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptionList };\n    });\n}\nexports.withServicePrincipalCertificateWithAuthResponse = withServicePrincipalCertificateWithAuthResponse;\nfunction validateAuthFileContent(credsObj, filePath) {\n    if (!credsObj) {\n        throw new Error(\"Please provide a credsObj to validate.\");\n    }\n    if (!filePath) {\n        throw new Error(\"Please provide a filePath.\");\n    }\n    if (!credsObj.clientId) {\n        throw new Error(`\"clientId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.clientSecret && !credsObj.clientCertificate) {\n        throw new Error(`Either \"clientSecret\" or \"clientCertificate\" must be present in the auth file: ${filePath}.`);\n    }\n    if (!credsObj.subscriptionId) {\n        throw new Error(`\"subscriptionId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.tenantId) {\n        throw new Error(`\"tenantId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryEndpointUrl) {\n        throw new Error(`\"activeDirectoryEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.resourceManagerEndpointUrl) {\n        throw new Error(`\"resourceManagerEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.activeDirectoryGraphResourceId) {\n        throw new Error(`\"activeDirectoryGraphResourceId\" is missing from the auth file: ${filePath}.`);\n    }\n    if (!credsObj.sqlManagementEndpointUrl) {\n        throw new Error(`\"sqlManagementEndpointUrl\" is missing from the auth file: ${filePath}.`);\n    }\n}\nfunction foundManagementEndpointUrl(authFileUrl, envUrl) {\n    if (!authFileUrl || (authFileUrl && typeof authFileUrl.valueOf() !== \"string\")) {\n        throw new Error(\"authFileUrl cannot be null or undefined and must be of type string.\");\n    }\n    if (!envUrl || (envUrl && typeof envUrl.valueOf() !== \"string\")) {\n        throw new Error(\"envUrl cannot be null or undefined and must be of type string.\");\n    }\n    authFileUrl = authFileUrl.endsWith(\"/\") ? authFileUrl.slice(0, -1) : authFileUrl;\n    envUrl = envUrl.endsWith(\"/\") ? envUrl.slice(0, -1) : envUrl;\n    return authFileUrl.toLowerCase() === envUrl.toLowerCase();\n}\n/**\n * Before using this method please install az cli from https://github.com/Azure/azure-cli/releases. Then execute `az ad sp create-for-rbac --sdk-auth > ${yourFilename.json}`.\n * If you want to create the sp for a different cloud/environment then please execute:\n * 1. az cloud list\n * 2. az cloud set â€“n <name of the environment>\n * 3. az ad sp create-for-rbac --sdk-auth > auth.json // create sp with secret\n *  **OR**\n * 3. az ad sp create-for-rbac --create-cert --sdk-auth > auth.json // create sp with certificate\n * If the service principal is already created then login with service principal info:\n * 4. az login --service-principal -u <clientId> -p <clientSecret> -t <tenantId>\n * 5. az account show --sdk-auth > auth.json\n *\n * Authenticates using the service principal information provided in the auth file. This method will set\n * the subscriptionId from the auth file to the user provided environment variable in the options\n * parameter or the default \"AZURE_SUBSCRIPTION_ID\".\n *\n * @param options - Optional parameters\n * @param options.filePath - Absolute file path to the auth file. If not provided\n * then please set the environment variable AZURE_AUTH_LOCATION.\n * @param options.subscriptionEnvVariableName - The subscriptionId environment variable\n * name. Default is \"AZURE_SUBSCRIPTION_ID\".\n * @param optionalCallback - The optional callback.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withAuthFileWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options)\n            options = { filePath: \"\" };\n        const filePath = options.filePath || process.env[authConstants_1.AuthConstants.AZURE_AUTH_LOCATION];\n        const subscriptionEnvVariableName = options.subscriptionEnvVariableName || \"AZURE_SUBSCRIPTION_ID\";\n        if (!filePath) {\n            const msg = `Either provide an absolute file path to the auth file or set/export the environment variable - ${authConstants_1.AuthConstants.AZURE_AUTH_LOCATION}.`;\n            throw new Error(msg);\n        }\n        let content, credsObj = {};\n        const optionsForSp = {};\n        content = fs_1.readFileSync(filePath, { encoding: \"utf8\" });\n        credsObj = JSON.parse(content);\n        validateAuthFileContent(credsObj, filePath);\n        if (!credsObj.managementEndpointUrl) {\n            credsObj.managementEndpointUrl = credsObj.resourceManagerEndpointUrl;\n        }\n        // setting the subscriptionId from auth file to the environment variable\n        process.env[subscriptionEnvVariableName] = credsObj.subscriptionId;\n        // get the AzureEnvironment or create a new AzureEnvironment based on the info provided in the auth file\n        const envFound = {\n            name: \"\"\n        };\n        const envNames = Object.keys(ms_rest_azure_env_1.Environment);\n        for (let i = 0; i < envNames.length; i++) {\n            const env = envNames[i];\n            const environmentObj = ms_rest_azure_env_1.Environment[env];\n            if (environmentObj &&\n                environmentObj.managementEndpointUrl &&\n                foundManagementEndpointUrl(credsObj.managementEndpointUrl, environmentObj.managementEndpointUrl)) {\n                envFound.name = environmentObj.name;\n                break;\n            }\n        }\n        if (envFound.name) {\n            optionsForSp.environment = ms_rest_azure_env_1.Environment[envFound.name];\n        }\n        else {\n            // create a new environment with provided info.\n            const envParams = {\n                // try to find a logical name or set the filepath as the env name.\n                name: credsObj.managementEndpointUrl.match(/.*management\\.core\\.(.*)\\..*/i)[1] || filePath\n            };\n            const keys = Object.keys(credsObj);\n            for (let i = 0; i < keys.length; i++) {\n                const key = keys[i];\n                if (key.match(/^(clientId|clientSecret|clientCertificate|subscriptionId|tenantId)$/gi) === null) {\n                    if (key === \"activeDirectoryEndpointUrl\" && !key.endsWith(\"/\")) {\n                        envParams[key] = credsObj[key] + \"/\";\n                    }\n                    else {\n                        envParams[key] = credsObj[key];\n                    }\n                }\n            }\n            if (!envParams.activeDirectoryResourceId) {\n                envParams.activeDirectoryResourceId = credsObj.managementEndpointUrl;\n            }\n            if (!envParams.portalUrl) {\n                envParams.portalUrl = \"https://portal.azure.com\";\n            }\n            optionsForSp.environment = ms_rest_azure_env_1.Environment.add(envParams);\n        }\n        if (credsObj.clientSecret) {\n            return withServicePrincipalSecretWithAuthResponse(credsObj.clientId, credsObj.clientSecret, credsObj.tenantId, optionsForSp);\n        }\n        return withServicePrincipalCertificateWithAuthResponse(credsObj.clientId, credsObj.clientCertificate, credsObj.tenantId, optionsForSp);\n    });\n}\nexports.withAuthFileWithAuthResponse = withAuthFileWithAuthResponse;\n/**\n * Provides a url and code that needs to be copy and pasted in a browser and authenticated over there. If successful, the user will get a DeviceTokenCredentials object and the list of subscriptions associated with that userId across all the applicable tenants.\n *\n * When using personal accounts, the `domain` property in the `options` parameter is required to be set to the Id of a tenant for that account. Otherwise, the resulting credential will not be able to access the account's resources.\n *\n * @param options - Object representing optional parameters.\n *\n * @param options.clientId - The active directory application client id.\n * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\n * for an example.\n *\n * @param options.tokenAudience - The audience for which the token is requested. Valid value is \"graph\".If tokenAudience is provided\n * then domain should also be provided its value should not be the default \"common\" tenant. It must be a string (preferably in a guid format).\n *\n * @param options.domain - The domain or tenant Id containing this application. Default value is \"common\".\n *\n * @param options.environment - The azure environment to authenticate with. Default environment is \"Public Azure\".\n *\n * @param options.tokenCache - The token cache. Default value is the MemoryCache object from adal.\n *\n * @param options.language - The language code specifying how the message should be localized to. Default value \"en-us\".\n *\n * @param options.userCodeResponseLogger - A logger that logs the user code response message required for interactive login. When\n * this option is specified the usercode response message will not be logged to console.\n *\n * @param optionalCallback - The optional callback.\n *\n * @returns A Promise that resolves to AuthResponse, which contains \"credentials\" and optional \"subscriptions\" array and rejects with an Error.\n */\nfunction withInteractiveWithAuthResponse(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        if (!options.environment) {\n            options.environment = ms_rest_azure_env_1.Environment.AzureCloud;\n        }\n        if (!options.domain) {\n            options.domain = authConstants_1.AuthConstants.AAD_COMMON_TENANT;\n        }\n        if (!options.clientId) {\n            options.clientId = authConstants_1.AuthConstants.DEFAULT_ADAL_CLIENT_ID;\n        }\n        if (!options.tokenCache) {\n            options.tokenCache = new adal.MemoryCache();\n        }\n        if (!options.language) {\n            options.language = authConstants_1.AuthConstants.DEFAULT_LANGUAGE;\n        }\n        if (!options.tokenAudience) {\n            options.tokenAudience = options.environment.activeDirectoryResourceId;\n        }\n        const interactiveOptions = {};\n        interactiveOptions.tokenAudience = options.tokenAudience;\n        interactiveOptions.environment = options.environment;\n        interactiveOptions.domain = options.domain;\n        interactiveOptions.clientId = options.clientId;\n        interactiveOptions.tokenCache = options.tokenCache;\n        interactiveOptions.language = options.language;\n        interactiveOptions.userCodeResponseLogger = options.userCodeResponseLogger;\n        const authorityUrl = interactiveOptions.environment.activeDirectoryEndpointUrl + interactiveOptions.domain;\n        const authContext = new adal.AuthenticationContext(authorityUrl, interactiveOptions.environment.validateAuthority, interactiveOptions.tokenCache);\n        interactiveOptions.context = authContext;\n        function tryAcquireToken(interactiveOptions, resolve, reject) {\n            authContext.acquireUserCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, interactiveOptions.language, (err, userCodeRes) => {\n                if (err) {\n                    if (err.error === \"authorization_pending\") {\n                        setTimeout(() => {\n                            tryAcquireToken(interactiveOptions, resolve, reject);\n                        }, 1000);\n                    }\n                    else {\n                        reject(err);\n                    }\n                    return;\n                }\n                if (interactiveOptions.userCodeResponseLogger) {\n                    interactiveOptions.userCodeResponseLogger(userCodeRes.message);\n                }\n                else {\n                    console.log(userCodeRes.message);\n                }\n                return resolve(userCodeRes);\n            });\n        }\n        const getUserCode = new Promise((resolve, reject) => {\n            return tryAcquireToken(interactiveOptions, resolve, reject);\n        });\n        const userCodeResponse = yield getUserCode;\n        const creds = yield new Promise((resolve, reject) => {\n            return authContext.acquireTokenWithDeviceCode(interactiveOptions.tokenAudience, interactiveOptions.clientId, userCodeResponse, (error, tokenResponse) => {\n                if (error) {\n                    return reject(error);\n                }\n                const response = tokenResponse;\n                interactiveOptions.userName = response.userId;\n                interactiveOptions.authorizationScheme = response.tokenType;\n                let creds;\n                try {\n                    creds = new deviceTokenCredentials_1.DeviceTokenCredentials(interactiveOptions.clientId, interactiveOptions.domain, interactiveOptions.userName, interactiveOptions.tokenAudience, interactiveOptions.environment, interactiveOptions.tokenCache);\n                }\n                catch (err) {\n                    return reject(err);\n                }\n                return resolve(creds);\n            });\n        });\n        const tenants = yield subscriptionUtils_1.buildTenantList(creds);\n        const subscriptions = yield _getSubscriptions(creds, tenants, interactiveOptions.tokenAudience);\n        return { credentials: creds, subscriptions: subscriptions };\n    });\n}\nexports.withInteractiveWithAuthResponse = withInteractiveWithAuthResponse;\nfunction withAuthFile(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withAuthFileWithAuthResponse(options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withAuthFileWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withAuthFile = withAuthFile;\nfunction interactive(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withInteractiveWithAuthResponse(options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withInteractiveWithAuthResponse(options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.interactive = interactive;\nfunction withServicePrincipalSecret(clientId, secret, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalSecretWithAuthResponse(clientId, secret, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalSecret = withServicePrincipalSecret;\nfunction withServicePrincipalCertificate(clientId, certificateStringOrFilePath, domain, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withServicePrincipalCertificateWithAuthResponse(clientId, certificateStringOrFilePath, domain, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withServicePrincipalCertificate = withServicePrincipalCertificate;\nfunction withUsernamePassword(username, password, options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    const cb = callback;\n    if (!callback) {\n        return withUsernamePasswordWithAuthResponse(username, password, options).then((authRes) => {\n            return authRes.credentials;\n        });\n    }\n    else {\n        msRest.promiseToCallback(withUsernamePasswordWithAuthResponse(username, password, options))((err, authRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, authRes.credentials, authRes.subscriptions);\n        });\n    }\n}\nexports.withUsernamePassword = withUsernamePassword;\n/**\n * We only need to get the subscription list if the tokenAudience is for a management client.\n */\nfunction _getSubscriptions(creds, tenants, tokenAudience) {\n    if (tokenAudience &&\n        !managementPlaneTokenAudiences.some((item) => {\n            return item === tokenAudience.toLowerCase();\n        })) {\n        return Promise.resolve([]);\n    }\n    return subscriptionUtils_1.getSubscriptionsFromTenants(creds, tenants);\n}\n/**\n * Initializes MSITokenCredentials class and calls getToken and returns a token response.\n *\n * @param domain - - required. The tenant id.\n * @param options - - Optional parameters\n * @param options.port - port on which the MSI service is running on the host VM. Default port is 50342\n * @param options.resource - The resource uri or token audience for which the token is needed. Default - \"https://management.azure.com/\"\n * @param options.aadEndpoint - The add endpoint for authentication. default - \"https://login.microsoftonline.com\"\n * @param callback - - the callback function.\n */\nfunction _withMSI(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        const creds = new msiVmTokenCredentials_1.MSIVmTokenCredentials(options);\n        yield creds.getToken();\n        return creds;\n    });\n}\nfunction loginWithVmMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithVmMSI = loginWithVmMSI;\n/**\n * Private method\n */\nfunction _withAppServiceMSI(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            options = {};\n        }\n        const creds = new msiAppServiceTokenCredentials_1.MSIAppServiceTokenCredentials(options);\n        yield creds.getToken();\n        return creds;\n    });\n}\nfunction loginWithAppServiceMSI(options, callback) {\n    if (!callback && typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n    const cb = callback;\n    if (!callback) {\n        return _withAppServiceMSI(options);\n    }\n    else {\n        msRest.promiseToCallback(_withAppServiceMSI(options))((err, tokenRes) => {\n            if (err) {\n                return cb(err);\n            }\n            return cb(undefined, tokenRes);\n        });\n    }\n}\nexports.loginWithAppServiceMSI = loginWithAppServiceMSI;\n/**\n * Executes the azure cli command and returns the result. It will be `undefined` if the command did\n * not return anything or a `JSON object` if the command did return something.\n * @param cmdArguments Arguments to the az cli command to execute.\n */\nfunction execAz(cmdArguments) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const azCmd = process.platform === \"win32\" ? \"az.cmd\" : \"az\";\n        return new Promise((resolve, reject) => {\n            child_process_1.execFile(azCmd, [...cmdArguments, \"--out\", \"json\"], { encoding: \"utf8\" }, (error, stdout) => {\n                if (error) {\n                    return reject(error);\n                }\n                try {\n                    return resolve(JSON.parse(stdout));\n                }\n                catch (err) {\n                    const msg = `An error occurred while parsing the output \"${stdout}\", of ` +\n                        `the cmd az \"${cmdArguments}\": ${err.stack}.`;\n                    return reject(new Error(msg));\n                }\n            });\n        });\n    });\n}\nexports.execAz = execAz;\n//# sourceMappingURL=login.js.map"]},"metadata":{},"sourceType":"script"}