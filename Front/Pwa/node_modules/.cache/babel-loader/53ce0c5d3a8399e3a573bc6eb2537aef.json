{"ast":null,"code":"'use strict';\n\nconst tds = require('tedious');\n\nconst debug = require('debug')('mssql:tedi');\n\nconst BaseRequest = require('../base/request');\n\nconst RequestError = require('../error/request-error');\n\nconst {\n  IDS,\n  objectHasProperty\n} = require('../utils');\n\nconst {\n  TYPES,\n  DECLARATIONS,\n  declare,\n  cast\n} = require('../datatypes');\n\nconst Table = require('../table');\n\nconst {\n  PARSERS: UDT\n} = require('../udt');\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nconst N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nconst getMssqlType = function (type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nconst createColumns = function (metadata, arrayRowMode) {\n  let out = {};\n  if (arrayRowMode) out = [];\n\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    const column = metadata[index];\n    const outColumn = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n\n  return out;\n};\n\nconst valueCorrection = function (value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n\n    for (const col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      });\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nclass Request extends BaseRequest {\n  /*\r\n  Execute specified sql batch.\r\n  */\n  _batch(batch, callback) {\n    this._isBatch = true;\n\n    this._query(batch, callback);\n  }\n  /*\r\n  Bulk load.\r\n  */\n\n\n  _bulk(table, options, callback) {\n    super._bulk(table, options, err => {\n      if (err) return callback(err);\n\n      try {\n        table._makeBulk();\n      } catch (e) {\n        return callback(new RequestError(e, 'EREQUEST'));\n      }\n\n      if (!table.name) {\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n      }\n\n      const errors = [];\n      const errorHandlers = {};\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection) => {\n        const callbackWithRelease = (err, ...args) => {\n          try {\n            this.parent.release(connection);\n          } catch (e) {// noop\n          }\n\n          callback(err, ...args);\n        };\n\n        if (err) return callbackWithRelease(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            hasReturned = true;\n\n            if (this.stream) {\n              callbackWithRelease(null, rowCount);\n            } else {\n              callbackWithRelease(error, rowCount);\n            }\n          }\n        };\n\n        const bulk = connection.newBulkLoad(table.path, options, done);\n\n        for (const col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {\n            nullable: col.nullable,\n            length: col.length,\n            scale: col.scale,\n            precision: col.precision\n          });\n        }\n\n        for (const row of table.rows) {\n          try {\n            bulk.addRow(row);\n          } catch (e) {\n            return handleError(true, connection, e);\n          }\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err);\n            connection.execBulkLoad(bulk);\n          });\n\n          this._setCurrentRequest(req);\n\n          connection.execSqlBatch(req);\n        } else {\n          connection.execBulkLoad(bulk);\n        }\n      });\n    });\n  }\n  /*\r\n  Execute specified sql command.\r\n  */\n\n\n  _query(command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let batchLastRow = null;\n      let batchHasOutput = false;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n        debug('request(%d): query', IDS.get(this), command);\n        const req = new tds.Request(command, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          } // process batch outputs\n\n\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0];\n\n            for (const name in batchLastRow) {\n              const value = batchLastRow[name];\n\n              if (name !== '___return___') {\n                output[name] = value;\n              }\n            }\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): completed', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns);\n              }\n            } else {\n              this.emit('recordset', columns);\n            }\n          }\n\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          } // this function is called even when select only set variables so we should skip adding a new recordset\n\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            const concatenatedChunks = chunksBuffer.join('');\n\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (concatenatedChunks === '') {\n                  row = null;\n                } else {\n                  row = JSON.parse(concatenatedChunks);\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = concatenatedChunks;\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        };\n\n        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n        req.on('done', doneHandler); // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row;\n              } else {\n                this.emit('row', row);\n              }\n            } else {\n              this.emit('row', row);\n            }\n          } else {\n            recordset.push(row);\n          }\n        });\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n\n              try {\n                param.value = getTediousType(param.type).validate(param.value);\n              } catch (e) {\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`;\n                const err = new RequestError(e, 'EPARAM');\n                this.parent.release(connection);\n                return callback(err);\n              }\n            }\n\n            const declarations = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n              declarations.push(`@${name} ${declare(param.type, param)}`);\n            }\n\n            const assigns = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);\n            }\n\n            const selects = [];\n\n            for (const name in this.parameters) {\n              if (!objectHasProperty(this.parameters, name)) {\n                continue;\n              }\n\n              const param = this.parameters[name];\n\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`);\n              }\n            }\n\n            batchHasOutput = selects.length > 0;\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? `select 1 as [___return___], ${selects.join(', ')}` : ''}`;\n          }\n        } else {\n          for (const name in this.parameters) {\n            if (!objectHasProperty(this.parameters, name)) {\n              continue;\n            }\n\n            const param = this.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n        }\n\n        try {\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);\n        } catch (error) {\n          handleError(true, connection, error);\n        }\n      });\n    });\n  }\n  /*\r\n  Execute stored procedure with specified parameters.\r\n  */\n\n\n  _execute(procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err);\n      const recordsets = [];\n      const recordsetcolumns = [];\n      const errors = [];\n      const errorHandlers = {};\n      const output = {};\n      const rowsAffected = [];\n      let columns = {};\n      let recordset = [];\n      let returnValue = 0;\n      let isChunkedRecordset = false;\n      let chunksBuffer = null;\n      let hasReturned = false;\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message);\n        err.info = info;\n        err = new RequestError(err, 'EREQUEST');\n\n        if (this.stream) {\n          this.emit('error', err);\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (const event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              this.parent.release(connection);\n            }\n\n            hasReturned = true;\n            callback(err);\n          }\n        } // we must collect errors even in stream mode\n\n\n        errors.push(err);\n      };\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        });\n      };\n\n      this.parent.acquire(this, (err, connection, config) => {\n        if (err) return callback(err);\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));\n        let row;\n\n        if (this.canceled) {\n          debug('request(%d): canceled', IDS.get(this));\n          this.parent.release(connection);\n          return callback(new RequestError('Canceled.', 'ECANCEL'));\n        }\n\n        this._cancel = () => {\n          debug('request(%d): cancel', IDS.get(this));\n          connection.cancel();\n        }; // attach handler to handle multiple error messages\n\n\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n        if (debug.enabled) {\n          // log stored procedure executions and provided parameters\n          const params = Object.keys(this.parameters).map(k => this.parameters[k]); // cut long string parameters short to keep log somewhat clean\n\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s; // format parameter names as 'my_parameter [sql.Int]'\n\n\n          const logName = param => param.name + ' [sql.' + param.type.name + ']';\n\n          const logParams = {};\n          params.forEach(p => {\n            logParams[logName(p)] = logValue(p.value);\n          });\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams);\n        }\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n            err = new RequestError(err, 'EREQUEST');\n            if (this.stream) this.emit('error', err);\n            errors.push(err);\n          }\n\n          delete this._cancel;\n          let error;\n\n          if (errors.length && !this.stream) {\n            error = errors.pop();\n            error.precedingErrors = errors;\n          }\n\n          if (!hasReturned) {\n            for (const event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event]);\n            }\n\n            this.parent.release(connection);\n            hasReturned = true;\n\n            if (error) {\n              debug('request(%d): failed', IDS.get(this), error);\n            } else {\n              debug('request(%d): complete', IDS.get(this));\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n            }\n          }\n        });\n\n        this._setCurrentRequest(req);\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata, this.arrayRowMode);\n          isChunkedRecordset = false;\n\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true;\n            chunksBuffer = [];\n          }\n\n          if (this.stream) this.emit('recordset', columns);\n          if (this.arrayRowMode) recordsetcolumns.push(columns);\n        });\n        req.on('row', columns => {\n          if (!recordset) recordset = [];\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value);\n          }\n\n          if (this.arrayRowMode) {\n            row = [];\n          } else {\n            row = {};\n          }\n\n          for (const col of columns) {\n            col.value = valueCorrection(col.value, col.metadata);\n\n            if (this.arrayRowMode) {\n              row.push(col.value);\n            } else {\n              const exi = row[col.metadata.colName];\n\n              if (exi != null) {\n                if (exi instanceof Array) {\n                  exi.push(col.value);\n                } else {\n                  row[col.metadata.colName] = [exi, col.value];\n                }\n              } else {\n                row[col.metadata.colName] = col.value;\n              }\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row);\n          } else {\n            recordset.push(row);\n          }\n        });\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) {\n            rowsAffected.push(rowCount);\n\n            if (this.stream) {\n              this.emit('rowsaffected', rowCount);\n            }\n          } // filter empty recordsets when NOCOUNT is OFF\n\n\n          if (Object.keys(columns).length === 0) return;\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n              try {\n                if (chunksBuffer.length === 0) {\n                  row = null;\n                } else {\n                  row = JSON.parse(chunksBuffer.join(''));\n                }\n              } catch (ex) {\n                row = null;\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');\n                if (this.stream) this.emit('error', ex2); // we must collect errors even in stream mode\n\n                errors.push(ex2);\n              }\n            } else {\n              row = {};\n              row[Object.keys(columns)[0]] = chunksBuffer.join('');\n            }\n\n            chunksBuffer = null;\n\n            if (this.stream) {\n              this.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            });\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n\n              value(name) {\n                return Table.fromRecordset(this, name);\n              }\n\n            });\n            recordsets.push(recordset);\n          }\n\n          recordset = [];\n          columns = {};\n        });\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus;\n        });\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value;\n        });\n\n        for (const name in this.parameters) {\n          if (!objectHasProperty(this.parameters, name)) {\n            continue;\n          }\n\n          const param = this.parameters[name];\n\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n              length: param.length,\n              scale: param.scale,\n              precision: param.precision\n            });\n          }\n        }\n\n        connection.callProcedure(req);\n      });\n    });\n  }\n\n  _pause() {\n    super._pause();\n\n    if (this._currentRequest) {\n      this._currentRequest.pause();\n    }\n  }\n\n  _resume() {\n    super._resume();\n\n    if (this._currentRequest) {\n      this._currentRequest.resume();\n    }\n  }\n\n}\n\nmodule.exports = Request;","map":{"version":3,"sources":["B:/Duoc/Portafolio_de_titulo/Git/Turismo-Real/Front/Pwa/node_modules/mssql/lib/tedious/request.js"],"names":["tds","require","debug","BaseRequest","RequestError","IDS","objectHasProperty","TYPES","DECLARATIONS","declare","cast","Table","PARSERS","UDT","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","arrayRowMode","out","index","column","outColumn","name","colName","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","push","valueCorrection","value","parameterCorrection","tvp","columns","rows","col","Request","_batch","batch","callback","_isBatch","_query","_bulk","table","options","err","_makeBulk","e","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","callbackWithRelease","args","get","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","done","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","addColumn","row","addRow","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","recordsets","recordsetcolumns","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","exi","Array","parameters","param","validate","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","_execute","procedure","returnValue","enabled","params","map","k","logValue","s","substring","logName","logParams","forEach","p","returnStatus","callProcedure","_pause","_currentRequest","pause","_resume","resume","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst tds = require('tedious')\r\nconst debug = require('debug')('mssql:tedi')\r\nconst BaseRequest = require('../base/request')\r\nconst RequestError = require('../error/request-error')\r\nconst { IDS, objectHasProperty } = require('../utils')\r\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\r\nconst Table = require('../table')\r\nconst { PARSERS: UDT } = require('../udt')\r\n\r\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\r\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\r\n\r\nconst N_TYPES = {\r\n  BitN: 0x68,\r\n  DateTimeN: 0x6F,\r\n  DecimalN: 0x6A,\r\n  FloatN: 0x6D,\r\n  IntN: 0x26,\r\n  MoneyN: 0x6E,\r\n  NumericN: 0x6C\r\n}\r\n\r\nconst getTediousType = function (type) {\r\n  switch (type) {\r\n    case TYPES.VarChar: return tds.TYPES.VarChar\r\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\r\n    case TYPES.Text: return tds.TYPES.Text\r\n    case TYPES.Int: return tds.TYPES.Int\r\n    case TYPES.BigInt: return tds.TYPES.BigInt\r\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\r\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\r\n    case TYPES.Bit: return tds.TYPES.Bit\r\n    case TYPES.Float: return tds.TYPES.Float\r\n    case TYPES.Decimal: return tds.TYPES.Decimal\r\n    case TYPES.Numeric: return tds.TYPES.Numeric\r\n    case TYPES.Real: return tds.TYPES.Real\r\n    case TYPES.Money: return tds.TYPES.Money\r\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\r\n    case TYPES.Time: return tds.TYPES.Time\r\n    case TYPES.Date: return tds.TYPES.Date\r\n    case TYPES.DateTime: return tds.TYPES.DateTime\r\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\r\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\r\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\r\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\r\n    case TYPES.Xml: return tds.TYPES.NVarChar\r\n    case TYPES.Char: return tds.TYPES.Char\r\n    case TYPES.NChar: return tds.TYPES.NChar\r\n    case TYPES.NText: return tds.TYPES.NVarChar\r\n    case TYPES.Image: return tds.TYPES.Image\r\n    case TYPES.Binary: return tds.TYPES.Binary\r\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\r\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\r\n    case TYPES.TVP: return tds.TYPES.TVP\r\n    case TYPES.Variant: return tds.TYPES.Variant\r\n    default: return type\r\n  }\r\n}\r\n\r\nconst getMssqlType = function (type, length) {\r\n  if (typeof type !== 'object') return undefined\r\n\r\n  switch (type) {\r\n    case tds.TYPES.Char: return TYPES.Char\r\n    case tds.TYPES.NChar: return TYPES.NChar\r\n    case tds.TYPES.VarChar: return TYPES.VarChar\r\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\r\n    case tds.TYPES.Text: return TYPES.Text\r\n    case tds.TYPES.NText: return TYPES.NText\r\n    case tds.TYPES.Int: return TYPES.Int\r\n    case tds.TYPES.BigInt: return TYPES.BigInt\r\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\r\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\r\n    case tds.TYPES.Bit: return TYPES.Bit\r\n    case tds.TYPES.Float: return TYPES.Float\r\n    case tds.TYPES.Real: return TYPES.Real\r\n    case tds.TYPES.Money: return TYPES.Money\r\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\r\n    case tds.TYPES.Numeric: return TYPES.Numeric\r\n    case tds.TYPES.Decimal: return TYPES.Decimal\r\n    case tds.TYPES.DateTime: return TYPES.DateTime\r\n    case tds.TYPES.Time: return TYPES.Time\r\n    case tds.TYPES.Date: return TYPES.Date\r\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\r\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\r\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\r\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\r\n    case tds.TYPES.Image: return TYPES.Image\r\n    case tds.TYPES.Binary: return TYPES.Binary\r\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\r\n    case tds.TYPES.Xml: return TYPES.Xml\r\n    case tds.TYPES.UDT: return TYPES.UDT\r\n    case tds.TYPES.TVP: return TYPES.TVP\r\n    case tds.TYPES.Variant: return TYPES.Variant\r\n    default:\r\n      switch (type.id) {\r\n        case N_TYPES.BitN: return TYPES.Bit\r\n        case N_TYPES.NumericN: return TYPES.Numeric\r\n        case N_TYPES.DecimalN: return TYPES.Decimal\r\n        case N_TYPES.IntN:\r\n          if (length === 8) return TYPES.BigInt\r\n          if (length === 4) return TYPES.Int\r\n          if (length === 2) return TYPES.SmallInt\r\n          return TYPES.TinyInt\r\n        case N_TYPES.FloatN:\r\n          if (length === 8) return TYPES.Float\r\n          return TYPES.Real\r\n        case N_TYPES.MoneyN:\r\n          if (length === 8) return TYPES.Money\r\n          return TYPES.SmallMoney\r\n        case N_TYPES.DateTimeN:\r\n          if (length === 8) return TYPES.DateTime\r\n          return TYPES.SmallDateTime\r\n      }\r\n  }\r\n}\r\n\r\nconst createColumns = function (metadata, arrayRowMode) {\r\n  let out = {}\r\n  if (arrayRowMode) out = []\r\n  for (let index = 0, length = metadata.length; index < length; index++) {\r\n    const column = metadata[index]\r\n    const outColumn = {\r\n      index,\r\n      name: column.colName,\r\n      length: column.dataLength,\r\n      type: getMssqlType(column.type, column.dataLength),\r\n      scale: column.scale,\r\n      precision: column.precision,\r\n      nullable: !!(column.flags & 0x01),\r\n      caseSensitive: !!(column.flags & 0x02),\r\n      identity: !!(column.flags & 0x10),\r\n      readOnly: !(column.flags & 0x0C)\r\n    }\r\n\r\n    if (column.udtInfo) {\r\n      outColumn.udt = {\r\n        name: column.udtInfo.typeName,\r\n        database: column.udtInfo.dbname,\r\n        schema: column.udtInfo.owningSchema,\r\n        assembly: column.udtInfo.assemblyName\r\n      }\r\n\r\n      if (DECLARATIONS[column.udtInfo.typeName]) {\r\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName]\r\n      }\r\n    }\r\n\r\n    if (arrayRowMode) {\r\n      out.push(outColumn)\r\n    } else {\r\n      out[column.colName] = outColumn\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\nconst valueCorrection = function (value, metadata) {\r\n  if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\r\n    if (UDT[metadata.udtInfo.typeName]) {\r\n      return UDT[metadata.udtInfo.typeName](value)\r\n    } else {\r\n      return value\r\n    }\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nconst parameterCorrection = function (value) {\r\n  if (value instanceof Table) {\r\n    const tvp = {\r\n      name: value.name,\r\n      schema: value.schema,\r\n      columns: [],\r\n      rows: value.rows\r\n    }\r\n\r\n    for (const col of value.columns) {\r\n      tvp.columns.push({\r\n        name: col.name,\r\n        type: getTediousType(col.type),\r\n        length: col.length,\r\n        scale: col.scale,\r\n        precision: col.precision\r\n      })\r\n    }\r\n\r\n    return tvp\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nclass Request extends BaseRequest {\r\n  /*\r\n  Execute specified sql batch.\r\n  */\r\n\r\n  _batch (batch, callback) {\r\n    this._isBatch = true\r\n    this._query(batch, callback)\r\n  }\r\n\r\n  /*\r\n  Bulk load.\r\n  */\r\n\r\n  _bulk (table, options, callback) {\r\n    super._bulk(table, options, err => {\r\n      if (err) return callback(err)\r\n\r\n      try {\r\n        table._makeBulk()\r\n      } catch (e) {\r\n        return callback(new RequestError(e, 'EREQUEST'))\r\n      }\r\n\r\n      if (!table.name) {\r\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\r\n      }\r\n\r\n      if (table.name.charAt(0) === '@') {\r\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\r\n      }\r\n\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection) => {\r\n        const callbackWithRelease = (err, ...args) => {\r\n          try {\r\n            this.parent.release(connection)\r\n          } catch (e) {\r\n            // noop\r\n          }\r\n          callback(err, ...args)\r\n        }\r\n        if (err) return callbackWithRelease(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        const done = (err, rowCount) => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            hasReturned = true\r\n\r\n            if (this.stream) {\r\n              callbackWithRelease(null, rowCount)\r\n            } else {\r\n              callbackWithRelease(error, rowCount)\r\n            }\r\n          }\r\n        }\r\n\r\n        const bulk = connection.newBulkLoad(table.path, options, done)\r\n\r\n        for (const col of table.columns) {\r\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\r\n        }\r\n\r\n        for (const row of table.rows) {\r\n          try {\r\n            bulk.addRow(row)\r\n          } catch (e) {\r\n            return handleError(true, connection, e)\r\n          }\r\n        }\r\n\r\n        if (table.create) {\r\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\r\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\r\n            if (err) return done(err)\r\n\r\n            connection.execBulkLoad(bulk)\r\n          })\r\n          this._setCurrentRequest(req)\r\n\r\n          connection.execSqlBatch(req)\r\n        } else {\r\n          connection.execBulkLoad(bulk)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute specified sql command.\r\n  */\r\n\r\n  _query (command, callback) {\r\n    super._query(command, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const recordsetcolumns = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let batchLastRow = null\r\n      let batchHasOutput = false\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        debug('request(%d): query', IDS.get(this), command)\r\n\r\n        const req = new tds.Request(command, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          // process batch outputs\r\n          if (batchHasOutput) {\r\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\r\n\r\n            for (const name in batchLastRow) {\r\n              const value = batchLastRow[name]\r\n              if (name !== '___return___') {\r\n                output[name] = value\r\n              }\r\n            }\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): completed', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, rowsAffected, recordsetcolumns)\r\n            } else {\r\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata, this.arrayRowMode)\r\n\r\n          isChunkedRecordset = false\r\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // don't stream recordset with output values in batches\r\n              if (!columns.___return___) {\r\n                this.emit('recordset', columns)\r\n              }\r\n            } else {\r\n              this.emit('recordset', columns)\r\n            }\r\n          }\r\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\r\n        })\r\n\r\n        const doneHandler = (rowCount, more) => {\r\n          if (rowCount != null) {\r\n            rowsAffected.push(rowCount)\r\n            if (this.stream) {\r\n              this.emit('rowsaffected', rowCount)\r\n            }\r\n          }\r\n          // this function is called even when select only set variables so we should skip adding a new recordset\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            const concatenatedChunks = chunksBuffer.join('')\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (concatenatedChunks === '') {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(concatenatedChunks)\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = concatenatedChunks\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        }\r\n\r\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\r\n        req.on('done', doneHandler) // done handlers are used in batches\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          if (this.arrayRowMode) {\r\n            row = []\r\n          } else {\r\n            row = {}\r\n          }\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            if (this.arrayRowMode) {\r\n              row.push(col.value)\r\n            } else {\r\n              const exi = row[col.metadata.colName]\r\n              if (exi != null) {\r\n                if (exi instanceof Array) {\r\n                  exi.push(col.value)\r\n                } else {\r\n                  row[col.metadata.colName] = [exi, col.value]\r\n                }\r\n              } else {\r\n                row[col.metadata.colName] = col.value\r\n              }\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // dont stream recordset with output values in batches\r\n              if (row.___return___) {\r\n                batchLastRow = row\r\n              } else {\r\n                this.emit('row', row)\r\n              }\r\n            } else {\r\n              this.emit('row', row)\r\n            }\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        if (this._isBatch) {\r\n          if (Object.keys(this.parameters).length) {\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n\r\n              try {\r\n                param.value = getTediousType(param.type).validate(param.value)\r\n              } catch (e) {\r\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`\r\n                const err = new RequestError(e, 'EPARAM')\r\n\r\n                this.parent.release(connection)\r\n                return callback(err)\r\n              }\r\n            }\r\n\r\n            const declarations = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              declarations.push(`@${name} ${declare(param.type, param)}`)\r\n            }\r\n\r\n            const assigns = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\r\n            }\r\n\r\n            const selects = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              if (param.io === 2) {\r\n                selects.push(`@${name} as [${name}]`)\r\n              }\r\n            }\r\n\r\n            batchHasOutput = selects.length > 0\r\n\r\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\r\n          }\r\n        } else {\r\n          for (const name in this.parameters) {\r\n            if (!objectHasProperty(this.parameters, name)) {\r\n              continue\r\n            }\r\n            const param = this.parameters[name]\r\n            if (param.io === 1) {\r\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            } else {\r\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            }\r\n          }\r\n        }\r\n\r\n        try {\r\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\r\n        } catch (error) {\r\n          handleError(true, connection, error)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute stored procedure with specified parameters.\r\n  */\r\n\r\n  _execute (procedure, callback) {\r\n    super._execute(procedure, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const recordsetcolumns = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let returnValue = 0\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        if (debug.enabled) {\r\n          // log stored procedure executions and provided parameters\r\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\r\n          // cut long string parameters short to keep log somewhat clean\r\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\r\n          // format parameter names as 'my_parameter [sql.Int]'\r\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\r\n          const logParams = {}\r\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\r\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\r\n        }\r\n\r\n        const req = new tds.Request(procedure, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): complete', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns)\r\n            } else {\r\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata, this.arrayRowMode)\r\n\r\n          isChunkedRecordset = false\r\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) this.emit('recordset', columns)\r\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          if (this.arrayRowMode) {\r\n            row = []\r\n          } else {\r\n            row = {}\r\n          }\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            if (this.arrayRowMode) {\r\n              row.push(col.value)\r\n            } else {\r\n              const exi = row[col.metadata.colName]\r\n              if (exi != null) {\r\n                if (exi instanceof Array) {\r\n                  exi.push(col.value)\r\n                } else {\r\n                  row[col.metadata.colName] = [exi, col.value]\r\n                }\r\n              } else {\r\n                row[col.metadata.colName] = col.value\r\n              }\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            this.emit('row', row)\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        req.on('doneInProc', (rowCount, more) => {\r\n          if (rowCount != null) {\r\n            rowsAffected.push(rowCount)\r\n            if (this.stream) {\r\n              this.emit('rowsaffected', rowCount)\r\n            }\r\n          }\r\n\r\n          // filter empty recordsets when NOCOUNT is OFF\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (chunksBuffer.length === 0) {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(chunksBuffer.join(''))\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        })\r\n\r\n        req.on('doneProc', (rowCount, more, returnStatus) => {\r\n          returnValue = returnStatus\r\n        })\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        for (const name in this.parameters) {\r\n          if (!objectHasProperty(this.parameters, name)) {\r\n            continue\r\n          }\r\n          const param = this.parameters[name]\r\n          if (param.io === 1) {\r\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          } else {\r\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          }\r\n        }\r\n\r\n        connection.callProcedure(req)\r\n      })\r\n    })\r\n  }\r\n\r\n  _pause () {\r\n    super._pause()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.pause()\r\n    }\r\n  }\r\n\r\n  _resume () {\r\n    super._resume()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.resume()\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Request\r\n"]},"metadata":{},"sourceType":"script"}