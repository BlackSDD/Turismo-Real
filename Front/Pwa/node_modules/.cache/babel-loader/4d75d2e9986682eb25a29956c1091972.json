{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\n\nconst authConstants_1 = require(\"../util/authConstants\");\n\nclass ApplicationTokenCredentialsBase extends tokenCredentialsBase_1.TokenCredentialsBase {\n  /**\r\n   * Creates a new ApplicationTokenCredentials object.\r\n   * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n   * for detailed instructions on creating an Azure Active Directory application.\r\n   *\r\n   * @param clientId - The active directory application client id.\r\n   * @param domain - The domain or tenant id containing this application.\r\n   * @param tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n   * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\r\n   * @param environment - The azure environment to authenticate with.\r\n   * @param tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n   */\n  constructor(clientId, domain, tokenAudience, environment, tokenCache) {\n    super(clientId, domain, tokenAudience, environment, tokenCache);\n  }\n\n  getTokenFromCache() {\n    const _super = Object.create(null, {\n      getTokenFromCache: {\n        get: () => super.getTokenFromCache\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      // a thin wrapper over the base implementation. try get token from cache, additionaly clean up cache if required.\n      try {\n        return yield _super.getTokenFromCache.call(this, undefined);\n      } catch (error) {\n        // Remove the stale token from the tokencache. ADAL gives the same error message \"Entry not found in cache.\"\n        // for entry not being present in the cache and for accessToken being expired in the cache. We do not want the token cache\n        // to contain the expired token, we clean it up here.\n        const status = yield this.removeInvalidItemsFromCache({\n          _clientId: this.clientId\n        });\n\n        if (status.result) {\n          throw error;\n        }\n\n        const message = status && status.details && status.details.message ? status.details.message : status.details;\n        throw new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR + \" : \" + \"critical failure while removing expired token for service principal from token cache. \" + message);\n      }\n    });\n  }\n  /**\r\n   * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\r\n   * Rather we resolve with an object that says the result is false and error information is provided in\r\n   * the details property of the resolved object. This is done to do better error handling in the above function\r\n   * where removeInvalidItemsFromCache() is called.\r\n   * @param query - The query to be used for finding the token for service principal from the cache\r\n   * @returns resultObject with more info.\r\n   */\n\n\n  removeInvalidItemsFromCache(query) {\n    const self = this;\n    return new Promise(resolve => {\n      self.tokenCache.find(query, (error, entries) => {\n        if (error) {\n          return resolve({\n            result: false,\n            details: error\n          });\n        }\n\n        if (entries && entries.length > 0) {\n          return self.tokenCache.remove(entries, err => {\n            if (err) {\n              return resolve({\n                result: false,\n                details: err\n              });\n            }\n\n            return resolve({\n              result: true\n            });\n          });\n        } else {\n          return resolve({\n            result: true\n          });\n        }\n      });\n    });\n  }\n\n}\n\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;","map":{"version":3,"sources":["../../../lib/credentials/applicationTokenCredentialsBase.ts"],"names":[],"mappings":"cAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AAEA,MAAA,eAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;AAGA,MAAsB,+BAAtB,SAA8D,sBAAA,CAAA,oBAA9D,CAAkF;AAChF;;;;;;;;;;;AAWG;AACH,EAAA,WAAA,CACE,QADF,EAEE,MAFF,EAGE,aAHF,EAIE,WAJF,EAKE,UALF,EAKyB;AAEvB,UAAM,QAAN,EAAgB,MAAhB,EAAwB,aAAxB,EAAuC,WAAvC,EAAoD,UAApD;AACD;;AAEe,EAAA,iBAAiB,GAAA;;;;;;;;AAC/B;AACA,UAAI;AACF,eAAO,MAAM,MAAA,CAAM,iBAAN,CAAuB,IAAvB,CAAuB,IAAvB,EAAwB,SAAxB,CAAb;AACD,OAFD,CAEE,OAAO,KAAP,EAAc;AACd;AACA;AACA;AACA,cAAM,MAAM,GAAG,MAAM,KAAK,2BAAL,CAAiC;AACpD,UAAA,SAAS,EAAE,KAAK;AADoC,SAAjC,CAArB;;AAIA,YAAI,MAAM,CAAC,MAAX,EAAmB;AACjB,gBAAM,KAAN;AACD;;AAED,cAAM,OAAO,GACX,MAAM,IAAI,MAAM,CAAC,OAAjB,IAA4B,MAAM,CAAC,OAAP,CAAe,OAA3C,GACI,MAAM,CAAC,OAAP,CAAe,OADnB,GAEI,MAAM,CAAC,OAHb;AAKA,cAAM,IAAI,KAAJ,CACJ,eAAA,CAAA,aAAA,CAAc,kBAAd,GACE,KADF,GAEE,wFAFF,GAGE,OAJE,CAAN;AAMD;AACF,K;AAAA;AAED;;;;;;;AAOG;;;AACK,EAAA,2BAA2B,CACjC,KADiC,EACpB;AAEb,UAAM,IAAI,GAAG,IAAb;AACA,WAAO,IAAI,OAAJ,CAAmD,OAAD,IAAY;AACnE,MAAA,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,KAArB,EAA4B,CAAC,KAAD,EAAe,OAAf,KAAiC;AAC3D,YAAI,KAAJ,EAAW;AACT,iBAAO,OAAO,CAAC;AAAE,YAAA,MAAM,EAAE,KAAV;AAAiB,YAAA,OAAO,EAAE;AAA1B,WAAD,CAAd;AACD;;AAED,YAAI,OAAO,IAAI,OAAO,CAAC,MAAR,GAAiB,CAAhC,EAAmC;AACjC,iBAAO,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,OAAvB,EAAiC,GAAD,IAAe;AACpD,gBAAI,GAAJ,EAAS;AACP,qBAAO,OAAO,CAAC;AAAE,gBAAA,MAAM,EAAE,KAAV;AAAiB,gBAAA,OAAO,EAAE;AAA1B,eAAD,CAAd;AACD;;AACD,mBAAO,OAAO,CAAC;AAAE,cAAA,MAAM,EAAE;AAAV,aAAD,CAAd;AACD,WALM,CAAP;AAMD,SAPD,MAOO;AACL,iBAAO,OAAO,CAAC;AAAE,YAAA,MAAM,EAAE;AAAV,WAAD,CAAd;AACD;AACF,OAfD;AAgBD,KAjBM,CAAP;AAkBD;;AAnF+E;;AAAlF,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst tokenCredentialsBase_1 = require(\"./tokenCredentialsBase\");\r\nconst authConstants_1 = require(\"../util/authConstants\");\r\nclass ApplicationTokenCredentialsBase extends tokenCredentialsBase_1.TokenCredentialsBase {\r\n    /**\r\n     * Creates a new ApplicationTokenCredentials object.\r\n     * See {@link https://azure.microsoft.com/en-us/documentation/articles/active-directory-devquickstarts-dotnet/ Active Directory Quickstart for .Net}\r\n     * for detailed instructions on creating an Azure Active Directory application.\r\n     *\r\n     * @param clientId - The active directory application client id.\r\n     * @param domain - The domain or tenant id containing this application.\r\n     * @param tokenAudience - The audience for which the token is requested. Valid values are 'graph', 'batch', or any other resource like 'https://vault.azure.net/'.\r\n     * If tokenAudience is 'graph' then domain should also be provided and its value should not be the default 'common' tenant. It must be a string (preferrably in a guid format).\r\n     * @param environment - The azure environment to authenticate with.\r\n     * @param tokenCache - The token cache. Default value is the MemoryCache object from adal.\r\n     */\r\n    constructor(clientId, domain, tokenAudience, environment, tokenCache) {\r\n        super(clientId, domain, tokenAudience, environment, tokenCache);\r\n    }\r\n    getTokenFromCache() {\r\n        const _super = Object.create(null, {\r\n            getTokenFromCache: { get: () => super.getTokenFromCache }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // a thin wrapper over the base implementation. try get token from cache, additionaly clean up cache if required.\r\n            try {\r\n                return yield _super.getTokenFromCache.call(this, undefined);\r\n            }\r\n            catch (error) {\r\n                // Remove the stale token from the tokencache. ADAL gives the same error message \"Entry not found in cache.\"\r\n                // for entry not being present in the cache and for accessToken being expired in the cache. We do not want the token cache\r\n                // to contain the expired token, we clean it up here.\r\n                const status = yield this.removeInvalidItemsFromCache({\r\n                    _clientId: this.clientId\r\n                });\r\n                if (status.result) {\r\n                    throw error;\r\n                }\r\n                const message = status && status.details && status.details.message\r\n                    ? status.details.message\r\n                    : status.details;\r\n                throw new Error(authConstants_1.AuthConstants.SDK_INTERNAL_ERROR +\r\n                    \" : \" +\r\n                    \"critical failure while removing expired token for service principal from token cache. \" +\r\n                    message);\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Removes invalid items from token cache. This method is different. Here we never reject in case of error.\r\n     * Rather we resolve with an object that says the result is false and error information is provided in\r\n     * the details property of the resolved object. This is done to do better error handling in the above function\r\n     * where removeInvalidItemsFromCache() is called.\r\n     * @param query - The query to be used for finding the token for service principal from the cache\r\n     * @returns resultObject with more info.\r\n     */\r\n    removeInvalidItemsFromCache(query) {\r\n        const self = this;\r\n        return new Promise((resolve) => {\r\n            self.tokenCache.find(query, (error, entries) => {\r\n                if (error) {\r\n                    return resolve({ result: false, details: error });\r\n                }\r\n                if (entries && entries.length > 0) {\r\n                    return self.tokenCache.remove(entries, (err) => {\r\n                        if (err) {\r\n                            return resolve({ result: false, details: err });\r\n                        }\r\n                        return resolve({ result: true });\r\n                    });\r\n                }\r\n                else {\r\n                    return resolve({ result: true });\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\nexports.ApplicationTokenCredentialsBase = ApplicationTokenCredentialsBase;\r\n//# sourceMappingURL=applicationTokenCredentialsBase.js.map"]},"metadata":{},"sourceType":"script"}