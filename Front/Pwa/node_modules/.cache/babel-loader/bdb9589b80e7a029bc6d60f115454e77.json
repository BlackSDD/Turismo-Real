{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nimport { __awaiter, __extends, __generator } from \"tslib\";\nimport * as utils from \"../util/utils\";\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: function create(nextPolicy, options) {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\r\n * @class\r\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\r\n *\r\n * @constructor\r\n * @param {number} retryCount        The client retry count.\r\n * @param {number} retryInterval     The client retry interval, in milliseconds.\r\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\r\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\r\n */\n\nvar SystemErrorRetryPolicy =\n/** @class */\nfunction (_super) {\n  __extends(SystemErrorRetryPolicy, _super);\n\n  function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    var _this = _super.call(this, nextPolicy, options) || this;\n\n    _this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n    _this.DEFAULT_CLIENT_RETRY_COUNT = 3;\n    _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n    _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n    _this.retryCount = typeof retryCount === \"number\" ? retryCount : _this.DEFAULT_CLIENT_RETRY_COUNT;\n    _this.retryInterval = typeof retryInterval === \"number\" ? retryInterval : _this.DEFAULT_CLIENT_RETRY_INTERVAL;\n    _this.minRetryInterval = typeof minRetryInterval === \"number\" ? minRetryInterval : _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    _this.maxRetryInterval = typeof maxRetryInterval === \"number\" ? maxRetryInterval : _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    return _this;\n  }\n\n  SystemErrorRetryPolicy.prototype.sendRequest = function (request) {\n    var _this = this;\n\n    return this._nextPolicy.sendRequest(request.clone()).catch(function (error) {\n      return retry(_this, request, error.response, error);\n    });\n  };\n\n  return SystemErrorRetryPolicy;\n}(BaseRequestPolicy);\n\nexport { SystemErrorRetryPolicy };\n/**\r\n * Determines if the operation should be retried and how long to wait until the next retry.\r\n *\r\n * @param {number} statusCode The HTTP status code.\r\n * @param {RetryData} retryData  The retry data.\r\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\r\n */\n\nfunction shouldRetry(policy, retryData) {\n  var currentCount;\n\n  if (!retryData) {\n    throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\n  } else {\n    currentCount = retryData && retryData.retryCount;\n  }\n\n  return currentCount < policy.retryCount;\n}\n/**\r\n * Updates the retry data for the next attempt.\r\n *\r\n * @param {RetryData} retryData  The retry data.\r\n * @param {object} err        The operation\"s error, if any.\r\n */\n\n\nfunction updateRetryData(policy, retryData, err) {\n  if (!retryData) {\n    retryData = {\n      retryCount: 0,\n      retryInterval: 0\n    };\n  }\n\n  if (err) {\n    if (retryData.error) {\n      err.innerError = retryData.error;\n    }\n\n    retryData.error = err;\n  } // Adjust retry count\n\n\n  retryData.retryCount++; // Adjust retry interval\n\n  var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n  var boundedRandDelta = policy.retryInterval * 0.8 + Math.floor(Math.random() * (policy.retryInterval * 0.4));\n  incrementDelta *= boundedRandDelta;\n  retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\n  return retryData;\n}\n\nfunction retry(policy, request, operationResponse, err, retryData) {\n  return __awaiter(this, void 0, void 0, function () {\n    var error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          retryData = updateRetryData(policy, retryData, err);\n          if (!(err && err.code && shouldRetry(policy, retryData) && (err.code === \"ETIMEDOUT\" || err.code === \"ESOCKETTIMEDOUT\" || err.code === \"ECONNREFUSED\" || err.code === \"ECONNRESET\" || err.code === \"ENOENT\"))) return [3\n          /*break*/\n          , 5];\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n\n          return [4\n          /*yield*/\n          , utils.delay(retryData.retryInterval)];\n\n        case 2:\n          _a.sent();\n\n          return [2\n          /*return*/\n          , policy._nextPolicy.sendRequest(request.clone())];\n\n        case 3:\n          error_1 = _a.sent();\n          return [2\n          /*return*/\n          , retry(policy, request, operationResponse, error_1, retryData)];\n\n        case 4:\n          return [3\n          /*break*/\n          , 6];\n\n        case 5:\n          if (err) {\n            // If the operation failed in the end, return all errors instead of just the last one\n            return [2\n            /*return*/\n            , Promise.reject(retryData.error)];\n          }\n\n          return [2\n          /*return*/\n          , operationResponse];\n\n        case 6:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../lib/policies/systemErrorRetryPolicy.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\nimport { __awaiter, __extends, __generator } from \"tslib\";\r\nimport * as utils from \"../util/utils\";\r\nimport { BaseRequestPolicy, } from \"./requestPolicy\";\r\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\r\n    return {\r\n        create: function (nextPolicy, options) {\r\n            return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\r\n        },\r\n    };\r\n}\r\n/**\r\n * @class\r\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\r\n *\r\n * @constructor\r\n * @param {number} retryCount        The client retry count.\r\n * @param {number} retryInterval     The client retry interval, in milliseconds.\r\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\r\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\r\n */\r\nvar SystemErrorRetryPolicy = /** @class */ (function (_super) {\r\n    __extends(SystemErrorRetryPolicy, _super);\r\n    function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\r\n        var _this = _super.call(this, nextPolicy, options) || this;\r\n        _this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\r\n        _this.DEFAULT_CLIENT_RETRY_COUNT = 3;\r\n        _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\r\n        _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\r\n        _this.retryCount = typeof retryCount === \"number\" ? retryCount : _this.DEFAULT_CLIENT_RETRY_COUNT;\r\n        _this.retryInterval =\r\n            typeof retryInterval === \"number\" ? retryInterval : _this.DEFAULT_CLIENT_RETRY_INTERVAL;\r\n        _this.minRetryInterval =\r\n            typeof minRetryInterval === \"number\"\r\n                ? minRetryInterval\r\n                : _this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\r\n        _this.maxRetryInterval =\r\n            typeof maxRetryInterval === \"number\"\r\n                ? maxRetryInterval\r\n                : _this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\r\n        return _this;\r\n    }\r\n    SystemErrorRetryPolicy.prototype.sendRequest = function (request) {\r\n        var _this = this;\r\n        return this._nextPolicy\r\n            .sendRequest(request.clone())\r\n            .catch(function (error) { return retry(_this, request, error.response, error); });\r\n    };\r\n    return SystemErrorRetryPolicy;\r\n}(BaseRequestPolicy));\r\nexport { SystemErrorRetryPolicy };\r\n/**\r\n * Determines if the operation should be retried and how long to wait until the next retry.\r\n *\r\n * @param {number} statusCode The HTTP status code.\r\n * @param {RetryData} retryData  The retry data.\r\n * @return {boolean} True if the operation qualifies for a retry; false otherwise.\r\n */\r\nfunction shouldRetry(policy, retryData) {\r\n    var currentCount;\r\n    if (!retryData) {\r\n        throw new Error(\"retryData for the SystemErrorRetryPolicyFilter cannot be null.\");\r\n    }\r\n    else {\r\n        currentCount = retryData && retryData.retryCount;\r\n    }\r\n    return currentCount < policy.retryCount;\r\n}\r\n/**\r\n * Updates the retry data for the next attempt.\r\n *\r\n * @param {RetryData} retryData  The retry data.\r\n * @param {object} err        The operation\"s error, if any.\r\n */\r\nfunction updateRetryData(policy, retryData, err) {\r\n    if (!retryData) {\r\n        retryData = {\r\n            retryCount: 0,\r\n            retryInterval: 0,\r\n        };\r\n    }\r\n    if (err) {\r\n        if (retryData.error) {\r\n            err.innerError = retryData.error;\r\n        }\r\n        retryData.error = err;\r\n    }\r\n    // Adjust retry count\r\n    retryData.retryCount++;\r\n    // Adjust retry interval\r\n    var incrementDelta = Math.pow(2, retryData.retryCount) - 1;\r\n    var boundedRandDelta = policy.retryInterval * 0.8 + Math.floor(Math.random() * (policy.retryInterval * 0.4));\r\n    incrementDelta *= boundedRandDelta;\r\n    retryData.retryInterval = Math.min(policy.minRetryInterval + incrementDelta, policy.maxRetryInterval);\r\n    return retryData;\r\n}\r\nfunction retry(policy, request, operationResponse, err, retryData) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var error_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    retryData = updateRetryData(policy, retryData, err);\r\n                    if (!(err &&\r\n                        err.code &&\r\n                        shouldRetry(policy, retryData) &&\r\n                        (err.code === \"ETIMEDOUT\" ||\r\n                            err.code === \"ESOCKETTIMEDOUT\" ||\r\n                            err.code === \"ECONNREFUSED\" ||\r\n                            err.code === \"ECONNRESET\" ||\r\n                            err.code === \"ENOENT\"))) return [3 /*break*/, 5];\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 4]);\r\n                    return [4 /*yield*/, utils.delay(retryData.retryInterval)];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [2 /*return*/, policy._nextPolicy.sendRequest(request.clone())];\r\n                case 3:\r\n                    error_1 = _a.sent();\r\n                    return [2 /*return*/, retry(policy, request, operationResponse, error_1, retryData)];\r\n                case 4: return [3 /*break*/, 6];\r\n                case 5:\r\n                    if (err) {\r\n                        // If the operation failed in the end, return all errors instead of just the last one\r\n                        return [2 /*return*/, Promise.reject(retryData.error)];\r\n                    }\r\n                    return [2 /*return*/, operationResponse];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=systemErrorRetryPolicy.js.map"]},"metadata":{},"sourceType":"module"}