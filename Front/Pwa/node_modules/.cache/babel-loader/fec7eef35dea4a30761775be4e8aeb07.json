{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar tds = require('tedious');\n\nvar debug = require('debug')('mssql:tedi');\n\nvar BaseRequest = require('../base/request');\n\nvar RequestError = require('../error/request-error');\n\nvar _require = require('../utils'),\n    IDS = _require.IDS,\n    objectHasProperty = _require.objectHasProperty;\n\nvar _require2 = require('../datatypes'),\n    TYPES = _require2.TYPES,\n    DECLARATIONS = _require2.DECLARATIONS,\n    declare = _require2.declare,\n    cast = _require2.cast;\n\nvar Table = require('../table');\n\nvar _require3 = require('../udt'),\n    UDT = _require3.PARSERS;\n\nvar JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';\nvar N_TYPES = {\n  BitN: 0x68,\n  DateTimeN: 0x6F,\n  DecimalN: 0x6A,\n  FloatN: 0x6D,\n  IntN: 0x26,\n  MoneyN: 0x6E,\n  NumericN: 0x6C\n};\n\nvar getTediousType = function getTediousType(type) {\n  switch (type) {\n    case TYPES.VarChar:\n      return tds.TYPES.VarChar;\n\n    case TYPES.NVarChar:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Text:\n      return tds.TYPES.Text;\n\n    case TYPES.Int:\n      return tds.TYPES.Int;\n\n    case TYPES.BigInt:\n      return tds.TYPES.BigInt;\n\n    case TYPES.TinyInt:\n      return tds.TYPES.TinyInt;\n\n    case TYPES.SmallInt:\n      return tds.TYPES.SmallInt;\n\n    case TYPES.Bit:\n      return tds.TYPES.Bit;\n\n    case TYPES.Float:\n      return tds.TYPES.Float;\n\n    case TYPES.Decimal:\n      return tds.TYPES.Decimal;\n\n    case TYPES.Numeric:\n      return tds.TYPES.Numeric;\n\n    case TYPES.Real:\n      return tds.TYPES.Real;\n\n    case TYPES.Money:\n      return tds.TYPES.Money;\n\n    case TYPES.SmallMoney:\n      return tds.TYPES.SmallMoney;\n\n    case TYPES.Time:\n      return tds.TYPES.Time;\n\n    case TYPES.Date:\n      return tds.TYPES.Date;\n\n    case TYPES.DateTime:\n      return tds.TYPES.DateTime;\n\n    case TYPES.DateTime2:\n      return tds.TYPES.DateTime2;\n\n    case TYPES.DateTimeOffset:\n      return tds.TYPES.DateTimeOffset;\n\n    case TYPES.SmallDateTime:\n      return tds.TYPES.SmallDateTime;\n\n    case TYPES.UniqueIdentifier:\n      return tds.TYPES.UniqueIdentifier;\n\n    case TYPES.Xml:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Char:\n      return tds.TYPES.Char;\n\n    case TYPES.NChar:\n      return tds.TYPES.NChar;\n\n    case TYPES.NText:\n      return tds.TYPES.NVarChar;\n\n    case TYPES.Image:\n      return tds.TYPES.Image;\n\n    case TYPES.Binary:\n      return tds.TYPES.Binary;\n\n    case TYPES.VarBinary:\n      return tds.TYPES.VarBinary;\n\n    case TYPES.UDT:\n    case TYPES.Geography:\n    case TYPES.Geometry:\n      return tds.TYPES.UDT;\n\n    case TYPES.TVP:\n      return tds.TYPES.TVP;\n\n    case TYPES.Variant:\n      return tds.TYPES.Variant;\n\n    default:\n      return type;\n  }\n};\n\nvar getMssqlType = function getMssqlType(type, length) {\n  if (typeof type !== 'object') return undefined;\n\n  switch (type) {\n    case tds.TYPES.Char:\n      return TYPES.Char;\n\n    case tds.TYPES.NChar:\n      return TYPES.NChar;\n\n    case tds.TYPES.VarChar:\n      return TYPES.VarChar;\n\n    case tds.TYPES.NVarChar:\n      return TYPES.NVarChar;\n\n    case tds.TYPES.Text:\n      return TYPES.Text;\n\n    case tds.TYPES.NText:\n      return TYPES.NText;\n\n    case tds.TYPES.Int:\n      return TYPES.Int;\n\n    case tds.TYPES.BigInt:\n      return TYPES.BigInt;\n\n    case tds.TYPES.TinyInt:\n      return TYPES.TinyInt;\n\n    case tds.TYPES.SmallInt:\n      return TYPES.SmallInt;\n\n    case tds.TYPES.Bit:\n      return TYPES.Bit;\n\n    case tds.TYPES.Float:\n      return TYPES.Float;\n\n    case tds.TYPES.Real:\n      return TYPES.Real;\n\n    case tds.TYPES.Money:\n      return TYPES.Money;\n\n    case tds.TYPES.SmallMoney:\n      return TYPES.SmallMoney;\n\n    case tds.TYPES.Numeric:\n      return TYPES.Numeric;\n\n    case tds.TYPES.Decimal:\n      return TYPES.Decimal;\n\n    case tds.TYPES.DateTime:\n      return TYPES.DateTime;\n\n    case tds.TYPES.Time:\n      return TYPES.Time;\n\n    case tds.TYPES.Date:\n      return TYPES.Date;\n\n    case tds.TYPES.DateTime2:\n      return TYPES.DateTime2;\n\n    case tds.TYPES.DateTimeOffset:\n      return TYPES.DateTimeOffset;\n\n    case tds.TYPES.SmallDateTime:\n      return TYPES.SmallDateTime;\n\n    case tds.TYPES.UniqueIdentifier:\n      return TYPES.UniqueIdentifier;\n\n    case tds.TYPES.Image:\n      return TYPES.Image;\n\n    case tds.TYPES.Binary:\n      return TYPES.Binary;\n\n    case tds.TYPES.VarBinary:\n      return TYPES.VarBinary;\n\n    case tds.TYPES.Xml:\n      return TYPES.Xml;\n\n    case tds.TYPES.UDT:\n      return TYPES.UDT;\n\n    case tds.TYPES.TVP:\n      return TYPES.TVP;\n\n    case tds.TYPES.Variant:\n      return TYPES.Variant;\n\n    default:\n      switch (type.id) {\n        case N_TYPES.BitN:\n          return TYPES.Bit;\n\n        case N_TYPES.NumericN:\n          return TYPES.Numeric;\n\n        case N_TYPES.DecimalN:\n          return TYPES.Decimal;\n\n        case N_TYPES.IntN:\n          if (length === 8) return TYPES.BigInt;\n          if (length === 4) return TYPES.Int;\n          if (length === 2) return TYPES.SmallInt;\n          return TYPES.TinyInt;\n\n        case N_TYPES.FloatN:\n          if (length === 8) return TYPES.Float;\n          return TYPES.Real;\n\n        case N_TYPES.MoneyN:\n          if (length === 8) return TYPES.Money;\n          return TYPES.SmallMoney;\n\n        case N_TYPES.DateTimeN:\n          if (length === 8) return TYPES.DateTime;\n          return TYPES.SmallDateTime;\n      }\n\n  }\n};\n\nvar createColumns = function createColumns(metadata, arrayRowMode) {\n  var out = {};\n  if (arrayRowMode) out = [];\n\n  for (var index = 0, length = metadata.length; index < length; index++) {\n    var column = metadata[index];\n    var outColumn = {\n      index: index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    };\n\n    if (column.udtInfo) {\n      outColumn.udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      };\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName];\n      }\n    }\n\n    if (arrayRowMode) {\n      out.push(outColumn);\n    } else {\n      out[column.colName] = outColumn;\n    }\n  }\n\n  return out;\n};\n\nvar valueCorrection = function valueCorrection(value, metadata) {\n  if (metadata.type === tds.TYPES.UDT && value != null) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n};\n\nvar parameterCorrection = function parameterCorrection(value) {\n  if (value instanceof Table) {\n    var tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    };\n\n    var _iterator = _createForOfIteratorHelper(value.columns),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var col = _step.value;\n        tvp.columns.push({\n          name: col.name,\n          type: getTediousType(col.type),\n          length: col.length,\n          scale: col.scale,\n          precision: col.precision\n        });\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return tvp;\n  } else {\n    return value;\n  }\n};\n\nvar Request = /*#__PURE__*/function (_BaseRequest) {\n  _inherits(Request, _BaseRequest);\n\n  var _super = _createSuper(Request);\n\n  function Request() {\n    _classCallCheck(this, Request);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Request, [{\n    key: \"_batch\",\n    value:\n    /*\r\n    Execute specified sql batch.\r\n    */\n    function _batch(batch, callback) {\n      this._isBatch = true;\n\n      this._query(batch, callback);\n    }\n    /*\r\n    Bulk load.\r\n    */\n\n  }, {\n    key: \"_bulk\",\n    value: function _bulk(table, options, callback) {\n      var _this = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_bulk\", this).call(this, table, options, function (err) {\n        if (err) return callback(err);\n\n        try {\n          table._makeBulk();\n        } catch (e) {\n          return callback(new RequestError(e, 'EREQUEST'));\n        }\n\n        if (!table.name) {\n          return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'));\n        }\n\n        if (table.name.charAt(0) === '@') {\n          return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'));\n        }\n\n        var errors = [];\n        var errorHandlers = {};\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this.stream) {\n            _this.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this.parent.acquire(_this, function (err, connection) {\n          var callbackWithRelease = function callbackWithRelease(err) {\n            try {\n              _this.parent.release(connection);\n            } catch (e) {// noop\n            }\n\n            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              args[_key - 1] = arguments[_key];\n            }\n\n            callback.apply(void 0, [err].concat(args));\n          };\n\n          if (err) return callbackWithRelease(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this));\n\n          if (_this.canceled) {\n            debug('request(%d): canceled', IDS.get(_this));\n            return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n          var done = function done(err, rowCount) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this.stream) _this.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this._cancel;\n            var error;\n\n            if (errors.length && !_this.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              hasReturned = true;\n\n              if (_this.stream) {\n                callbackWithRelease(null, rowCount);\n              } else {\n                callbackWithRelease(error, rowCount);\n              }\n            }\n          };\n\n          var bulk = connection.newBulkLoad(table.path, options, done);\n\n          var _iterator2 = _createForOfIteratorHelper(table.columns),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var col = _step2.value;\n              bulk.addColumn(col.name, getTediousType(col.type), {\n                nullable: col.nullable,\n                length: col.length,\n                scale: col.scale,\n                precision: col.precision\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var _iterator3 = _createForOfIteratorHelper(table.rows),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var row = _step3.value;\n\n              try {\n                bulk.addRow(row);\n              } catch (e) {\n                return handleError(true, connection, e);\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          if (table.create) {\n            var objectid = table.temporary ? \"tempdb..[\".concat(table.name, \"]\") : table.path;\n            var req = new tds.Request(\"if object_id('\".concat(objectid.replace(/'/g, '\\'\\''), \"') is null \").concat(table.declare()), function (err) {\n              if (err) return done(err);\n              connection.execBulkLoad(bulk);\n            });\n\n            _this._setCurrentRequest(req);\n\n            connection.execSqlBatch(req);\n          } else {\n            connection.execBulkLoad(bulk);\n          }\n        });\n      });\n    }\n    /*\r\n    Execute specified sql command.\r\n    */\n\n  }, {\n    key: \"_query\",\n    value: function _query(command, callback) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_query\", this).call(this, command, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var batchLastRow = null;\n        var batchHasOutput = false;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this2.stream) {\n            _this2.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this2.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this2.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this2.parent.acquire(_this2, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this2));\n          var row;\n\n          if (_this2.canceled) {\n            debug('request(%d): canceled', IDS.get(_this2));\n\n            _this2.parent.release(connection);\n\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this2._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this2));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n          debug('request(%d): query', IDS.get(_this2), command);\n          var req = new tds.Request(command, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this2.stream) _this2.emit('error', err);\n              errors.push(err);\n            } // process batch outputs\n\n\n            if (batchHasOutput) {\n              if (!_this2.stream) batchLastRow = recordsets.pop()[0];\n\n              for (var name in batchLastRow) {\n                var value = batchLastRow[name];\n\n                if (name !== '___return___') {\n                  output[name] = value;\n                }\n              }\n            }\n\n            delete _this2._cancel;\n            var error;\n\n            if (errors.length && !_this2.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this2.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this2), error);\n              } else {\n                debug('request(%d): completed', IDS.get(_this2));\n              }\n\n              if (_this2.stream) {\n                callback(null, null, output, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n\n          _this2._setCurrentRequest(req);\n\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this2.arrayRowMode);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // don't stream recordset with output values in batches\n                if (!columns.___return___) {\n                  _this2.emit('recordset', columns);\n                }\n              } else {\n                _this2.emit('recordset', columns);\n              }\n            }\n\n            if (_this2.arrayRowMode) recordsetcolumns.push(columns);\n          });\n\n          var doneHandler = function doneHandler(rowCount, more) {\n            if (rowCount != null) {\n              rowsAffected.push(rowCount);\n\n              if (_this2.stream) {\n                _this2.emit('rowsaffected', rowCount);\n              }\n            } // this function is called even when select only set variables so we should skip adding a new recordset\n\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              var concatenatedChunks = chunksBuffer.join('');\n\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (concatenatedChunks === '') {\n                    row = null;\n                  } else {\n                    row = JSON.parse(concatenatedChunks);\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this2.stream) _this2.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = concatenatedChunks;\n              }\n\n              chunksBuffer = null;\n\n              if (_this2.stream) {\n                _this2.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this2.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          };\n\n          req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches\n\n          req.on('done', doneHandler); // done handlers are used in batches\n\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            if (_this2.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n\n            var _iterator4 = _createForOfIteratorHelper(columns),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var col = _step4.value;\n                col.value = valueCorrection(col.value, col.metadata);\n\n                if (_this2.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n\n                  if (exi != null) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            if (_this2.stream) {\n              if (_this2._isBatch) {\n                // dont stream recordset with output values in batches\n                if (row.___return___) {\n                  batchLastRow = row;\n                } else {\n                  _this2.emit('row', row);\n                }\n              } else {\n                _this2.emit('row', row);\n              }\n            } else {\n              recordset.push(row);\n            }\n          });\n\n          if (_this2._isBatch) {\n            if (Object.keys(_this2.parameters).length) {\n              for (var name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, name)) {\n                  continue;\n                }\n\n                var param = _this2.parameters[name];\n\n                try {\n                  param.value = getTediousType(param.type).validate(param.value);\n                } catch (e) {\n                  e.message = \"Validation failed for parameter '\".concat(name, \"'. \").concat(e.message);\n\n                  var _err = new RequestError(e, 'EPARAM');\n\n                  _this2.parent.release(connection);\n\n                  return callback(_err);\n                }\n              }\n\n              var declarations = [];\n\n              for (var _name in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name)) {\n                  continue;\n                }\n\n                var _param = _this2.parameters[_name];\n                declarations.push(\"@\".concat(_name, \" \").concat(declare(_param.type, _param)));\n              }\n\n              var assigns = [];\n\n              for (var _name2 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name2)) {\n                  continue;\n                }\n\n                var _param2 = _this2.parameters[_name2];\n                assigns.push(\"@\".concat(_name2, \" = \").concat(cast(_param2.value, _param2.type, _param2)));\n              }\n\n              var selects = [];\n\n              for (var _name3 in _this2.parameters) {\n                if (!objectHasProperty(_this2.parameters, _name3)) {\n                  continue;\n                }\n\n                var _param3 = _this2.parameters[_name3];\n\n                if (_param3.io === 2) {\n                  selects.push(\"@\".concat(_name3, \" as [\").concat(_name3, \"]\"));\n                }\n              }\n\n              batchHasOutput = selects.length > 0;\n              req.sqlTextOrProcedure = \"declare \".concat(declarations.join(', '), \";select \").concat(assigns.join(', '), \";\").concat(req.sqlTextOrProcedure, \";\").concat(batchHasOutput ? \"select 1 as [___return___], \".concat(selects.join(', ')) : '');\n            }\n          } else {\n            for (var _name4 in _this2.parameters) {\n              if (!objectHasProperty(_this2.parameters, _name4)) {\n                continue;\n              }\n\n              var _param4 = _this2.parameters[_name4];\n\n              if (_param4.io === 1) {\n                req.addParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              } else {\n                req.addOutputParameter(_param4.name, getTediousType(_param4.type), parameterCorrection(_param4.value), {\n                  length: _param4.length,\n                  scale: _param4.scale,\n                  precision: _param4.precision\n                });\n              }\n            }\n          }\n\n          try {\n            connection[_this2._isBatch ? 'execSqlBatch' : 'execSql'](req);\n          } catch (error) {\n            handleError(true, connection, error);\n          }\n        });\n      });\n    }\n    /*\r\n    Execute stored procedure with specified parameters.\r\n    */\n\n  }, {\n    key: \"_execute\",\n    value: function _execute(procedure, callback) {\n      var _this3 = this;\n\n      _get(_getPrototypeOf(Request.prototype), \"_execute\", this).call(this, procedure, function (err) {\n        if (err) return callback(err);\n        var recordsets = [];\n        var recordsetcolumns = [];\n        var errors = [];\n        var errorHandlers = {};\n        var output = {};\n        var rowsAffected = [];\n        var columns = {};\n        var recordset = [];\n        var returnValue = 0;\n        var isChunkedRecordset = false;\n        var chunksBuffer = null;\n        var hasReturned = false;\n\n        var handleError = function handleError(doReturn, connection, info) {\n          var err = new Error(info.message);\n          err.info = info;\n          err = new RequestError(err, 'EREQUEST');\n\n          if (_this3.stream) {\n            _this3.emit('error', err);\n          } else {\n            if (doReturn && !hasReturned) {\n              if (connection) {\n                for (var event in errorHandlers) {\n                  connection.removeListener(event, errorHandlers[event]);\n                }\n\n                _this3.parent.release(connection);\n              }\n\n              hasReturned = true;\n              callback(err);\n            }\n          } // we must collect errors even in stream mode\n\n\n          errors.push(err);\n        };\n\n        var handleInfo = function handleInfo(msg) {\n          _this3.emit('info', {\n            message: msg.message,\n            number: msg.number,\n            state: msg.state,\n            class: msg.class,\n            lineNumber: msg.lineNumber,\n            serverName: msg.serverName,\n            procName: msg.procName\n          });\n        };\n\n        _this3.parent.acquire(_this3, function (err, connection, config) {\n          if (err) return callback(err);\n          debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(_this3));\n          var row;\n\n          if (_this3.canceled) {\n            debug('request(%d): canceled', IDS.get(_this3));\n\n            _this3.parent.release(connection);\n\n            return callback(new RequestError('Canceled.', 'ECANCEL'));\n          }\n\n          _this3._cancel = function () {\n            debug('request(%d): cancel', IDS.get(_this3));\n            connection.cancel();\n          }; // attach handler to handle multiple error messages\n\n\n          connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);\n          connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));\n          connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));\n\n          if (debug.enabled) {\n            // log stored procedure executions and provided parameters\n            var params = Object.keys(_this3.parameters).map(function (k) {\n              return _this3.parameters[k];\n            }); // cut long string parameters short to keep log somewhat clean\n\n            var logValue = function logValue(s) {\n              return typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;\n            }; // format parameter names as 'my_parameter [sql.Int]'\n\n\n            var logName = function logName(param) {\n              return param.name + ' [sql.' + param.type.name + ']';\n            };\n\n            var logParams = {};\n            params.forEach(function (p) {\n              logParams[logName(p)] = logValue(p.value);\n            });\n            debug('request(%d): execute %s %O', IDS.get(_this3), procedure, logParams);\n          }\n\n          var req = new tds.Request(procedure, function (err) {\n            // to make sure we handle no-sql errors as well\n            if (err && (!errors.length || errors.length && err.message !== errors[errors.length - 1].message)) {\n              err = new RequestError(err, 'EREQUEST');\n              if (_this3.stream) _this3.emit('error', err);\n              errors.push(err);\n            }\n\n            delete _this3._cancel;\n            var error;\n\n            if (errors.length && !_this3.stream) {\n              error = errors.pop();\n              error.precedingErrors = errors;\n            }\n\n            if (!hasReturned) {\n              for (var event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event]);\n              }\n\n              _this3.parent.release(connection);\n\n              hasReturned = true;\n\n              if (error) {\n                debug('request(%d): failed', IDS.get(_this3), error);\n              } else {\n                debug('request(%d): complete', IDS.get(_this3));\n              }\n\n              if (_this3.stream) {\n                callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);\n              } else {\n                callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);\n              }\n            }\n          });\n\n          _this3._setCurrentRequest(req);\n\n          req.on('columnMetadata', function (metadata) {\n            columns = createColumns(metadata, _this3.arrayRowMode);\n            isChunkedRecordset = false;\n\n            if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n              isChunkedRecordset = true;\n              chunksBuffer = [];\n            }\n\n            if (_this3.stream) _this3.emit('recordset', columns);\n            if (_this3.arrayRowMode) recordsetcolumns.push(columns);\n          });\n          req.on('row', function (columns) {\n            if (!recordset) recordset = [];\n\n            if (isChunkedRecordset) {\n              return chunksBuffer.push(columns[0].value);\n            }\n\n            if (_this3.arrayRowMode) {\n              row = [];\n            } else {\n              row = {};\n            }\n\n            var _iterator5 = _createForOfIteratorHelper(columns),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var col = _step5.value;\n                col.value = valueCorrection(col.value, col.metadata);\n\n                if (_this3.arrayRowMode) {\n                  row.push(col.value);\n                } else {\n                  var exi = row[col.metadata.colName];\n\n                  if (exi != null) {\n                    if (exi instanceof Array) {\n                      exi.push(col.value);\n                    } else {\n                      row[col.metadata.colName] = [exi, col.value];\n                    }\n                  } else {\n                    row[col.metadata.colName] = col.value;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            if (_this3.stream) {\n              _this3.emit('row', row);\n            } else {\n              recordset.push(row);\n            }\n          });\n          req.on('doneInProc', function (rowCount, more) {\n            if (rowCount != null) {\n              rowsAffected.push(rowCount);\n\n              if (_this3.stream) {\n                _this3.emit('rowsaffected', rowCount);\n              }\n            } // filter empty recordsets when NOCOUNT is OFF\n\n\n            if (Object.keys(columns).length === 0) return;\n\n            if (isChunkedRecordset) {\n              if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\n                try {\n                  if (chunksBuffer.length === 0) {\n                    row = null;\n                  } else {\n                    row = JSON.parse(chunksBuffer.join(''));\n                  }\n                } catch (ex) {\n                  row = null;\n                  var ex2 = new RequestError(new Error(\"Failed to parse incoming JSON. \".concat(ex.message)), 'EJSON');\n                  if (_this3.stream) _this3.emit('error', ex2); // we must collect errors even in stream mode\n\n                  errors.push(ex2);\n                }\n              } else {\n                row = {};\n                row[Object.keys(columns)[0]] = chunksBuffer.join('');\n              }\n\n              chunksBuffer = null;\n\n              if (_this3.stream) {\n                _this3.emit('row', row);\n              } else {\n                recordset.push(row);\n              }\n            }\n\n            if (!_this3.stream) {\n              // all rows of current recordset loaded\n              Object.defineProperty(recordset, 'columns', {\n                enumerable: false,\n                configurable: true,\n                value: columns\n              });\n              Object.defineProperty(recordset, 'toTable', {\n                enumerable: false,\n                configurable: true,\n                value: function value(name) {\n                  return Table.fromRecordset(this, name);\n                }\n              });\n              recordsets.push(recordset);\n            }\n\n            recordset = [];\n            columns = {};\n          });\n          req.on('doneProc', function (rowCount, more, returnStatus) {\n            returnValue = returnStatus;\n          });\n          req.on('returnValue', function (parameterName, value, metadata) {\n            output[parameterName] = value;\n          });\n\n          for (var name in _this3.parameters) {\n            if (!objectHasProperty(_this3.parameters, name)) {\n              continue;\n            }\n\n            var param = _this3.parameters[name];\n\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {\n                length: param.length,\n                scale: param.scale,\n                precision: param.precision\n              });\n            }\n          }\n\n          connection.callProcedure(req);\n        });\n      });\n    }\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      _get(_getPrototypeOf(Request.prototype), \"_pause\", this).call(this);\n\n      if (this._currentRequest) {\n        this._currentRequest.pause();\n      }\n    }\n  }, {\n    key: \"_resume\",\n    value: function _resume() {\n      _get(_getPrototypeOf(Request.prototype), \"_resume\", this).call(this);\n\n      if (this._currentRequest) {\n        this._currentRequest.resume();\n      }\n    }\n  }]);\n\n  return Request;\n}(BaseRequest);\n\nmodule.exports = Request;","map":{"version":3,"sources":["C:/Users/jesus/Documents/GitHub/Turismo-Real/Front/Pwa/node_modules/mssql/lib/tedious/request.js"],"names":["tds","require","debug","BaseRequest","RequestError","IDS","objectHasProperty","TYPES","DECLARATIONS","declare","cast","Table","UDT","PARSERS","JSON_COLUMN_ID","XML_COLUMN_ID","N_TYPES","BitN","DateTimeN","DecimalN","FloatN","IntN","MoneyN","NumericN","getTediousType","type","VarChar","NVarChar","Text","Int","BigInt","TinyInt","SmallInt","Bit","Float","Decimal","Numeric","Real","Money","SmallMoney","Time","Date","DateTime","DateTime2","DateTimeOffset","SmallDateTime","UniqueIdentifier","Xml","Char","NChar","NText","Image","Binary","VarBinary","Geography","Geometry","TVP","Variant","getMssqlType","length","undefined","id","createColumns","metadata","arrayRowMode","out","index","column","outColumn","name","colName","dataLength","scale","precision","nullable","flags","caseSensitive","identity","readOnly","udtInfo","udt","typeName","database","dbname","schema","owningSchema","assembly","assemblyName","push","valueCorrection","value","parameterCorrection","tvp","columns","rows","col","Request","batch","callback","_isBatch","_query","table","options","err","_makeBulk","e","charAt","errors","errorHandlers","hasReturned","handleError","doReturn","connection","info","Error","message","stream","emit","event","removeListener","parent","release","handleInfo","msg","number","state","class","lineNumber","serverName","procName","acquire","callbackWithRelease","args","get","canceled","_cancel","cancel","on","infoMessage","errorMessage","bind","error","done","rowCount","pop","precedingErrors","bulk","newBulkLoad","path","addColumn","row","addRow","create","objectid","temporary","req","replace","execBulkLoad","_setCurrentRequest","execSqlBatch","command","recordsets","recordsetcolumns","output","rowsAffected","recordset","batchLastRow","batchHasOutput","isChunkedRecordset","chunksBuffer","config","___return___","doneHandler","more","Object","keys","concatenatedChunks","join","parseJSON","JSON","parse","ex","ex2","defineProperty","enumerable","configurable","fromRecordset","parameterName","exi","Array","parameters","param","validate","declarations","assigns","selects","io","sqlTextOrProcedure","addParameter","addOutputParameter","procedure","returnValue","enabled","params","map","k","logValue","s","substring","logName","logParams","forEach","p","returnStatus","callProcedure","_currentRequest","pause","resume","module","exports"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,IAAMA,GAAG,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAAP,CAAiB,YAAjB,CAAd;;AACA,IAAME,WAAW,GAAGF,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAMG,YAAY,GAAGH,OAAO,CAAC,wBAAD,CAA5B;;eACmCA,OAAO,CAAC,UAAD,C;IAAlCI,G,YAAAA,G;IAAKC,iB,YAAAA,iB;;gBACkCL,OAAO,CAAC,cAAD,C;IAA9CM,K,aAAAA,K;IAAOC,Y,aAAAA,Y;IAAcC,O,aAAAA,O;IAASC,I,aAAAA,I;;AACtC,IAAMC,KAAK,GAAGV,OAAO,CAAC,UAAD,CAArB;;gBACyBA,OAAO,CAAC,QAAD,C;IAAfW,G,aAATC,O;;AAER,IAAMC,cAAc,GAAG,2CAAvB;AACA,IAAMC,aAAa,GAAG,0CAAtB;AAEA,IAAMC,OAAO,GAAG;AACdC,EAAAA,IAAI,EAAE,IADQ;AAEdC,EAAAA,SAAS,EAAE,IAFG;AAGdC,EAAAA,QAAQ,EAAE,IAHI;AAIdC,EAAAA,MAAM,EAAE,IAJM;AAKdC,EAAAA,IAAI,EAAE,IALQ;AAMdC,EAAAA,MAAM,EAAE,IANM;AAOdC,EAAAA,QAAQ,EAAE;AAPI,CAAhB;;AAUA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAAUC,IAAV,EAAgB;AACrC,UAAQA,IAAR;AACE,SAAKlB,KAAK,CAACmB,OAAX;AAAoB,aAAO1B,GAAG,CAACO,KAAJ,CAAUmB,OAAjB;;AACpB,SAAKnB,KAAK,CAACoB,QAAX;AAAqB,aAAO3B,GAAG,CAACO,KAAJ,CAAUoB,QAAjB;;AACrB,SAAKpB,KAAK,CAACqB,IAAX;AAAiB,aAAO5B,GAAG,CAACO,KAAJ,CAAUqB,IAAjB;;AACjB,SAAKrB,KAAK,CAACsB,GAAX;AAAgB,aAAO7B,GAAG,CAACO,KAAJ,CAAUsB,GAAjB;;AAChB,SAAKtB,KAAK,CAACuB,MAAX;AAAmB,aAAO9B,GAAG,CAACO,KAAJ,CAAUuB,MAAjB;;AACnB,SAAKvB,KAAK,CAACwB,OAAX;AAAoB,aAAO/B,GAAG,CAACO,KAAJ,CAAUwB,OAAjB;;AACpB,SAAKxB,KAAK,CAACyB,QAAX;AAAqB,aAAOhC,GAAG,CAACO,KAAJ,CAAUyB,QAAjB;;AACrB,SAAKzB,KAAK,CAAC0B,GAAX;AAAgB,aAAOjC,GAAG,CAACO,KAAJ,CAAU0B,GAAjB;;AAChB,SAAK1B,KAAK,CAAC2B,KAAX;AAAkB,aAAOlC,GAAG,CAACO,KAAJ,CAAU2B,KAAjB;;AAClB,SAAK3B,KAAK,CAAC4B,OAAX;AAAoB,aAAOnC,GAAG,CAACO,KAAJ,CAAU4B,OAAjB;;AACpB,SAAK5B,KAAK,CAAC6B,OAAX;AAAoB,aAAOpC,GAAG,CAACO,KAAJ,CAAU6B,OAAjB;;AACpB,SAAK7B,KAAK,CAAC8B,IAAX;AAAiB,aAAOrC,GAAG,CAACO,KAAJ,CAAU8B,IAAjB;;AACjB,SAAK9B,KAAK,CAAC+B,KAAX;AAAkB,aAAOtC,GAAG,CAACO,KAAJ,CAAU+B,KAAjB;;AAClB,SAAK/B,KAAK,CAACgC,UAAX;AAAuB,aAAOvC,GAAG,CAACO,KAAJ,CAAUgC,UAAjB;;AACvB,SAAKhC,KAAK,CAACiC,IAAX;AAAiB,aAAOxC,GAAG,CAACO,KAAJ,CAAUiC,IAAjB;;AACjB,SAAKjC,KAAK,CAACkC,IAAX;AAAiB,aAAOzC,GAAG,CAACO,KAAJ,CAAUkC,IAAjB;;AACjB,SAAKlC,KAAK,CAACmC,QAAX;AAAqB,aAAO1C,GAAG,CAACO,KAAJ,CAAUmC,QAAjB;;AACrB,SAAKnC,KAAK,CAACoC,SAAX;AAAsB,aAAO3C,GAAG,CAACO,KAAJ,CAAUoC,SAAjB;;AACtB,SAAKpC,KAAK,CAACqC,cAAX;AAA2B,aAAO5C,GAAG,CAACO,KAAJ,CAAUqC,cAAjB;;AAC3B,SAAKrC,KAAK,CAACsC,aAAX;AAA0B,aAAO7C,GAAG,CAACO,KAAJ,CAAUsC,aAAjB;;AAC1B,SAAKtC,KAAK,CAACuC,gBAAX;AAA6B,aAAO9C,GAAG,CAACO,KAAJ,CAAUuC,gBAAjB;;AAC7B,SAAKvC,KAAK,CAACwC,GAAX;AAAgB,aAAO/C,GAAG,CAACO,KAAJ,CAAUoB,QAAjB;;AAChB,SAAKpB,KAAK,CAACyC,IAAX;AAAiB,aAAOhD,GAAG,CAACO,KAAJ,CAAUyC,IAAjB;;AACjB,SAAKzC,KAAK,CAAC0C,KAAX;AAAkB,aAAOjD,GAAG,CAACO,KAAJ,CAAU0C,KAAjB;;AAClB,SAAK1C,KAAK,CAAC2C,KAAX;AAAkB,aAAOlD,GAAG,CAACO,KAAJ,CAAUoB,QAAjB;;AAClB,SAAKpB,KAAK,CAAC4C,KAAX;AAAkB,aAAOnD,GAAG,CAACO,KAAJ,CAAU4C,KAAjB;;AAClB,SAAK5C,KAAK,CAAC6C,MAAX;AAAmB,aAAOpD,GAAG,CAACO,KAAJ,CAAU6C,MAAjB;;AACnB,SAAK7C,KAAK,CAAC8C,SAAX;AAAsB,aAAOrD,GAAG,CAACO,KAAJ,CAAU8C,SAAjB;;AACtB,SAAK9C,KAAK,CAACK,GAAX;AAAgB,SAAKL,KAAK,CAAC+C,SAAX;AAAsB,SAAK/C,KAAK,CAACgD,QAAX;AAAqB,aAAOvD,GAAG,CAACO,KAAJ,CAAUK,GAAjB;;AAC3D,SAAKL,KAAK,CAACiD,GAAX;AAAgB,aAAOxD,GAAG,CAACO,KAAJ,CAAUiD,GAAjB;;AAChB,SAAKjD,KAAK,CAACkD,OAAX;AAAoB,aAAOzD,GAAG,CAACO,KAAJ,CAAUkD,OAAjB;;AACpB;AAAS,aAAOhC,IAAP;AAhCX;AAkCD,CAnCD;;AAqCA,IAAMiC,YAAY,GAAG,SAAfA,YAAe,CAAUjC,IAAV,EAAgBkC,MAAhB,EAAwB;AAC3C,MAAI,OAAOlC,IAAP,KAAgB,QAApB,EAA8B,OAAOmC,SAAP;;AAE9B,UAAQnC,IAAR;AACE,SAAKzB,GAAG,CAACO,KAAJ,CAAUyC,IAAf;AAAqB,aAAOzC,KAAK,CAACyC,IAAb;;AACrB,SAAKhD,GAAG,CAACO,KAAJ,CAAU0C,KAAf;AAAsB,aAAO1C,KAAK,CAAC0C,KAAb;;AACtB,SAAKjD,GAAG,CAACO,KAAJ,CAAUmB,OAAf;AAAwB,aAAOnB,KAAK,CAACmB,OAAb;;AACxB,SAAK1B,GAAG,CAACO,KAAJ,CAAUoB,QAAf;AAAyB,aAAOpB,KAAK,CAACoB,QAAb;;AACzB,SAAK3B,GAAG,CAACO,KAAJ,CAAUqB,IAAf;AAAqB,aAAOrB,KAAK,CAACqB,IAAb;;AACrB,SAAK5B,GAAG,CAACO,KAAJ,CAAU2C,KAAf;AAAsB,aAAO3C,KAAK,CAAC2C,KAAb;;AACtB,SAAKlD,GAAG,CAACO,KAAJ,CAAUsB,GAAf;AAAoB,aAAOtB,KAAK,CAACsB,GAAb;;AACpB,SAAK7B,GAAG,CAACO,KAAJ,CAAUuB,MAAf;AAAuB,aAAOvB,KAAK,CAACuB,MAAb;;AACvB,SAAK9B,GAAG,CAACO,KAAJ,CAAUwB,OAAf;AAAwB,aAAOxB,KAAK,CAACwB,OAAb;;AACxB,SAAK/B,GAAG,CAACO,KAAJ,CAAUyB,QAAf;AAAyB,aAAOzB,KAAK,CAACyB,QAAb;;AACzB,SAAKhC,GAAG,CAACO,KAAJ,CAAU0B,GAAf;AAAoB,aAAO1B,KAAK,CAAC0B,GAAb;;AACpB,SAAKjC,GAAG,CAACO,KAAJ,CAAU2B,KAAf;AAAsB,aAAO3B,KAAK,CAAC2B,KAAb;;AACtB,SAAKlC,GAAG,CAACO,KAAJ,CAAU8B,IAAf;AAAqB,aAAO9B,KAAK,CAAC8B,IAAb;;AACrB,SAAKrC,GAAG,CAACO,KAAJ,CAAU+B,KAAf;AAAsB,aAAO/B,KAAK,CAAC+B,KAAb;;AACtB,SAAKtC,GAAG,CAACO,KAAJ,CAAUgC,UAAf;AAA2B,aAAOhC,KAAK,CAACgC,UAAb;;AAC3B,SAAKvC,GAAG,CAACO,KAAJ,CAAU6B,OAAf;AAAwB,aAAO7B,KAAK,CAAC6B,OAAb;;AACxB,SAAKpC,GAAG,CAACO,KAAJ,CAAU4B,OAAf;AAAwB,aAAO5B,KAAK,CAAC4B,OAAb;;AACxB,SAAKnC,GAAG,CAACO,KAAJ,CAAUmC,QAAf;AAAyB,aAAOnC,KAAK,CAACmC,QAAb;;AACzB,SAAK1C,GAAG,CAACO,KAAJ,CAAUiC,IAAf;AAAqB,aAAOjC,KAAK,CAACiC,IAAb;;AACrB,SAAKxC,GAAG,CAACO,KAAJ,CAAUkC,IAAf;AAAqB,aAAOlC,KAAK,CAACkC,IAAb;;AACrB,SAAKzC,GAAG,CAACO,KAAJ,CAAUoC,SAAf;AAA0B,aAAOpC,KAAK,CAACoC,SAAb;;AAC1B,SAAK3C,GAAG,CAACO,KAAJ,CAAUqC,cAAf;AAA+B,aAAOrC,KAAK,CAACqC,cAAb;;AAC/B,SAAK5C,GAAG,CAACO,KAAJ,CAAUsC,aAAf;AAA8B,aAAOtC,KAAK,CAACsC,aAAb;;AAC9B,SAAK7C,GAAG,CAACO,KAAJ,CAAUuC,gBAAf;AAAiC,aAAOvC,KAAK,CAACuC,gBAAb;;AACjC,SAAK9C,GAAG,CAACO,KAAJ,CAAU4C,KAAf;AAAsB,aAAO5C,KAAK,CAAC4C,KAAb;;AACtB,SAAKnD,GAAG,CAACO,KAAJ,CAAU6C,MAAf;AAAuB,aAAO7C,KAAK,CAAC6C,MAAb;;AACvB,SAAKpD,GAAG,CAACO,KAAJ,CAAU8C,SAAf;AAA0B,aAAO9C,KAAK,CAAC8C,SAAb;;AAC1B,SAAKrD,GAAG,CAACO,KAAJ,CAAUwC,GAAf;AAAoB,aAAOxC,KAAK,CAACwC,GAAb;;AACpB,SAAK/C,GAAG,CAACO,KAAJ,CAAUK,GAAf;AAAoB,aAAOL,KAAK,CAACK,GAAb;;AACpB,SAAKZ,GAAG,CAACO,KAAJ,CAAUiD,GAAf;AAAoB,aAAOjD,KAAK,CAACiD,GAAb;;AACpB,SAAKxD,GAAG,CAACO,KAAJ,CAAUkD,OAAf;AAAwB,aAAOlD,KAAK,CAACkD,OAAb;;AACxB;AACE,cAAQhC,IAAI,CAACoC,EAAb;AACE,aAAK7C,OAAO,CAACC,IAAb;AAAmB,iBAAOV,KAAK,CAAC0B,GAAb;;AACnB,aAAKjB,OAAO,CAACO,QAAb;AAAuB,iBAAOhB,KAAK,CAAC6B,OAAb;;AACvB,aAAKpB,OAAO,CAACG,QAAb;AAAuB,iBAAOZ,KAAK,CAAC4B,OAAb;;AACvB,aAAKnB,OAAO,CAACK,IAAb;AACE,cAAIsC,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAACuB,MAAb;AAClB,cAAI6B,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAACsB,GAAb;AAClB,cAAI8B,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAACyB,QAAb;AAClB,iBAAOzB,KAAK,CAACwB,OAAb;;AACF,aAAKf,OAAO,CAACI,MAAb;AACE,cAAIuC,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAAC2B,KAAb;AAClB,iBAAO3B,KAAK,CAAC8B,IAAb;;AACF,aAAKrB,OAAO,CAACM,MAAb;AACE,cAAIqC,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAAC+B,KAAb;AAClB,iBAAO/B,KAAK,CAACgC,UAAb;;AACF,aAAKvB,OAAO,CAACE,SAAb;AACE,cAAIyC,MAAM,KAAK,CAAf,EAAkB,OAAOpD,KAAK,CAACmC,QAAb;AAClB,iBAAOnC,KAAK,CAACsC,aAAb;AAjBJ;;AAjCJ;AAqDD,CAxDD;;AA0DA,IAAMiB,aAAa,GAAG,SAAhBA,aAAgB,CAAUC,QAAV,EAAoBC,YAApB,EAAkC;AACtD,MAAIC,GAAG,GAAG,EAAV;AACA,MAAID,YAAJ,EAAkBC,GAAG,GAAG,EAAN;;AAClB,OAAK,IAAIC,KAAK,GAAG,CAAZ,EAAeP,MAAM,GAAGI,QAAQ,CAACJ,MAAtC,EAA8CO,KAAK,GAAGP,MAAtD,EAA8DO,KAAK,EAAnE,EAAuE;AACrE,QAAMC,MAAM,GAAGJ,QAAQ,CAACG,KAAD,CAAvB;AACA,QAAME,SAAS,GAAG;AAChBF,MAAAA,KAAK,EAALA,KADgB;AAEhBG,MAAAA,IAAI,EAAEF,MAAM,CAACG,OAFG;AAGhBX,MAAAA,MAAM,EAAEQ,MAAM,CAACI,UAHC;AAIhB9C,MAAAA,IAAI,EAAEiC,YAAY,CAACS,MAAM,CAAC1C,IAAR,EAAc0C,MAAM,CAACI,UAArB,CAJF;AAKhBC,MAAAA,KAAK,EAAEL,MAAM,CAACK,KALE;AAMhBC,MAAAA,SAAS,EAAEN,MAAM,CAACM,SANF;AAOhBC,MAAAA,QAAQ,EAAE,CAAC,EAAEP,MAAM,CAACQ,KAAP,GAAe,IAAjB,CAPK;AAQhBC,MAAAA,aAAa,EAAE,CAAC,EAAET,MAAM,CAACQ,KAAP,GAAe,IAAjB,CARA;AAShBE,MAAAA,QAAQ,EAAE,CAAC,EAAEV,MAAM,CAACQ,KAAP,GAAe,IAAjB,CATK;AAUhBG,MAAAA,QAAQ,EAAE,EAAEX,MAAM,CAACQ,KAAP,GAAe,IAAjB;AAVM,KAAlB;;AAaA,QAAIR,MAAM,CAACY,OAAX,EAAoB;AAClBX,MAAAA,SAAS,CAACY,GAAV,GAAgB;AACdX,QAAAA,IAAI,EAAEF,MAAM,CAACY,OAAP,CAAeE,QADP;AAEdC,QAAAA,QAAQ,EAAEf,MAAM,CAACY,OAAP,CAAeI,MAFX;AAGdC,QAAAA,MAAM,EAAEjB,MAAM,CAACY,OAAP,CAAeM,YAHT;AAIdC,QAAAA,QAAQ,EAAEnB,MAAM,CAACY,OAAP,CAAeQ;AAJX,OAAhB;;AAOA,UAAI/E,YAAY,CAAC2D,MAAM,CAACY,OAAP,CAAeE,QAAhB,CAAhB,EAA2C;AACzCb,QAAAA,SAAS,CAAC3C,IAAV,GAAiBjB,YAAY,CAAC2D,MAAM,CAACY,OAAP,CAAeE,QAAhB,CAA7B;AACD;AACF;;AAED,QAAIjB,YAAJ,EAAkB;AAChBC,MAAAA,GAAG,CAACuB,IAAJ,CAASpB,SAAT;AACD,KAFD,MAEO;AACLH,MAAAA,GAAG,CAACE,MAAM,CAACG,OAAR,CAAH,GAAsBF,SAAtB;AACD;AACF;;AAED,SAAOH,GAAP;AACD,CAvCD;;AAyCA,IAAMwB,eAAe,GAAG,SAAlBA,eAAkB,CAAUC,KAAV,EAAiB3B,QAAjB,EAA2B;AACjD,MAAKA,QAAQ,CAACtC,IAAT,KAAkBzB,GAAG,CAACO,KAAJ,CAAUK,GAA7B,IAAsC8E,KAAK,IAAI,IAAnD,EAA0D;AACxD,QAAI9E,GAAG,CAACmD,QAAQ,CAACgB,OAAT,CAAiBE,QAAlB,CAAP,EAAoC;AAClC,aAAOrE,GAAG,CAACmD,QAAQ,CAACgB,OAAT,CAAiBE,QAAlB,CAAH,CAA+BS,KAA/B,CAAP;AACD,KAFD,MAEO;AACL,aAAOA,KAAP;AACD;AACF,GAND,MAMO;AACL,WAAOA,KAAP;AACD;AACF,CAVD;;AAYA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUD,KAAV,EAAiB;AAC3C,MAAIA,KAAK,YAAY/E,KAArB,EAA4B;AAC1B,QAAMiF,GAAG,GAAG;AACVvB,MAAAA,IAAI,EAAEqB,KAAK,CAACrB,IADF;AAEVe,MAAAA,MAAM,EAAEM,KAAK,CAACN,MAFJ;AAGVS,MAAAA,OAAO,EAAE,EAHC;AAIVC,MAAAA,IAAI,EAAEJ,KAAK,CAACI;AAJF,KAAZ;;AAD0B,+CAQRJ,KAAK,CAACG,OARE;AAAA;;AAAA;AAQ1B,0DAAiC;AAAA,YAAtBE,GAAsB;AAC/BH,QAAAA,GAAG,CAACC,OAAJ,CAAYL,IAAZ,CAAiB;AACfnB,UAAAA,IAAI,EAAE0B,GAAG,CAAC1B,IADK;AAEf5C,UAAAA,IAAI,EAAED,cAAc,CAACuE,GAAG,CAACtE,IAAL,CAFL;AAGfkC,UAAAA,MAAM,EAAEoC,GAAG,CAACpC,MAHG;AAIfa,UAAAA,KAAK,EAAEuB,GAAG,CAACvB,KAJI;AAKfC,UAAAA,SAAS,EAAEsB,GAAG,CAACtB;AALA,SAAjB;AAOD;AAhByB;AAAA;AAAA;AAAA;AAAA;;AAkB1B,WAAOmB,GAAP;AACD,GAnBD,MAmBO;AACL,WAAOF,KAAP;AACD;AACF,CAvBD;;IAyBMM,O;;;;;;;;;;;;;;AACJ;AACF;AACA;AAEE,oBAAQC,KAAR,EAAeC,QAAf,EAAyB;AACvB,WAAKC,QAAL,GAAgB,IAAhB;;AACA,WAAKC,MAAL,CAAYH,KAAZ,EAAmBC,QAAnB;AACD;AAED;AACF;AACA;;;;WAEE,eAAOG,KAAP,EAAcC,OAAd,EAAuBJ,QAAvB,EAAiC;AAAA;;AAC/B,yEAAYG,KAAZ,EAAmBC,OAAnB,EAA4B,UAAAC,GAAG,EAAI;AACjC,YAAIA,GAAJ,EAAS,OAAOL,QAAQ,CAACK,GAAD,CAAf;;AAET,YAAI;AACFF,UAAAA,KAAK,CAACG,SAAN;AACD,SAFD,CAEE,OAAOC,CAAP,EAAU;AACV,iBAAOP,QAAQ,CAAC,IAAI9F,YAAJ,CAAiBqG,CAAjB,EAAoB,UAApB,CAAD,CAAf;AACD;;AAED,YAAI,CAACJ,KAAK,CAAChC,IAAX,EAAiB;AACf,iBAAO6B,QAAQ,CAAC,IAAI9F,YAAJ,CAAiB,+CAAjB,EAAkE,OAAlE,CAAD,CAAf;AACD;;AAED,YAAIiG,KAAK,CAAChC,IAAN,CAAWqC,MAAX,CAAkB,CAAlB,MAAyB,GAA7B,EAAkC;AAChC,iBAAOR,QAAQ,CAAC,IAAI9F,YAAJ,CAAiB,gDAAjB,EAAmE,OAAnE,CAAD,CAAf;AACD;;AAED,YAAMuG,MAAM,GAAG,EAAf;AACA,YAAMC,aAAa,GAAG,EAAtB;AACA,YAAIC,WAAW,GAAG,KAAlB;;AAEA,YAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,QAAD,EAAWC,UAAX,EAAuBC,IAAvB,EAAgC;AAClD,cAAIV,GAAG,GAAG,IAAIW,KAAJ,CAAUD,IAAI,CAACE,OAAf,CAAV;AACAZ,UAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,UAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;;AAEA,cAAI,KAAI,CAACa,MAAT,EAAiB;AACf,YAAA,KAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACD,WAFD,MAEO;AACL,gBAAIQ,QAAQ,IAAI,CAACF,WAAjB,EAA8B;AAC5B,kBAAIG,UAAJ,EAAgB;AACd,qBAAK,IAAMM,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,kBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAED,gBAAA,KAAI,CAACE,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;AACD;;AAEDH,cAAAA,WAAW,GAAG,IAAd;AACAX,cAAAA,QAAQ,CAACK,GAAD,CAAR;AACD;AACF,WApBiD,CAsBlD;;;AACAI,UAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD,SAxBD;;AA0BA,YAAMmB,UAAU,GAAG,SAAbA,UAAa,CAAAC,GAAG,EAAI;AACxB,UAAA,KAAI,CAACN,IAAL,CAAU,MAAV,EAAkB;AAChBF,YAAAA,OAAO,EAAEQ,GAAG,CAACR,OADG;AAEhBS,YAAAA,MAAM,EAAED,GAAG,CAACC,MAFI;AAGhBC,YAAAA,KAAK,EAAEF,GAAG,CAACE,KAHK;AAIhBC,YAAAA,KAAK,EAAEH,GAAG,CAACG,KAJK;AAKhBC,YAAAA,UAAU,EAAEJ,GAAG,CAACI,UALA;AAMhBC,YAAAA,UAAU,EAAEL,GAAG,CAACK,UANA;AAOhBC,YAAAA,QAAQ,EAAEN,GAAG,CAACM;AAPE,WAAlB;AASD,SAVD;;AAYA,QAAA,KAAI,CAACT,MAAL,CAAYU,OAAZ,CAAoB,KAApB,EAA0B,UAAC3B,GAAD,EAAMS,UAAN,EAAqB;AAC7C,cAAMmB,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAC5B,GAAD,EAAkB;AAC5C,gBAAI;AACF,cAAA,KAAI,CAACiB,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;AACD,aAFD,CAEE,OAAOP,CAAP,EAAU,CACV;AACD;;AAL2C,8CAAT2B,IAAS;AAATA,cAAAA,IAAS;AAAA;;AAM5ClC,YAAAA,QAAQ,MAAR,UAASK,GAAT,SAAiB6B,IAAjB;AACD,WAPD;;AAQA,cAAI7B,GAAJ,EAAS,OAAO4B,mBAAmB,CAAC5B,GAAD,CAA1B;AAETrG,UAAAA,KAAK,CAAC,yCAAD,EAA4CG,GAAG,CAACgI,GAAJ,CAAQrB,UAAR,CAA5C,EAAiE3G,GAAG,CAACgI,GAAJ,CAAQ,KAAR,CAAjE,CAAL;;AAEA,cAAI,KAAI,CAACC,QAAT,EAAmB;AACjBpI,YAAAA,KAAK,CAAC,uBAAD,EAA0BG,GAAG,CAACgI,GAAJ,CAAQ,KAAR,CAA1B,CAAL;AACA,mBAAOF,mBAAmB,CAAC,IAAI/H,YAAJ,CAAiB,WAAjB,EAA8B,SAA9B,CAAD,CAA1B;AACD;;AAED,UAAA,KAAI,CAACmI,OAAL,GAAe,YAAM;AACnBrI,YAAAA,KAAK,CAAC,qBAAD,EAAwBG,GAAG,CAACgI,GAAJ,CAAQ,KAAR,CAAxB,CAAL;AACArB,YAAAA,UAAU,CAACwB,MAAX;AACD,WAHD,CAlB6C,CAuB7C;;;AACAxB,UAAAA,UAAU,CAACyB,EAAX,CAAc,aAAd,EAA6B7B,aAAa,CAAC8B,WAAd,GAA4BhB,UAAzD;AACAV,UAAAA,UAAU,CAACyB,EAAX,CAAc,cAAd,EAA8B7B,aAAa,CAAC+B,YAAd,GAA6B7B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B5B,UAA9B,CAA3D;AACAA,UAAAA,UAAU,CAACyB,EAAX,CAAc,OAAd,EAAuB7B,aAAa,CAACiC,KAAd,GAAsB/B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B5B,UAA7B,CAA7C;;AAEA,cAAM8B,IAAI,GAAG,SAAPA,IAAO,CAACvC,GAAD,EAAMwC,QAAN,EAAmB;AAC9B;AACA,gBAAIxC,GAAG,KAAK,CAACI,MAAM,CAAChD,MAAR,IAAmBgD,MAAM,CAAChD,MAAP,IAAiB4C,GAAG,CAACY,OAAJ,KAAgBR,MAAM,CAACA,MAAM,CAAChD,MAAP,GAAgB,CAAjB,CAAN,CAA0BwD,OAAnF,CAAP,EAAqG;AACnGZ,cAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;AACA,kBAAI,KAAI,CAACa,MAAT,EAAiB,KAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACjBI,cAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD;;AAED,mBAAO,KAAI,CAACgC,OAAZ;AAEA,gBAAIM,KAAJ;;AACA,gBAAIlC,MAAM,CAAChD,MAAP,IAAiB,CAAC,KAAI,CAACyD,MAA3B,EAAmC;AACjCyB,cAAAA,KAAK,GAAGlC,MAAM,CAACqC,GAAP,EAAR;AACAH,cAAAA,KAAK,CAACI,eAAN,GAAwBtC,MAAxB;AACD;;AAED,gBAAI,CAACE,WAAL,EAAkB;AAChB,mBAAK,IAAMS,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,gBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAEDT,cAAAA,WAAW,GAAG,IAAd;;AAEA,kBAAI,KAAI,CAACO,MAAT,EAAiB;AACfe,gBAAAA,mBAAmB,CAAC,IAAD,EAAOY,QAAP,CAAnB;AACD,eAFD,MAEO;AACLZ,gBAAAA,mBAAmB,CAACU,KAAD,EAAQE,QAAR,CAAnB;AACD;AACF;AACF,WA7BD;;AA+BA,cAAMG,IAAI,GAAGlC,UAAU,CAACmC,WAAX,CAAuB9C,KAAK,CAAC+C,IAA7B,EAAmC9C,OAAnC,EAA4CwC,IAA5C,CAAb;;AA3D6C,sDA6D3BzC,KAAK,CAACR,OA7DqB;AAAA;;AAAA;AA6D7C,mEAAiC;AAAA,kBAAtBE,GAAsB;AAC/BmD,cAAAA,IAAI,CAACG,SAAL,CAAetD,GAAG,CAAC1B,IAAnB,EAAyB7C,cAAc,CAACuE,GAAG,CAACtE,IAAL,CAAvC,EAAmD;AAAEiD,gBAAAA,QAAQ,EAAEqB,GAAG,CAACrB,QAAhB;AAA0Bf,gBAAAA,MAAM,EAAEoC,GAAG,CAACpC,MAAtC;AAA8Ca,gBAAAA,KAAK,EAAEuB,GAAG,CAACvB,KAAzD;AAAgEC,gBAAAA,SAAS,EAAEsB,GAAG,CAACtB;AAA/E,eAAnD;AACD;AA/D4C;AAAA;AAAA;AAAA;AAAA;;AAAA,sDAiE3B4B,KAAK,CAACP,IAjEqB;AAAA;;AAAA;AAiE7C,mEAA8B;AAAA,kBAAnBwD,GAAmB;;AAC5B,kBAAI;AACFJ,gBAAAA,IAAI,CAACK,MAAL,CAAYD,GAAZ;AACD,eAFD,CAEE,OAAO7C,CAAP,EAAU;AACV,uBAAOK,WAAW,CAAC,IAAD,EAAOE,UAAP,EAAmBP,CAAnB,CAAlB;AACD;AACF;AAvE4C;AAAA;AAAA;AAAA;AAAA;;AAyE7C,cAAIJ,KAAK,CAACmD,MAAV,EAAkB;AAChB,gBAAMC,QAAQ,GAAGpD,KAAK,CAACqD,SAAN,sBAA8BrD,KAAK,CAAChC,IAApC,SAA8CgC,KAAK,CAAC+C,IAArE;AACA,gBAAMO,GAAG,GAAG,IAAI3J,GAAG,CAACgG,OAAR,yBAAiCyD,QAAQ,CAACG,OAAT,CAAiB,IAAjB,EAAuB,MAAvB,CAAjC,wBAA6EvD,KAAK,CAAC5F,OAAN,EAA7E,GAAgG,UAAA8F,GAAG,EAAI;AACjH,kBAAIA,GAAJ,EAAS,OAAOuC,IAAI,CAACvC,GAAD,CAAX;AAETS,cAAAA,UAAU,CAAC6C,YAAX,CAAwBX,IAAxB;AACD,aAJW,CAAZ;;AAKA,YAAA,KAAI,CAACY,kBAAL,CAAwBH,GAAxB;;AAEA3C,YAAAA,UAAU,CAAC+C,YAAX,CAAwBJ,GAAxB;AACD,WAVD,MAUO;AACL3C,YAAAA,UAAU,CAAC6C,YAAX,CAAwBX,IAAxB;AACD;AACF,SAtFD;AAuFD,OAlJD;AAmJD;AAED;AACF;AACA;;;;WAEE,gBAAQc,OAAR,EAAiB9D,QAAjB,EAA2B;AAAA;;AACzB,0EAAa8D,OAAb,EAAsB,UAAAzD,GAAG,EAAI;AAC3B,YAAIA,GAAJ,EAAS,OAAOL,QAAQ,CAACK,GAAD,CAAf;AAET,YAAM0D,UAAU,GAAG,EAAnB;AACA,YAAMC,gBAAgB,GAAG,EAAzB;AACA,YAAMvD,MAAM,GAAG,EAAf;AACA,YAAMC,aAAa,GAAG,EAAtB;AACA,YAAMuD,MAAM,GAAG,EAAf;AACA,YAAMC,YAAY,GAAG,EAArB;AAEA,YAAIvE,OAAO,GAAG,EAAd;AACA,YAAIwE,SAAS,GAAG,EAAhB;AACA,YAAIC,YAAY,GAAG,IAAnB;AACA,YAAIC,cAAc,GAAG,KAArB;AACA,YAAIC,kBAAkB,GAAG,KAAzB;AACA,YAAIC,YAAY,GAAG,IAAnB;AACA,YAAI5D,WAAW,GAAG,KAAlB;;AAEA,YAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,QAAD,EAAWC,UAAX,EAAuBC,IAAvB,EAAgC;AAClD,cAAIV,GAAG,GAAG,IAAIW,KAAJ,CAAUD,IAAI,CAACE,OAAf,CAAV;AACAZ,UAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,UAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;;AAEA,cAAI,MAAI,CAACa,MAAT,EAAiB;AACf,YAAA,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACD,WAFD,MAEO;AACL,gBAAIQ,QAAQ,IAAI,CAACF,WAAjB,EAA8B;AAC5B,kBAAIG,UAAJ,EAAgB;AACd,qBAAK,IAAMM,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,kBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAED,gBAAA,MAAI,CAACE,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;AACD;;AAEDH,cAAAA,WAAW,GAAG,IAAd;AACAX,cAAAA,QAAQ,CAACK,GAAD,CAAR;AACD;AACF,WApBiD,CAsBlD;;;AACAI,UAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD,SAxBD;;AA0BA,YAAMmB,UAAU,GAAG,SAAbA,UAAa,CAAAC,GAAG,EAAI;AACxB,UAAA,MAAI,CAACN,IAAL,CAAU,MAAV,EAAkB;AAChBF,YAAAA,OAAO,EAAEQ,GAAG,CAACR,OADG;AAEhBS,YAAAA,MAAM,EAAED,GAAG,CAACC,MAFI;AAGhBC,YAAAA,KAAK,EAAEF,GAAG,CAACE,KAHK;AAIhBC,YAAAA,KAAK,EAAEH,GAAG,CAACG,KAJK;AAKhBC,YAAAA,UAAU,EAAEJ,GAAG,CAACI,UALA;AAMhBC,YAAAA,UAAU,EAAEL,GAAG,CAACK,UANA;AAOhBC,YAAAA,QAAQ,EAAEN,GAAG,CAACM;AAPE,WAAlB;AASD,SAVD;;AAYA,QAAA,MAAI,CAACT,MAAL,CAAYU,OAAZ,CAAoB,MAApB,EAA0B,UAAC3B,GAAD,EAAMS,UAAN,EAAkB0D,MAAlB,EAA6B;AACrD,cAAInE,GAAJ,EAAS,OAAOL,QAAQ,CAACK,GAAD,CAAf;AAETrG,UAAAA,KAAK,CAAC,yCAAD,EAA4CG,GAAG,CAACgI,GAAJ,CAAQrB,UAAR,CAA5C,EAAiE3G,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAjE,CAAL;AAEA,cAAIiB,GAAJ;;AAEA,cAAI,MAAI,CAAChB,QAAT,EAAmB;AACjBpI,YAAAA,KAAK,CAAC,uBAAD,EAA0BG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAA1B,CAAL;;AACA,YAAA,MAAI,CAACb,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;;AACA,mBAAOd,QAAQ,CAAC,IAAI9F,YAAJ,CAAiB,WAAjB,EAA8B,SAA9B,CAAD,CAAf;AACD;;AAED,UAAA,MAAI,CAACmI,OAAL,GAAe,YAAM;AACnBrI,YAAAA,KAAK,CAAC,qBAAD,EAAwBG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAxB,CAAL;AACArB,YAAAA,UAAU,CAACwB,MAAX;AACD,WAHD,CAbqD,CAkBrD;;;AACAxB,UAAAA,UAAU,CAACyB,EAAX,CAAc,aAAd,EAA6B7B,aAAa,CAAC8B,WAAd,GAA4BhB,UAAzD;AACAV,UAAAA,UAAU,CAACyB,EAAX,CAAc,cAAd,EAA8B7B,aAAa,CAAC+B,YAAd,GAA6B7B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B5B,UAA9B,CAA3D;AACAA,UAAAA,UAAU,CAACyB,EAAX,CAAc,OAAd,EAAuB7B,aAAa,CAACiC,KAAd,GAAsB/B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B5B,UAA7B,CAA7C;AAEA9G,UAAAA,KAAK,CAAC,oBAAD,EAAuBG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAvB,EAAsC2B,OAAtC,CAAL;AAEA,cAAML,GAAG,GAAG,IAAI3J,GAAG,CAACgG,OAAR,CAAgBgE,OAAhB,EAAyB,UAAAzD,GAAG,EAAI;AAC1C;AACA,gBAAIA,GAAG,KAAK,CAACI,MAAM,CAAChD,MAAR,IAAmBgD,MAAM,CAAChD,MAAP,IAAiB4C,GAAG,CAACY,OAAJ,KAAgBR,MAAM,CAACA,MAAM,CAAChD,MAAP,GAAgB,CAAjB,CAAN,CAA0BwD,OAAnF,CAAP,EAAqG;AACnGZ,cAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;AACA,kBAAI,MAAI,CAACa,MAAT,EAAiB,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACjBI,cAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD,aANyC,CAQ1C;;;AACA,gBAAIgE,cAAJ,EAAoB;AAClB,kBAAI,CAAC,MAAI,CAACnD,MAAV,EAAkBkD,YAAY,GAAGL,UAAU,CAACjB,GAAX,GAAiB,CAAjB,CAAf;;AAElB,mBAAK,IAAM3E,IAAX,IAAmBiG,YAAnB,EAAiC;AAC/B,oBAAM5E,KAAK,GAAG4E,YAAY,CAACjG,IAAD,CAA1B;;AACA,oBAAIA,IAAI,KAAK,cAAb,EAA6B;AAC3B8F,kBAAAA,MAAM,CAAC9F,IAAD,CAAN,GAAeqB,KAAf;AACD;AACF;AACF;;AAED,mBAAO,MAAI,CAAC6C,OAAZ;AAEA,gBAAIM,KAAJ;;AACA,gBAAIlC,MAAM,CAAChD,MAAP,IAAiB,CAAC,MAAI,CAACyD,MAA3B,EAAmC;AACjCyB,cAAAA,KAAK,GAAGlC,MAAM,CAACqC,GAAP,EAAR;AACAH,cAAAA,KAAK,CAACI,eAAN,GAAwBtC,MAAxB;AACD;;AAED,gBAAI,CAACE,WAAL,EAAkB;AAChB,mBAAK,IAAMS,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,gBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAED,cAAA,MAAI,CAACE,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;;AACAH,cAAAA,WAAW,GAAG,IAAd;;AAEA,kBAAIgC,KAAJ,EAAW;AACT3I,gBAAAA,KAAK,CAAC,qBAAD,EAAwBG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAxB,EAAuCQ,KAAvC,CAAL;AACD,eAFD,MAEO;AACL3I,gBAAAA,KAAK,CAAC,wBAAD,EAA2BG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAA3B,CAAL;AACD;;AAED,kBAAI,MAAI,CAACjB,MAAT,EAAiB;AACflB,gBAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,EAAaiE,MAAb,EAAqBC,YAArB,EAAmCF,gBAAnC,CAAR;AACD,eAFD,MAEO;AACLhE,gBAAAA,QAAQ,CAAC2C,KAAD,EAAQoB,UAAR,EAAoBE,MAApB,EAA4BC,YAA5B,EAA0CF,gBAA1C,CAAR;AACD;AACF;AACF,WAhDW,CAAZ;;AAkDA,UAAA,MAAI,CAACJ,kBAAL,CAAwBH,GAAxB;;AAEAA,UAAAA,GAAG,CAAClB,EAAJ,CAAO,gBAAP,EAAyB,UAAA1E,QAAQ,EAAI;AACnC8B,YAAAA,OAAO,GAAG/B,aAAa,CAACC,QAAD,EAAW,MAAI,CAACC,YAAhB,CAAvB;AAEAwG,YAAAA,kBAAkB,GAAG,KAArB;;AACA,gBAAIzG,QAAQ,CAACJ,MAAT,KAAoB,CAApB,KAA0BI,QAAQ,CAAC,CAAD,CAAR,CAAYO,OAAZ,KAAwBxD,cAAxB,IAA0CiD,QAAQ,CAAC,CAAD,CAAR,CAAYO,OAAZ,KAAwBvD,aAA5F,CAAJ,EAAgH;AAC9GyJ,cAAAA,kBAAkB,GAAG,IAArB;AACAC,cAAAA,YAAY,GAAG,EAAf;AACD;;AAED,gBAAI,MAAI,CAACrD,MAAT,EAAiB;AACf,kBAAI,MAAI,CAACjB,QAAT,EAAmB;AACjB;AACA,oBAAI,CAACN,OAAO,CAAC8E,YAAb,EAA2B;AACzB,kBAAA,MAAI,CAACtD,IAAL,CAAU,WAAV,EAAuBxB,OAAvB;AACD;AACF,eALD,MAKO;AACL,gBAAA,MAAI,CAACwB,IAAL,CAAU,WAAV,EAAuBxB,OAAvB;AACD;AACF;;AACD,gBAAI,MAAI,CAAC7B,YAAT,EAAuBkG,gBAAgB,CAAC1E,IAAjB,CAAsBK,OAAtB;AACxB,WApBD;;AAsBA,cAAM+E,WAAW,GAAG,SAAdA,WAAc,CAAC7B,QAAD,EAAW8B,IAAX,EAAoB;AACtC,gBAAI9B,QAAQ,IAAI,IAAhB,EAAsB;AACpBqB,cAAAA,YAAY,CAAC5E,IAAb,CAAkBuD,QAAlB;;AACA,kBAAI,MAAI,CAAC3B,MAAT,EAAiB;AACf,gBAAA,MAAI,CAACC,IAAL,CAAU,cAAV,EAA0B0B,QAA1B;AACD;AACF,aANqC,CAOtC;;;AACA,gBAAI+B,MAAM,CAACC,IAAP,CAAYlF,OAAZ,EAAqBlC,MAArB,KAAgC,CAApC,EAAuC;;AAEvC,gBAAI6G,kBAAJ,EAAwB;AACtB,kBAAMQ,kBAAkB,GAAGP,YAAY,CAACQ,IAAb,CAAkB,EAAlB,CAA3B;;AACA,kBAAIpF,OAAO,CAAC/E,cAAD,CAAP,IAA2B4J,MAAM,CAACQ,SAAP,KAAqB,IAApD,EAA0D;AACxD,oBAAI;AACF,sBAAIF,kBAAkB,KAAK,EAA3B,EAA+B;AAC7B1B,oBAAAA,GAAG,GAAG,IAAN;AACD,mBAFD,MAEO;AACLA,oBAAAA,GAAG,GAAG6B,IAAI,CAACC,KAAL,CAAWJ,kBAAX,CAAN;AACD;AACF,iBAND,CAME,OAAOK,EAAP,EAAW;AACX/B,kBAAAA,GAAG,GAAG,IAAN;AACA,sBAAMgC,GAAG,GAAG,IAAIlL,YAAJ,CAAiB,IAAI8G,KAAJ,0CAA4CmE,EAAE,CAAClE,OAA/C,EAAjB,EAA4E,OAA5E,CAAZ;AAEA,sBAAI,MAAI,CAACC,MAAT,EAAiB,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBiE,GAAnB,EAJN,CAMX;;AACA3E,kBAAAA,MAAM,CAACnB,IAAP,CAAY8F,GAAZ;AACD;AACF,eAhBD,MAgBO;AACLhC,gBAAAA,GAAG,GAAG,EAAN;AACAA,gBAAAA,GAAG,CAACwB,MAAM,CAACC,IAAP,CAAYlF,OAAZ,EAAqB,CAArB,CAAD,CAAH,GAA+BmF,kBAA/B;AACD;;AAEDP,cAAAA,YAAY,GAAG,IAAf;;AAEA,kBAAI,MAAI,CAACrD,MAAT,EAAiB;AACf,gBAAA,MAAI,CAACC,IAAL,CAAU,KAAV,EAAiBiC,GAAjB;AACD,eAFD,MAEO;AACLe,gBAAAA,SAAS,CAAC7E,IAAV,CAAe8D,GAAf;AACD;AACF;;AAED,gBAAI,CAAC,MAAI,CAAClC,MAAV,EAAkB;AAChB;AACA0D,cAAAA,MAAM,CAACS,cAAP,CAAsBlB,SAAtB,EAAiC,SAAjC,EAA4C;AAC1CmB,gBAAAA,UAAU,EAAE,KAD8B;AAE1CC,gBAAAA,YAAY,EAAE,IAF4B;AAG1C/F,gBAAAA,KAAK,EAAEG;AAHmC,eAA5C;AAMAiF,cAAAA,MAAM,CAACS,cAAP,CAAsBlB,SAAtB,EAAiC,SAAjC,EAA4C;AAC1CmB,gBAAAA,UAAU,EAAE,KAD8B;AAE1CC,gBAAAA,YAAY,EAAE,IAF4B;AAG1C/F,gBAAAA,KAH0C,iBAGnCrB,IAHmC,EAG7B;AAAE,yBAAO1D,KAAK,CAAC+K,aAAN,CAAoB,IAApB,EAA0BrH,IAA1B,CAAP;AAAwC;AAHb,eAA5C;AAMA4F,cAAAA,UAAU,CAACzE,IAAX,CAAgB6E,SAAhB;AACD;;AAEDA,YAAAA,SAAS,GAAG,EAAZ;AACAxE,YAAAA,OAAO,GAAG,EAAV;AACD,WA7DD;;AA+DA8D,UAAAA,GAAG,CAAClB,EAAJ,CAAO,YAAP,EAAqBmC,WAArB,EAlKqD,CAkKnB;;AAClCjB,UAAAA,GAAG,CAAClB,EAAJ,CAAO,MAAP,EAAemC,WAAf,EAnKqD,CAmKzB;;AAE5BjB,UAAAA,GAAG,CAAClB,EAAJ,CAAO,aAAP,EAAsB,UAACkD,aAAD,EAAgBjG,KAAhB,EAAuB3B,QAAvB,EAAoC;AACxDoG,YAAAA,MAAM,CAACwB,aAAD,CAAN,GAAwBjG,KAAxB;AACD,WAFD;AAIAiE,UAAAA,GAAG,CAAClB,EAAJ,CAAO,KAAP,EAAc,UAAA5C,OAAO,EAAI;AACvB,gBAAI,CAACwE,SAAL,EAAgBA,SAAS,GAAG,EAAZ;;AAEhB,gBAAIG,kBAAJ,EAAwB;AACtB,qBAAOC,YAAY,CAACjF,IAAb,CAAkBK,OAAO,CAAC,CAAD,CAAP,CAAWH,KAA7B,CAAP;AACD;;AAED,gBAAI,MAAI,CAAC1B,YAAT,EAAuB;AACrBsF,cAAAA,GAAG,GAAG,EAAN;AACD,aAFD,MAEO;AACLA,cAAAA,GAAG,GAAG,EAAN;AACD;;AAXsB,wDAYLzD,OAZK;AAAA;;AAAA;AAYvB,qEAA2B;AAAA,oBAAhBE,GAAgB;AACzBA,gBAAAA,GAAG,CAACL,KAAJ,GAAYD,eAAe,CAACM,GAAG,CAACL,KAAL,EAAYK,GAAG,CAAChC,QAAhB,CAA3B;;AAEA,oBAAI,MAAI,CAACC,YAAT,EAAuB;AACrBsF,kBAAAA,GAAG,CAAC9D,IAAJ,CAASO,GAAG,CAACL,KAAb;AACD,iBAFD,MAEO;AACL,sBAAMkG,GAAG,GAAGtC,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAf;;AACA,sBAAIsH,GAAG,IAAI,IAAX,EAAiB;AACf,wBAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxBD,sBAAAA,GAAG,CAACpG,IAAJ,CAASO,GAAG,CAACL,KAAb;AACD,qBAFD,MAEO;AACL4D,sBAAAA,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAH,GAA4B,CAACsH,GAAD,EAAM7F,GAAG,CAACL,KAAV,CAA5B;AACD;AACF,mBAND,MAMO;AACL4D,oBAAAA,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAH,GAA4ByB,GAAG,CAACL,KAAhC;AACD;AACF;AACF;AA7BsB;AAAA;AAAA;AAAA;AAAA;;AA+BvB,gBAAI,MAAI,CAAC0B,MAAT,EAAiB;AACf,kBAAI,MAAI,CAACjB,QAAT,EAAmB;AACjB;AACA,oBAAImD,GAAG,CAACqB,YAAR,EAAsB;AACpBL,kBAAAA,YAAY,GAAGhB,GAAf;AACD,iBAFD,MAEO;AACL,kBAAA,MAAI,CAACjC,IAAL,CAAU,KAAV,EAAiBiC,GAAjB;AACD;AACF,eAPD,MAOO;AACL,gBAAA,MAAI,CAACjC,IAAL,CAAU,KAAV,EAAiBiC,GAAjB;AACD;AACF,aAXD,MAWO;AACLe,cAAAA,SAAS,CAAC7E,IAAV,CAAe8D,GAAf;AACD;AACF,WA7CD;;AA+CA,cAAI,MAAI,CAACnD,QAAT,EAAmB;AACjB,gBAAI2E,MAAM,CAACC,IAAP,CAAY,MAAI,CAACe,UAAjB,EAA6BnI,MAAjC,EAAyC;AACvC,mBAAK,IAAMU,IAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,oBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,IAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,oBAAM0H,KAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,IAAhB,CAAd;;AAEA,oBAAI;AACF0H,kBAAAA,KAAK,CAACrG,KAAN,GAAclE,cAAc,CAACuK,KAAK,CAACtK,IAAP,CAAd,CAA2BuK,QAA3B,CAAoCD,KAAK,CAACrG,KAA1C,CAAd;AACD,iBAFD,CAEE,OAAOe,CAAP,EAAU;AACVA,kBAAAA,CAAC,CAACU,OAAF,8CAAgD9C,IAAhD,gBAA0DoC,CAAC,CAACU,OAA5D;;AACA,sBAAMZ,IAAG,GAAG,IAAInG,YAAJ,CAAiBqG,CAAjB,EAAoB,QAApB,CAAZ;;AAEA,kBAAA,MAAI,CAACe,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;;AACA,yBAAOd,QAAQ,CAACK,IAAD,CAAf;AACD;AACF;;AAED,kBAAM0F,YAAY,GAAG,EAArB;;AACA,mBAAK,IAAM5H,KAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,oBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,KAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,oBAAM0H,MAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,KAAhB,CAAd;AACA4H,gBAAAA,YAAY,CAACzG,IAAb,YAAsBnB,KAAtB,cAA8B5D,OAAO,CAACsL,MAAK,CAACtK,IAAP,EAAasK,MAAb,CAArC;AACD;;AAED,kBAAMG,OAAO,GAAG,EAAhB;;AACA,mBAAK,IAAM7H,MAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,oBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,MAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,oBAAM0H,OAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,MAAhB,CAAd;AACA6H,gBAAAA,OAAO,CAAC1G,IAAR,YAAiBnB,MAAjB,gBAA2B3D,IAAI,CAACqL,OAAK,CAACrG,KAAP,EAAcqG,OAAK,CAACtK,IAApB,EAA0BsK,OAA1B,CAA/B;AACD;;AAED,kBAAMI,OAAO,GAAG,EAAhB;;AACA,mBAAK,IAAM9H,MAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,oBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,MAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,oBAAM0H,OAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,MAAhB,CAAd;;AACA,oBAAI0H,OAAK,CAACK,EAAN,KAAa,CAAjB,EAAoB;AAClBD,kBAAAA,OAAO,CAAC3G,IAAR,YAAiBnB,MAAjB,kBAA6BA,MAA7B;AACD;AACF;;AAEDkG,cAAAA,cAAc,GAAG4B,OAAO,CAACxI,MAAR,GAAiB,CAAlC;AAEAgG,cAAAA,GAAG,CAAC0C,kBAAJ,qBAAoCJ,YAAY,CAAChB,IAAb,CAAkB,IAAlB,CAApC,qBAAsEiB,OAAO,CAACjB,IAAR,CAAa,IAAb,CAAtE,cAA4FtB,GAAG,CAAC0C,kBAAhG,cAAsH9B,cAAc,yCAAmC4B,OAAO,CAAClB,IAAR,CAAa,IAAb,CAAnC,IAA2D,EAA/L;AACD;AACF,WApDD,MAoDO;AACL,iBAAK,IAAM5G,MAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,kBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,MAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,kBAAM0H,OAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,MAAhB,CAAd;;AACA,kBAAI0H,OAAK,CAACK,EAAN,KAAa,CAAjB,EAAoB;AAClBzC,gBAAAA,GAAG,CAAC2C,YAAJ,CAAiBP,OAAK,CAAC1H,IAAvB,EAA6B7C,cAAc,CAACuK,OAAK,CAACtK,IAAP,CAA3C,EAAyDkE,mBAAmB,CAACoG,OAAK,CAACrG,KAAP,CAA5E,EAA2F;AAAE/B,kBAAAA,MAAM,EAAEoI,OAAK,CAACpI,MAAhB;AAAwBa,kBAAAA,KAAK,EAAEuH,OAAK,CAACvH,KAArC;AAA4CC,kBAAAA,SAAS,EAAEsH,OAAK,CAACtH;AAA7D,iBAA3F;AACD,eAFD,MAEO;AACLkF,gBAAAA,GAAG,CAAC4C,kBAAJ,CAAuBR,OAAK,CAAC1H,IAA7B,EAAmC7C,cAAc,CAACuK,OAAK,CAACtK,IAAP,CAAjD,EAA+DkE,mBAAmB,CAACoG,OAAK,CAACrG,KAAP,CAAlF,EAAiG;AAAE/B,kBAAAA,MAAM,EAAEoI,OAAK,CAACpI,MAAhB;AAAwBa,kBAAAA,KAAK,EAAEuH,OAAK,CAACvH,KAArC;AAA4CC,kBAAAA,SAAS,EAAEsH,OAAK,CAACtH;AAA7D,iBAAjG;AACD;AACF;AACF;;AAED,cAAI;AACFuC,YAAAA,UAAU,CAAC,MAAI,CAACb,QAAL,GAAgB,cAAhB,GAAiC,SAAlC,CAAV,CAAuDwD,GAAvD;AACD,WAFD,CAEE,OAAOd,KAAP,EAAc;AACd/B,YAAAA,WAAW,CAAC,IAAD,EAAOE,UAAP,EAAmB6B,KAAnB,CAAX;AACD;AACF,SA/RD;AAgSD,OAxVD;AAyVD;AAED;AACF;AACA;;;;WAEE,kBAAU2D,SAAV,EAAqBtG,QAArB,EAA+B;AAAA;;AAC7B,4EAAesG,SAAf,EAA0B,UAAAjG,GAAG,EAAI;AAC/B,YAAIA,GAAJ,EAAS,OAAOL,QAAQ,CAACK,GAAD,CAAf;AAET,YAAM0D,UAAU,GAAG,EAAnB;AACA,YAAMC,gBAAgB,GAAG,EAAzB;AACA,YAAMvD,MAAM,GAAG,EAAf;AACA,YAAMC,aAAa,GAAG,EAAtB;AACA,YAAMuD,MAAM,GAAG,EAAf;AACA,YAAMC,YAAY,GAAG,EAArB;AAEA,YAAIvE,OAAO,GAAG,EAAd;AACA,YAAIwE,SAAS,GAAG,EAAhB;AACA,YAAIoC,WAAW,GAAG,CAAlB;AACA,YAAIjC,kBAAkB,GAAG,KAAzB;AACA,YAAIC,YAAY,GAAG,IAAnB;AACA,YAAI5D,WAAW,GAAG,KAAlB;;AAEA,YAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,QAAD,EAAWC,UAAX,EAAuBC,IAAvB,EAAgC;AAClD,cAAIV,GAAG,GAAG,IAAIW,KAAJ,CAAUD,IAAI,CAACE,OAAf,CAAV;AACAZ,UAAAA,GAAG,CAACU,IAAJ,GAAWA,IAAX;AACAV,UAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;;AAEA,cAAI,MAAI,CAACa,MAAT,EAAiB;AACf,YAAA,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACD,WAFD,MAEO;AACL,gBAAIQ,QAAQ,IAAI,CAACF,WAAjB,EAA8B;AAC5B,kBAAIG,UAAJ,EAAgB;AACd,qBAAK,IAAMM,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,kBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAED,gBAAA,MAAI,CAACE,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;AACD;;AAEDH,cAAAA,WAAW,GAAG,IAAd;AACAX,cAAAA,QAAQ,CAACK,GAAD,CAAR;AACD;AACF,WApBiD,CAsBlD;;;AACAI,UAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD,SAxBD;;AA0BA,YAAMmB,UAAU,GAAG,SAAbA,UAAa,CAAAC,GAAG,EAAI;AACxB,UAAA,MAAI,CAACN,IAAL,CAAU,MAAV,EAAkB;AAChBF,YAAAA,OAAO,EAAEQ,GAAG,CAACR,OADG;AAEhBS,YAAAA,MAAM,EAAED,GAAG,CAACC,MAFI;AAGhBC,YAAAA,KAAK,EAAEF,GAAG,CAACE,KAHK;AAIhBC,YAAAA,KAAK,EAAEH,GAAG,CAACG,KAJK;AAKhBC,YAAAA,UAAU,EAAEJ,GAAG,CAACI,UALA;AAMhBC,YAAAA,UAAU,EAAEL,GAAG,CAACK,UANA;AAOhBC,YAAAA,QAAQ,EAAEN,GAAG,CAACM;AAPE,WAAlB;AASD,SAVD;;AAYA,QAAA,MAAI,CAACT,MAAL,CAAYU,OAAZ,CAAoB,MAApB,EAA0B,UAAC3B,GAAD,EAAMS,UAAN,EAAkB0D,MAAlB,EAA6B;AACrD,cAAInE,GAAJ,EAAS,OAAOL,QAAQ,CAACK,GAAD,CAAf;AAETrG,UAAAA,KAAK,CAAC,yCAAD,EAA4CG,GAAG,CAACgI,GAAJ,CAAQrB,UAAR,CAA5C,EAAiE3G,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAjE,CAAL;AAEA,cAAIiB,GAAJ;;AAEA,cAAI,MAAI,CAAChB,QAAT,EAAmB;AACjBpI,YAAAA,KAAK,CAAC,uBAAD,EAA0BG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAA1B,CAAL;;AACA,YAAA,MAAI,CAACb,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;;AACA,mBAAOd,QAAQ,CAAC,IAAI9F,YAAJ,CAAiB,WAAjB,EAA8B,SAA9B,CAAD,CAAf;AACD;;AAED,UAAA,MAAI,CAACmI,OAAL,GAAe,YAAM;AACnBrI,YAAAA,KAAK,CAAC,qBAAD,EAAwBG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAxB,CAAL;AACArB,YAAAA,UAAU,CAACwB,MAAX;AACD,WAHD,CAbqD,CAkBrD;;;AACAxB,UAAAA,UAAU,CAACyB,EAAX,CAAc,aAAd,EAA6B7B,aAAa,CAAC8B,WAAd,GAA4BhB,UAAzD;AACAV,UAAAA,UAAU,CAACyB,EAAX,CAAc,cAAd,EAA8B7B,aAAa,CAAC+B,YAAd,GAA6B7B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,KAAvB,EAA8B5B,UAA9B,CAA3D;AACAA,UAAAA,UAAU,CAACyB,EAAX,CAAc,OAAd,EAAuB7B,aAAa,CAACiC,KAAd,GAAsB/B,WAAW,CAAC8B,IAAZ,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B5B,UAA7B,CAA7C;;AAEA,cAAI9G,KAAK,CAACwM,OAAV,EAAmB;AACjB;AACA,gBAAMC,MAAM,GAAG7B,MAAM,CAACC,IAAP,CAAY,MAAI,CAACe,UAAjB,EAA6Bc,GAA7B,CAAiC,UAAAC,CAAC;AAAA,qBAAI,MAAI,CAACf,UAAL,CAAgBe,CAAhB,CAAJ;AAAA,aAAlC,CAAf,CAFiB,CAGjB;;AACA,gBAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAC,CAAC;AAAA,qBAAI,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,CAACpJ,MAAF,GAAW,EAApC,GAAyCoJ,CAAC,CAACC,SAAF,CAAY,CAAZ,EAAe,EAAf,IAAqB,KAA9D,GAAsED,CAA1E;AAAA,aAAlB,CAJiB,CAKjB;;;AACA,gBAAME,OAAO,GAAG,SAAVA,OAAU,CAAAlB,KAAK;AAAA,qBAAIA,KAAK,CAAC1H,IAAN,GAAa,QAAb,GAAwB0H,KAAK,CAACtK,IAAN,CAAW4C,IAAnC,GAA0C,GAA9C;AAAA,aAArB;;AACA,gBAAM6I,SAAS,GAAG,EAAlB;AACAP,YAAAA,MAAM,CAACQ,OAAP,CAAe,UAAAC,CAAC,EAAI;AAAEF,cAAAA,SAAS,CAACD,OAAO,CAACG,CAAD,CAAR,CAAT,GAAwBN,QAAQ,CAACM,CAAC,CAAC1H,KAAH,CAAhC;AAA2C,aAAjE;AACAxF,YAAAA,KAAK,CAAC,4BAAD,EAA+BG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAA/B,EAA8CmE,SAA9C,EAAyDU,SAAzD,CAAL;AACD;;AAED,cAAMvD,GAAG,GAAG,IAAI3J,GAAG,CAACgG,OAAR,CAAgBwG,SAAhB,EAA2B,UAAAjG,GAAG,EAAI;AAC5C;AACA,gBAAIA,GAAG,KAAK,CAACI,MAAM,CAAChD,MAAR,IAAmBgD,MAAM,CAAChD,MAAP,IAAiB4C,GAAG,CAACY,OAAJ,KAAgBR,MAAM,CAACA,MAAM,CAAChD,MAAP,GAAgB,CAAjB,CAAN,CAA0BwD,OAAnF,CAAP,EAAqG;AACnGZ,cAAAA,GAAG,GAAG,IAAInG,YAAJ,CAAiBmG,GAAjB,EAAsB,UAAtB,CAAN;AACA,kBAAI,MAAI,CAACa,MAAT,EAAiB,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBd,GAAnB;AACjBI,cAAAA,MAAM,CAACnB,IAAP,CAAYe,GAAZ;AACD;;AAED,mBAAO,MAAI,CAACgC,OAAZ;AAEA,gBAAIM,KAAJ;;AACA,gBAAIlC,MAAM,CAAChD,MAAP,IAAiB,CAAC,MAAI,CAACyD,MAA3B,EAAmC;AACjCyB,cAAAA,KAAK,GAAGlC,MAAM,CAACqC,GAAP,EAAR;AACAH,cAAAA,KAAK,CAACI,eAAN,GAAwBtC,MAAxB;AACD;;AAED,gBAAI,CAACE,WAAL,EAAkB;AAChB,mBAAK,IAAMS,KAAX,IAAoBV,aAApB,EAAmC;AACjCI,gBAAAA,UAAU,CAACO,cAAX,CAA0BD,KAA1B,EAAiCV,aAAa,CAACU,KAAD,CAA9C;AACD;;AAED,cAAA,MAAI,CAACE,MAAL,CAAYC,OAAZ,CAAoBT,UAApB;;AACAH,cAAAA,WAAW,GAAG,IAAd;;AAEA,kBAAIgC,KAAJ,EAAW;AACT3I,gBAAAA,KAAK,CAAC,qBAAD,EAAwBG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAAxB,EAAuCQ,KAAvC,CAAL;AACD,eAFD,MAEO;AACL3I,gBAAAA,KAAK,CAAC,uBAAD,EAA0BG,GAAG,CAACgI,GAAJ,CAAQ,MAAR,CAA1B,CAAL;AACD;;AAED,kBAAI,MAAI,CAACjB,MAAT,EAAiB;AACflB,gBAAAA,QAAQ,CAAC,IAAD,EAAO,IAAP,EAAaiE,MAAb,EAAqBsC,WAArB,EAAkCrC,YAAlC,EAAgDF,gBAAhD,CAAR;AACD,eAFD,MAEO;AACLhE,gBAAAA,QAAQ,CAAC2C,KAAD,EAAQoB,UAAR,EAAoBE,MAApB,EAA4BsC,WAA5B,EAAyCrC,YAAzC,EAAuDF,gBAAvD,CAAR;AACD;AACF;AACF,WApCW,CAAZ;;AAsCA,UAAA,MAAI,CAACJ,kBAAL,CAAwBH,GAAxB;;AAEAA,UAAAA,GAAG,CAAClB,EAAJ,CAAO,gBAAP,EAAyB,UAAA1E,QAAQ,EAAI;AACnC8B,YAAAA,OAAO,GAAG/B,aAAa,CAACC,QAAD,EAAW,MAAI,CAACC,YAAhB,CAAvB;AAEAwG,YAAAA,kBAAkB,GAAG,KAArB;;AACA,gBAAKzG,QAAQ,CAACJ,MAAT,KAAoB,CAArB,KAA4BI,QAAQ,CAAC,CAAD,CAAR,CAAYO,OAAZ,KAAwBxD,cAAxB,IAA0CiD,QAAQ,CAAC,CAAD,CAAR,CAAYO,OAAZ,KAAwBvD,aAA9F,CAAJ,EAAkH;AAChHyJ,cAAAA,kBAAkB,GAAG,IAArB;AACAC,cAAAA,YAAY,GAAG,EAAf;AACD;;AAED,gBAAI,MAAI,CAACrD,MAAT,EAAiB,MAAI,CAACC,IAAL,CAAU,WAAV,EAAuBxB,OAAvB;AACjB,gBAAI,MAAI,CAAC7B,YAAT,EAAuBkG,gBAAgB,CAAC1E,IAAjB,CAAsBK,OAAtB;AACxB,WAXD;AAaA8D,UAAAA,GAAG,CAAClB,EAAJ,CAAO,KAAP,EAAc,UAAA5C,OAAO,EAAI;AACvB,gBAAI,CAACwE,SAAL,EAAgBA,SAAS,GAAG,EAAZ;;AAEhB,gBAAIG,kBAAJ,EAAwB;AACtB,qBAAOC,YAAY,CAACjF,IAAb,CAAkBK,OAAO,CAAC,CAAD,CAAP,CAAWH,KAA7B,CAAP;AACD;;AAED,gBAAI,MAAI,CAAC1B,YAAT,EAAuB;AACrBsF,cAAAA,GAAG,GAAG,EAAN;AACD,aAFD,MAEO;AACLA,cAAAA,GAAG,GAAG,EAAN;AACD;;AAXsB,wDAYLzD,OAZK;AAAA;;AAAA;AAYvB,qEAA2B;AAAA,oBAAhBE,GAAgB;AACzBA,gBAAAA,GAAG,CAACL,KAAJ,GAAYD,eAAe,CAACM,GAAG,CAACL,KAAL,EAAYK,GAAG,CAAChC,QAAhB,CAA3B;;AAEA,oBAAI,MAAI,CAACC,YAAT,EAAuB;AACrBsF,kBAAAA,GAAG,CAAC9D,IAAJ,CAASO,GAAG,CAACL,KAAb;AACD,iBAFD,MAEO;AACL,sBAAMkG,GAAG,GAAGtC,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAf;;AACA,sBAAIsH,GAAG,IAAI,IAAX,EAAiB;AACf,wBAAIA,GAAG,YAAYC,KAAnB,EAA0B;AACxBD,sBAAAA,GAAG,CAACpG,IAAJ,CAASO,GAAG,CAACL,KAAb;AACD,qBAFD,MAEO;AACL4D,sBAAAA,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAH,GAA4B,CAACsH,GAAD,EAAM7F,GAAG,CAACL,KAAV,CAA5B;AACD;AACF,mBAND,MAMO;AACL4D,oBAAAA,GAAG,CAACvD,GAAG,CAAChC,QAAJ,CAAaO,OAAd,CAAH,GAA4ByB,GAAG,CAACL,KAAhC;AACD;AACF;AACF;AA7BsB;AAAA;AAAA;AAAA;AAAA;;AA+BvB,gBAAI,MAAI,CAAC0B,MAAT,EAAiB;AACf,cAAA,MAAI,CAACC,IAAL,CAAU,KAAV,EAAiBiC,GAAjB;AACD,aAFD,MAEO;AACLe,cAAAA,SAAS,CAAC7E,IAAV,CAAe8D,GAAf;AACD;AACF,WApCD;AAsCAK,UAAAA,GAAG,CAAClB,EAAJ,CAAO,YAAP,EAAqB,UAACM,QAAD,EAAW8B,IAAX,EAAoB;AACvC,gBAAI9B,QAAQ,IAAI,IAAhB,EAAsB;AACpBqB,cAAAA,YAAY,CAAC5E,IAAb,CAAkBuD,QAAlB;;AACA,kBAAI,MAAI,CAAC3B,MAAT,EAAiB;AACf,gBAAA,MAAI,CAACC,IAAL,CAAU,cAAV,EAA0B0B,QAA1B;AACD;AACF,aANsC,CAQvC;;;AACA,gBAAI+B,MAAM,CAACC,IAAP,CAAYlF,OAAZ,EAAqBlC,MAArB,KAAgC,CAApC,EAAuC;;AAEvC,gBAAI6G,kBAAJ,EAAwB;AACtB,kBAAI3E,OAAO,CAAC/E,cAAD,CAAP,IAA2B4J,MAAM,CAACQ,SAAP,KAAqB,IAApD,EAA0D;AACxD,oBAAI;AACF,sBAAIT,YAAY,CAAC9G,MAAb,KAAwB,CAA5B,EAA+B;AAC7B2F,oBAAAA,GAAG,GAAG,IAAN;AACD,mBAFD,MAEO;AACLA,oBAAAA,GAAG,GAAG6B,IAAI,CAACC,KAAL,CAAWX,YAAY,CAACQ,IAAb,CAAkB,EAAlB,CAAX,CAAN;AACD;AACF,iBAND,CAME,OAAOI,EAAP,EAAW;AACX/B,kBAAAA,GAAG,GAAG,IAAN;AACA,sBAAMgC,GAAG,GAAG,IAAIlL,YAAJ,CAAiB,IAAI8G,KAAJ,0CAA4CmE,EAAE,CAAClE,OAA/C,EAAjB,EAA4E,OAA5E,CAAZ;AAEA,sBAAI,MAAI,CAACC,MAAT,EAAiB,MAAI,CAACC,IAAL,CAAU,OAAV,EAAmBiE,GAAnB,EAJN,CAMX;;AACA3E,kBAAAA,MAAM,CAACnB,IAAP,CAAY8F,GAAZ;AACD;AACF,eAhBD,MAgBO;AACLhC,gBAAAA,GAAG,GAAG,EAAN;AACAA,gBAAAA,GAAG,CAACwB,MAAM,CAACC,IAAP,CAAYlF,OAAZ,EAAqB,CAArB,CAAD,CAAH,GAA+B4E,YAAY,CAACQ,IAAb,CAAkB,EAAlB,CAA/B;AACD;;AAEDR,cAAAA,YAAY,GAAG,IAAf;;AAEA,kBAAI,MAAI,CAACrD,MAAT,EAAiB;AACf,gBAAA,MAAI,CAACC,IAAL,CAAU,KAAV,EAAiBiC,GAAjB;AACD,eAFD,MAEO;AACLe,gBAAAA,SAAS,CAAC7E,IAAV,CAAe8D,GAAf;AACD;AACF;;AAED,gBAAI,CAAC,MAAI,CAAClC,MAAV,EAAkB;AAChB;AACA0D,cAAAA,MAAM,CAACS,cAAP,CAAsBlB,SAAtB,EAAiC,SAAjC,EAA4C;AAC1CmB,gBAAAA,UAAU,EAAE,KAD8B;AAE1CC,gBAAAA,YAAY,EAAE,IAF4B;AAG1C/F,gBAAAA,KAAK,EAAEG;AAHmC,eAA5C;AAMAiF,cAAAA,MAAM,CAACS,cAAP,CAAsBlB,SAAtB,EAAiC,SAAjC,EAA4C;AAC1CmB,gBAAAA,UAAU,EAAE,KAD8B;AAE1CC,gBAAAA,YAAY,EAAE,IAF4B;AAG1C/F,gBAAAA,KAH0C,iBAGnCrB,IAHmC,EAG7B;AAAE,yBAAO1D,KAAK,CAAC+K,aAAN,CAAoB,IAApB,EAA0BrH,IAA1B,CAAP;AAAwC;AAHb,eAA5C;AAMA4F,cAAAA,UAAU,CAACzE,IAAX,CAAgB6E,SAAhB;AACD;;AAEDA,YAAAA,SAAS,GAAG,EAAZ;AACAxE,YAAAA,OAAO,GAAG,EAAV;AACD,WA7DD;AA+DA8D,UAAAA,GAAG,CAAClB,EAAJ,CAAO,UAAP,EAAmB,UAACM,QAAD,EAAW8B,IAAX,EAAiBwC,YAAjB,EAAkC;AACnDZ,YAAAA,WAAW,GAAGY,YAAd;AACD,WAFD;AAIA1D,UAAAA,GAAG,CAAClB,EAAJ,CAAO,aAAP,EAAsB,UAACkD,aAAD,EAAgBjG,KAAhB,EAAuB3B,QAAvB,EAAoC;AACxDoG,YAAAA,MAAM,CAACwB,aAAD,CAAN,GAAwBjG,KAAxB;AACD,WAFD;;AAIA,eAAK,IAAMrB,IAAX,IAAmB,MAAI,CAACyH,UAAxB,EAAoC;AAClC,gBAAI,CAACxL,iBAAiB,CAAC,MAAI,CAACwL,UAAN,EAAkBzH,IAAlB,CAAtB,EAA+C;AAC7C;AACD;;AACD,gBAAM0H,KAAK,GAAG,MAAI,CAACD,UAAL,CAAgBzH,IAAhB,CAAd;;AACA,gBAAI0H,KAAK,CAACK,EAAN,KAAa,CAAjB,EAAoB;AAClBzC,cAAAA,GAAG,CAAC2C,YAAJ,CAAiBP,KAAK,CAAC1H,IAAvB,EAA6B7C,cAAc,CAACuK,KAAK,CAACtK,IAAP,CAA3C,EAAyDkE,mBAAmB,CAACoG,KAAK,CAACrG,KAAP,CAA5E,EAA2F;AAAE/B,gBAAAA,MAAM,EAAEoI,KAAK,CAACpI,MAAhB;AAAwBa,gBAAAA,KAAK,EAAEuH,KAAK,CAACvH,KAArC;AAA4CC,gBAAAA,SAAS,EAAEsH,KAAK,CAACtH;AAA7D,eAA3F;AACD,aAFD,MAEO;AACLkF,cAAAA,GAAG,CAAC4C,kBAAJ,CAAuBR,KAAK,CAAC1H,IAA7B,EAAmC7C,cAAc,CAACuK,KAAK,CAACtK,IAAP,CAAjD,EAA+DkE,mBAAmB,CAACoG,KAAK,CAACrG,KAAP,CAAlF,EAAiG;AAAE/B,gBAAAA,MAAM,EAAEoI,KAAK,CAACpI,MAAhB;AAAwBa,gBAAAA,KAAK,EAAEuH,KAAK,CAACvH,KAArC;AAA4CC,gBAAAA,SAAS,EAAEsH,KAAK,CAACtH;AAA7D,eAAjG;AACD;AACF;;AAEDuC,UAAAA,UAAU,CAACsG,aAAX,CAAyB3D,GAAzB;AACD,SAlND;AAmND,OA1QD;AA2QD;;;WAED,kBAAU;AACR;;AACA,UAAI,KAAK4D,eAAT,EAA0B;AACxB,aAAKA,eAAL,CAAqBC,KAArB;AACD;AACF;;;WAED,mBAAW;AACT;;AACA,UAAI,KAAKD,eAAT,EAA0B;AACxB,aAAKA,eAAL,CAAqBE,MAArB;AACD;AACF;;;;EAlyBmBtN,W;;AAqyBtBuN,MAAM,CAACC,OAAP,GAAiB3H,OAAjB","sourcesContent":["'use strict'\r\n\r\nconst tds = require('tedious')\r\nconst debug = require('debug')('mssql:tedi')\r\nconst BaseRequest = require('../base/request')\r\nconst RequestError = require('../error/request-error')\r\nconst { IDS, objectHasProperty } = require('../utils')\r\nconst { TYPES, DECLARATIONS, declare, cast } = require('../datatypes')\r\nconst Table = require('../table')\r\nconst { PARSERS: UDT } = require('../udt')\r\n\r\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\r\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\r\n\r\nconst N_TYPES = {\r\n  BitN: 0x68,\r\n  DateTimeN: 0x6F,\r\n  DecimalN: 0x6A,\r\n  FloatN: 0x6D,\r\n  IntN: 0x26,\r\n  MoneyN: 0x6E,\r\n  NumericN: 0x6C\r\n}\r\n\r\nconst getTediousType = function (type) {\r\n  switch (type) {\r\n    case TYPES.VarChar: return tds.TYPES.VarChar\r\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\r\n    case TYPES.Text: return tds.TYPES.Text\r\n    case TYPES.Int: return tds.TYPES.Int\r\n    case TYPES.BigInt: return tds.TYPES.BigInt\r\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\r\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\r\n    case TYPES.Bit: return tds.TYPES.Bit\r\n    case TYPES.Float: return tds.TYPES.Float\r\n    case TYPES.Decimal: return tds.TYPES.Decimal\r\n    case TYPES.Numeric: return tds.TYPES.Numeric\r\n    case TYPES.Real: return tds.TYPES.Real\r\n    case TYPES.Money: return tds.TYPES.Money\r\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\r\n    case TYPES.Time: return tds.TYPES.Time\r\n    case TYPES.Date: return tds.TYPES.Date\r\n    case TYPES.DateTime: return tds.TYPES.DateTime\r\n    case TYPES.DateTime2: return tds.TYPES.DateTime2\r\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset\r\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\r\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier\r\n    case TYPES.Xml: return tds.TYPES.NVarChar\r\n    case TYPES.Char: return tds.TYPES.Char\r\n    case TYPES.NChar: return tds.TYPES.NChar\r\n    case TYPES.NText: return tds.TYPES.NVarChar\r\n    case TYPES.Image: return tds.TYPES.Image\r\n    case TYPES.Binary: return tds.TYPES.Binary\r\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\r\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\r\n    case TYPES.TVP: return tds.TYPES.TVP\r\n    case TYPES.Variant: return tds.TYPES.Variant\r\n    default: return type\r\n  }\r\n}\r\n\r\nconst getMssqlType = function (type, length) {\r\n  if (typeof type !== 'object') return undefined\r\n\r\n  switch (type) {\r\n    case tds.TYPES.Char: return TYPES.Char\r\n    case tds.TYPES.NChar: return TYPES.NChar\r\n    case tds.TYPES.VarChar: return TYPES.VarChar\r\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\r\n    case tds.TYPES.Text: return TYPES.Text\r\n    case tds.TYPES.NText: return TYPES.NText\r\n    case tds.TYPES.Int: return TYPES.Int\r\n    case tds.TYPES.BigInt: return TYPES.BigInt\r\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\r\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\r\n    case tds.TYPES.Bit: return TYPES.Bit\r\n    case tds.TYPES.Float: return TYPES.Float\r\n    case tds.TYPES.Real: return TYPES.Real\r\n    case tds.TYPES.Money: return TYPES.Money\r\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\r\n    case tds.TYPES.Numeric: return TYPES.Numeric\r\n    case tds.TYPES.Decimal: return TYPES.Decimal\r\n    case tds.TYPES.DateTime: return TYPES.DateTime\r\n    case tds.TYPES.Time: return TYPES.Time\r\n    case tds.TYPES.Date: return TYPES.Date\r\n    case tds.TYPES.DateTime2: return TYPES.DateTime2\r\n    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset\r\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\r\n    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier\r\n    case tds.TYPES.Image: return TYPES.Image\r\n    case tds.TYPES.Binary: return TYPES.Binary\r\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\r\n    case tds.TYPES.Xml: return TYPES.Xml\r\n    case tds.TYPES.UDT: return TYPES.UDT\r\n    case tds.TYPES.TVP: return TYPES.TVP\r\n    case tds.TYPES.Variant: return TYPES.Variant\r\n    default:\r\n      switch (type.id) {\r\n        case N_TYPES.BitN: return TYPES.Bit\r\n        case N_TYPES.NumericN: return TYPES.Numeric\r\n        case N_TYPES.DecimalN: return TYPES.Decimal\r\n        case N_TYPES.IntN:\r\n          if (length === 8) return TYPES.BigInt\r\n          if (length === 4) return TYPES.Int\r\n          if (length === 2) return TYPES.SmallInt\r\n          return TYPES.TinyInt\r\n        case N_TYPES.FloatN:\r\n          if (length === 8) return TYPES.Float\r\n          return TYPES.Real\r\n        case N_TYPES.MoneyN:\r\n          if (length === 8) return TYPES.Money\r\n          return TYPES.SmallMoney\r\n        case N_TYPES.DateTimeN:\r\n          if (length === 8) return TYPES.DateTime\r\n          return TYPES.SmallDateTime\r\n      }\r\n  }\r\n}\r\n\r\nconst createColumns = function (metadata, arrayRowMode) {\r\n  let out = {}\r\n  if (arrayRowMode) out = []\r\n  for (let index = 0, length = metadata.length; index < length; index++) {\r\n    const column = metadata[index]\r\n    const outColumn = {\r\n      index,\r\n      name: column.colName,\r\n      length: column.dataLength,\r\n      type: getMssqlType(column.type, column.dataLength),\r\n      scale: column.scale,\r\n      precision: column.precision,\r\n      nullable: !!(column.flags & 0x01),\r\n      caseSensitive: !!(column.flags & 0x02),\r\n      identity: !!(column.flags & 0x10),\r\n      readOnly: !(column.flags & 0x0C)\r\n    }\r\n\r\n    if (column.udtInfo) {\r\n      outColumn.udt = {\r\n        name: column.udtInfo.typeName,\r\n        database: column.udtInfo.dbname,\r\n        schema: column.udtInfo.owningSchema,\r\n        assembly: column.udtInfo.assemblyName\r\n      }\r\n\r\n      if (DECLARATIONS[column.udtInfo.typeName]) {\r\n        outColumn.type = DECLARATIONS[column.udtInfo.typeName]\r\n      }\r\n    }\r\n\r\n    if (arrayRowMode) {\r\n      out.push(outColumn)\r\n    } else {\r\n      out[column.colName] = outColumn\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n\r\nconst valueCorrection = function (value, metadata) {\r\n  if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\r\n    if (UDT[metadata.udtInfo.typeName]) {\r\n      return UDT[metadata.udtInfo.typeName](value)\r\n    } else {\r\n      return value\r\n    }\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nconst parameterCorrection = function (value) {\r\n  if (value instanceof Table) {\r\n    const tvp = {\r\n      name: value.name,\r\n      schema: value.schema,\r\n      columns: [],\r\n      rows: value.rows\r\n    }\r\n\r\n    for (const col of value.columns) {\r\n      tvp.columns.push({\r\n        name: col.name,\r\n        type: getTediousType(col.type),\r\n        length: col.length,\r\n        scale: col.scale,\r\n        precision: col.precision\r\n      })\r\n    }\r\n\r\n    return tvp\r\n  } else {\r\n    return value\r\n  }\r\n}\r\n\r\nclass Request extends BaseRequest {\r\n  /*\r\n  Execute specified sql batch.\r\n  */\r\n\r\n  _batch (batch, callback) {\r\n    this._isBatch = true\r\n    this._query(batch, callback)\r\n  }\r\n\r\n  /*\r\n  Bulk load.\r\n  */\r\n\r\n  _bulk (table, options, callback) {\r\n    super._bulk(table, options, err => {\r\n      if (err) return callback(err)\r\n\r\n      try {\r\n        table._makeBulk()\r\n      } catch (e) {\r\n        return callback(new RequestError(e, 'EREQUEST'))\r\n      }\r\n\r\n      if (!table.name) {\r\n        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))\r\n      }\r\n\r\n      if (table.name.charAt(0) === '@') {\r\n        return callback(new RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\r\n      }\r\n\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection) => {\r\n        const callbackWithRelease = (err, ...args) => {\r\n          try {\r\n            this.parent.release(connection)\r\n          } catch (e) {\r\n            // noop\r\n          }\r\n          callback(err, ...args)\r\n        }\r\n        if (err) return callbackWithRelease(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        const done = (err, rowCount) => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            hasReturned = true\r\n\r\n            if (this.stream) {\r\n              callbackWithRelease(null, rowCount)\r\n            } else {\r\n              callbackWithRelease(error, rowCount)\r\n            }\r\n          }\r\n        }\r\n\r\n        const bulk = connection.newBulkLoad(table.path, options, done)\r\n\r\n        for (const col of table.columns) {\r\n          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision })\r\n        }\r\n\r\n        for (const row of table.rows) {\r\n          try {\r\n            bulk.addRow(row)\r\n          } catch (e) {\r\n            return handleError(true, connection, e)\r\n          }\r\n        }\r\n\r\n        if (table.create) {\r\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\r\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\r\n            if (err) return done(err)\r\n\r\n            connection.execBulkLoad(bulk)\r\n          })\r\n          this._setCurrentRequest(req)\r\n\r\n          connection.execSqlBatch(req)\r\n        } else {\r\n          connection.execBulkLoad(bulk)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute specified sql command.\r\n  */\r\n\r\n  _query (command, callback) {\r\n    super._query(command, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const recordsetcolumns = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let batchLastRow = null\r\n      let batchHasOutput = false\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        debug('request(%d): query', IDS.get(this), command)\r\n\r\n        const req = new tds.Request(command, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          // process batch outputs\r\n          if (batchHasOutput) {\r\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\r\n\r\n            for (const name in batchLastRow) {\r\n              const value = batchLastRow[name]\r\n              if (name !== '___return___') {\r\n                output[name] = value\r\n              }\r\n            }\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): completed', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, rowsAffected, recordsetcolumns)\r\n            } else {\r\n              callback(error, recordsets, output, rowsAffected, recordsetcolumns)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata, this.arrayRowMode)\r\n\r\n          isChunkedRecordset = false\r\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // don't stream recordset with output values in batches\r\n              if (!columns.___return___) {\r\n                this.emit('recordset', columns)\r\n              }\r\n            } else {\r\n              this.emit('recordset', columns)\r\n            }\r\n          }\r\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\r\n        })\r\n\r\n        const doneHandler = (rowCount, more) => {\r\n          if (rowCount != null) {\r\n            rowsAffected.push(rowCount)\r\n            if (this.stream) {\r\n              this.emit('rowsaffected', rowCount)\r\n            }\r\n          }\r\n          // this function is called even when select only set variables so we should skip adding a new recordset\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            const concatenatedChunks = chunksBuffer.join('')\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (concatenatedChunks === '') {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(concatenatedChunks)\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = concatenatedChunks\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        }\r\n\r\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\r\n        req.on('done', doneHandler) // done handlers are used in batches\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          if (this.arrayRowMode) {\r\n            row = []\r\n          } else {\r\n            row = {}\r\n          }\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            if (this.arrayRowMode) {\r\n              row.push(col.value)\r\n            } else {\r\n              const exi = row[col.metadata.colName]\r\n              if (exi != null) {\r\n                if (exi instanceof Array) {\r\n                  exi.push(col.value)\r\n                } else {\r\n                  row[col.metadata.colName] = [exi, col.value]\r\n                }\r\n              } else {\r\n                row[col.metadata.colName] = col.value\r\n              }\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            if (this._isBatch) {\r\n              // dont stream recordset with output values in batches\r\n              if (row.___return___) {\r\n                batchLastRow = row\r\n              } else {\r\n                this.emit('row', row)\r\n              }\r\n            } else {\r\n              this.emit('row', row)\r\n            }\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        if (this._isBatch) {\r\n          if (Object.keys(this.parameters).length) {\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n\r\n              try {\r\n                param.value = getTediousType(param.type).validate(param.value)\r\n              } catch (e) {\r\n                e.message = `Validation failed for parameter '${name}'. ${e.message}`\r\n                const err = new RequestError(e, 'EPARAM')\r\n\r\n                this.parent.release(connection)\r\n                return callback(err)\r\n              }\r\n            }\r\n\r\n            const declarations = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              declarations.push(`@${name} ${declare(param.type, param)}`)\r\n            }\r\n\r\n            const assigns = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\r\n            }\r\n\r\n            const selects = []\r\n            for (const name in this.parameters) {\r\n              if (!objectHasProperty(this.parameters, name)) {\r\n                continue\r\n              }\r\n              const param = this.parameters[name]\r\n              if (param.io === 2) {\r\n                selects.push(`@${name} as [${name}]`)\r\n              }\r\n            }\r\n\r\n            batchHasOutput = selects.length > 0\r\n\r\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\r\n          }\r\n        } else {\r\n          for (const name in this.parameters) {\r\n            if (!objectHasProperty(this.parameters, name)) {\r\n              continue\r\n            }\r\n            const param = this.parameters[name]\r\n            if (param.io === 1) {\r\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            } else {\r\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n            }\r\n          }\r\n        }\r\n\r\n        try {\r\n          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\r\n        } catch (error) {\r\n          handleError(true, connection, error)\r\n        }\r\n      })\r\n    })\r\n  }\r\n\r\n  /*\r\n  Execute stored procedure with specified parameters.\r\n  */\r\n\r\n  _execute (procedure, callback) {\r\n    super._execute(procedure, err => {\r\n      if (err) return callback(err)\r\n\r\n      const recordsets = []\r\n      const recordsetcolumns = []\r\n      const errors = []\r\n      const errorHandlers = {}\r\n      const output = {}\r\n      const rowsAffected = []\r\n\r\n      let columns = {}\r\n      let recordset = []\r\n      let returnValue = 0\r\n      let isChunkedRecordset = false\r\n      let chunksBuffer = null\r\n      let hasReturned = false\r\n\r\n      const handleError = (doReturn, connection, info) => {\r\n        let err = new Error(info.message)\r\n        err.info = info\r\n        err = new RequestError(err, 'EREQUEST')\r\n\r\n        if (this.stream) {\r\n          this.emit('error', err)\r\n        } else {\r\n          if (doReturn && !hasReturned) {\r\n            if (connection) {\r\n              for (const event in errorHandlers) {\r\n                connection.removeListener(event, errorHandlers[event])\r\n              }\r\n\r\n              this.parent.release(connection)\r\n            }\r\n\r\n            hasReturned = true\r\n            callback(err)\r\n          }\r\n        }\r\n\r\n        // we must collect errors even in stream mode\r\n        errors.push(err)\r\n      }\r\n\r\n      const handleInfo = msg => {\r\n        this.emit('info', {\r\n          message: msg.message,\r\n          number: msg.number,\r\n          state: msg.state,\r\n          class: msg.class,\r\n          lineNumber: msg.lineNumber,\r\n          serverName: msg.serverName,\r\n          procName: msg.procName\r\n        })\r\n      }\r\n\r\n      this.parent.acquire(this, (err, connection, config) => {\r\n        if (err) return callback(err)\r\n\r\n        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this))\r\n\r\n        let row\r\n\r\n        if (this.canceled) {\r\n          debug('request(%d): canceled', IDS.get(this))\r\n          this.parent.release(connection)\r\n          return callback(new RequestError('Canceled.', 'ECANCEL'))\r\n        }\r\n\r\n        this._cancel = () => {\r\n          debug('request(%d): cancel', IDS.get(this))\r\n          connection.cancel()\r\n        }\r\n\r\n        // attach handler to handle multiple error messages\r\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\r\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\r\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\r\n\r\n        if (debug.enabled) {\r\n          // log stored procedure executions and provided parameters\r\n          const params = Object.keys(this.parameters).map(k => this.parameters[k])\r\n          // cut long string parameters short to keep log somewhat clean\r\n          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s\r\n          // format parameter names as 'my_parameter [sql.Int]'\r\n          const logName = param => param.name + ' [sql.' + param.type.name + ']'\r\n          const logParams = {}\r\n          params.forEach(p => { logParams[logName(p)] = logValue(p.value) })\r\n          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams)\r\n        }\r\n\r\n        const req = new tds.Request(procedure, err => {\r\n          // to make sure we handle no-sql errors as well\r\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\r\n            err = new RequestError(err, 'EREQUEST')\r\n            if (this.stream) this.emit('error', err)\r\n            errors.push(err)\r\n          }\r\n\r\n          delete this._cancel\r\n\r\n          let error\r\n          if (errors.length && !this.stream) {\r\n            error = errors.pop()\r\n            error.precedingErrors = errors\r\n          }\r\n\r\n          if (!hasReturned) {\r\n            for (const event in errorHandlers) {\r\n              connection.removeListener(event, errorHandlers[event])\r\n            }\r\n\r\n            this.parent.release(connection)\r\n            hasReturned = true\r\n\r\n            if (error) {\r\n              debug('request(%d): failed', IDS.get(this), error)\r\n            } else {\r\n              debug('request(%d): complete', IDS.get(this))\r\n            }\r\n\r\n            if (this.stream) {\r\n              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns)\r\n            } else {\r\n              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns)\r\n            }\r\n          }\r\n        })\r\n\r\n        this._setCurrentRequest(req)\r\n\r\n        req.on('columnMetadata', metadata => {\r\n          columns = createColumns(metadata, this.arrayRowMode)\r\n\r\n          isChunkedRecordset = false\r\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\r\n            isChunkedRecordset = true\r\n            chunksBuffer = []\r\n          }\r\n\r\n          if (this.stream) this.emit('recordset', columns)\r\n          if (this.arrayRowMode) recordsetcolumns.push(columns)\r\n        })\r\n\r\n        req.on('row', columns => {\r\n          if (!recordset) recordset = []\r\n\r\n          if (isChunkedRecordset) {\r\n            return chunksBuffer.push(columns[0].value)\r\n          }\r\n\r\n          if (this.arrayRowMode) {\r\n            row = []\r\n          } else {\r\n            row = {}\r\n          }\r\n          for (const col of columns) {\r\n            col.value = valueCorrection(col.value, col.metadata)\r\n\r\n            if (this.arrayRowMode) {\r\n              row.push(col.value)\r\n            } else {\r\n              const exi = row[col.metadata.colName]\r\n              if (exi != null) {\r\n                if (exi instanceof Array) {\r\n                  exi.push(col.value)\r\n                } else {\r\n                  row[col.metadata.colName] = [exi, col.value]\r\n                }\r\n              } else {\r\n                row[col.metadata.colName] = col.value\r\n              }\r\n            }\r\n          }\r\n\r\n          if (this.stream) {\r\n            this.emit('row', row)\r\n          } else {\r\n            recordset.push(row)\r\n          }\r\n        })\r\n\r\n        req.on('doneInProc', (rowCount, more) => {\r\n          if (rowCount != null) {\r\n            rowsAffected.push(rowCount)\r\n            if (this.stream) {\r\n              this.emit('rowsaffected', rowCount)\r\n            }\r\n          }\r\n\r\n          // filter empty recordsets when NOCOUNT is OFF\r\n          if (Object.keys(columns).length === 0) return\r\n\r\n          if (isChunkedRecordset) {\r\n            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {\r\n              try {\r\n                if (chunksBuffer.length === 0) {\r\n                  row = null\r\n                } else {\r\n                  row = JSON.parse(chunksBuffer.join(''))\r\n                }\r\n              } catch (ex) {\r\n                row = null\r\n                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\r\n\r\n                if (this.stream) this.emit('error', ex2)\r\n\r\n                // we must collect errors even in stream mode\r\n                errors.push(ex2)\r\n              }\r\n            } else {\r\n              row = {}\r\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\r\n            }\r\n\r\n            chunksBuffer = null\r\n\r\n            if (this.stream) {\r\n              this.emit('row', row)\r\n            } else {\r\n              recordset.push(row)\r\n            }\r\n          }\r\n\r\n          if (!this.stream) {\r\n            // all rows of current recordset loaded\r\n            Object.defineProperty(recordset, 'columns', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value: columns\r\n            })\r\n\r\n            Object.defineProperty(recordset, 'toTable', {\r\n              enumerable: false,\r\n              configurable: true,\r\n              value (name) { return Table.fromRecordset(this, name) }\r\n            })\r\n\r\n            recordsets.push(recordset)\r\n          }\r\n\r\n          recordset = []\r\n          columns = {}\r\n        })\r\n\r\n        req.on('doneProc', (rowCount, more, returnStatus) => {\r\n          returnValue = returnStatus\r\n        })\r\n\r\n        req.on('returnValue', (parameterName, value, metadata) => {\r\n          output[parameterName] = value\r\n        })\r\n\r\n        for (const name in this.parameters) {\r\n          if (!objectHasProperty(this.parameters, name)) {\r\n            continue\r\n          }\r\n          const param = this.parameters[name]\r\n          if (param.io === 1) {\r\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          } else {\r\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision })\r\n          }\r\n        }\r\n\r\n        connection.callProcedure(req)\r\n      })\r\n    })\r\n  }\r\n\r\n  _pause () {\r\n    super._pause()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.pause()\r\n    }\r\n  }\r\n\r\n  _resume () {\r\n    super._resume()\r\n    if (this._currentRequest) {\r\n      this._currentRequest.resume()\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = Request\r\n"]},"metadata":{},"sourceType":"script"}