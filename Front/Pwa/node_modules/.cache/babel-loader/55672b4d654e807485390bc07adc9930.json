{"ast":null,"code":"'use strict';\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\n\nclass Point {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.z = null;\n    this.m = null;\n  }\n\n}\n\nconst parsePoints = (buffer, count, isGeometryPoint) => {\n  // s2.1.5 + s2.1.6\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\n  // while a GEOMETRY POINT is ordered x then y.\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\n  const points = [];\n\n  if (count < 1) {\n    return points;\n  }\n\n  if (isGeometryPoint) {\n    // GEOMETRY POINT (s2.1.6): x then y.\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.x = buffer.readDoubleLE(buffer.position);\n      point.y = buffer.readDoubleLE(buffer.position + 8);\n      buffer.position += 16;\n    }\n  } else {\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.lat = buffer.readDoubleLE(buffer.position);\n      point.lng = buffer.readDoubleLE(buffer.position + 8); // For backwards compatibility, preserve the coordinate inversion in x and y.\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\n\n      point.x = point.lat;\n      point.y = point.lng;\n      buffer.position += 16;\n    }\n  }\n\n  return points;\n};\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n  const figures = [];\n\n  if (count < 1) {\n    return figures;\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      });\n      buffer.position += 5;\n    }\n  }\n\n  return figures;\n};\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n  const shapes = [];\n\n  if (count < 1) {\n    return shapes;\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    });\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      });\n      buffer.position += 9;\n    }\n  }\n\n  return shapes;\n};\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n  const segments = [];\n\n  if (count < 1) {\n    return segments;\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)\n    });\n    buffer.position++;\n  }\n\n  return segments;\n};\n\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\n  // s2.1.1 + s.2.1.2\n  const srid = buffer.readInt32LE(0);\n\n  if (srid === -1) {\n    return null;\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  };\n  const flags = buffer.readUInt8(5);\n  buffer.position = 6; // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & 1 << 0) > 0,\n    M: (flags & 1 << 1) > 0,\n    V: (flags & 1 << 2) > 0,\n    P: (flags & 1 << 3) > 0,\n    L: (flags & 1 << 4) > 0\n  };\n\n  if (value.version === 2) {\n    properties.H = (flags & 1 << 3) > 0;\n  } // console.log(\"properties\", properties);\n\n\n  let numberOfPoints;\n\n  if (properties.P) {\n    numberOfPoints = 1;\n  } else if (properties.L) {\n    numberOfPoints = 2;\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfPoints\", numberOfPoints)\n\n\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);\n\n  if (properties.Z) {\n    parseZ(buffer, value.points);\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points);\n  } // console.log(\"points\", points)\n\n\n  let numberOfFigures;\n\n  if (properties.P) {\n    numberOfFigures = 1;\n  } else if (properties.L) {\n    numberOfFigures = 1;\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfFigures\", numberOfFigures)\n\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties); // console.log(\"figures\", figures)\n\n  let numberOfShapes;\n\n  if (properties.P) {\n    numberOfShapes = 1;\n  } else if (properties.L) {\n    numberOfShapes = 1;\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfShapes\", numberOfShapes)\n\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties); // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4; // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments); // console.log(\"segments\", segments)\n  } else {\n    value.segments = [];\n  }\n\n  return value;\n};\n\nmodule.exports.PARSERS = {\n  geography(buffer) {\n    return parseGeography(buffer,\n    /* isUsingGeometryPoints: */\n    false);\n  },\n\n  geometry(buffer) {\n    return parseGeography(buffer,\n    /* isUsingGeometryPoints: */\n    true);\n  }\n\n};","map":{"version":3,"sources":["C:/Users/matia/Documents/Git/Turismo-Real/front/pwa/node_modules/mssql/lib/udt.js"],"names":["Point","constructor","x","y","z","m","parsePoints","buffer","count","isGeometryPoint","points","i","point","push","readDoubleLE","position","lat","lng","parseZ","forEach","parseM","parseFigures","properties","figures","P","attribute","pointOffset","L","readUInt8","readInt32LE","parseShapes","shapes","parentOffset","figureOffset","type","parseSegments","segments","parseGeography","isUsingGeometryPoints","srid","value","version","flags","Z","M","V","H","numberOfPoints","readUInt32LE","numberOfFigures","numberOfShapes","length","numberOfSegments","module","exports","PARSERS","geography","geometry"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,KAAN,CAAY;AACVC,EAAAA,WAAW,GAAI;AACb,SAAKC,CAAL,GAAS,CAAT;AACA,SAAKC,CAAL,GAAS,CAAT;AACA,SAAKC,CAAL,GAAS,IAAT;AACA,SAAKC,CAAL,GAAS,IAAT;AACD;;AANS;;AASZ,MAAMC,WAAW,GAAG,CAACC,MAAD,EAASC,KAAT,EAAgBC,eAAhB,KAAoC;AACtD;AACA;AACA;AACA;AAEA,QAAMC,MAAM,GAAG,EAAf;;AACA,MAAIF,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOE,MAAP;AACD;;AAED,MAAID,eAAJ,EAAqB;AACnB;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,KAArB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/B,YAAMC,KAAK,GAAG,IAAIZ,KAAJ,EAAd;AACAU,MAAAA,MAAM,CAACG,IAAP,CAAYD,KAAZ;AACAA,MAAAA,KAAK,CAACV,CAAN,GAAUK,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAA3B,CAAV;AACAH,MAAAA,KAAK,CAACT,CAAN,GAAUI,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAAP,GAAkB,CAAtC,CAAV;AACAR,MAAAA,MAAM,CAACQ,QAAP,IAAmB,EAAnB;AACD;AACF,GATD,MASO;AACL;AACA,SAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,KAArB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/B,YAAMC,KAAK,GAAG,IAAIZ,KAAJ,EAAd;AACAU,MAAAA,MAAM,CAACG,IAAP,CAAYD,KAAZ;AACAA,MAAAA,KAAK,CAACI,GAAN,GAAYT,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAA3B,CAAZ;AACAH,MAAAA,KAAK,CAACK,GAAN,GAAYV,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAAP,GAAkB,CAAtC,CAAZ,CAJ+B,CAM/B;AACA;AACA;;AACAH,MAAAA,KAAK,CAACV,CAAN,GAAUU,KAAK,CAACI,GAAhB;AACAJ,MAAAA,KAAK,CAACT,CAAN,GAAUS,KAAK,CAACK,GAAhB;AAEAV,MAAAA,MAAM,CAACQ,QAAP,IAAmB,EAAnB;AACD;AACF;;AAED,SAAOL,MAAP;AACD,CAvCD;;AAyCA,MAAMQ,MAAM,GAAG,CAACX,MAAD,EAASG,MAAT,KAAoB;AACjC;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACd;AACD;;AAEDA,EAAAA,MAAM,CAACS,OAAP,CAAeP,KAAK,IAAI;AACtBA,IAAAA,KAAK,CAACR,CAAN,GAAUG,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAA3B,CAAV;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD,GAHD;AAID,CAXD;;AAaA,MAAMK,MAAM,GAAG,CAACb,MAAD,EAASG,MAAT,KAAoB;AACjC;AAEA,MAAIA,MAAM,GAAG,CAAb,EAAgB;AACd;AACD;;AAEDA,EAAAA,MAAM,CAACS,OAAP,CAAeP,KAAK,IAAI;AACtBA,IAAAA,KAAK,CAACP,CAAN,GAAUE,MAAM,CAACO,YAAP,CAAoBP,MAAM,CAACQ,QAA3B,CAAV;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD,GAHD;AAID,CAXD;;AAaA,MAAMM,YAAY,GAAG,CAACd,MAAD,EAASC,KAAT,EAAgBc,UAAhB,KAA+B;AAClD;AAEA,QAAMC,OAAO,GAAG,EAAhB;;AACA,MAAIf,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOe,OAAP;AACD;;AAED,MAAID,UAAU,CAACE,CAAf,EAAkB;AAChBD,IAAAA,OAAO,CAACV,IAAR,CAAa;AACXY,MAAAA,SAAS,EAAE,IADA;AAEXC,MAAAA,WAAW,EAAE;AAFF,KAAb;AAID,GALD,MAKO,IAAIJ,UAAU,CAACK,CAAf,EAAkB;AACvBJ,IAAAA,OAAO,CAACV,IAAR,CAAa;AACXY,MAAAA,SAAS,EAAE,IADA;AAEXC,MAAAA,WAAW,EAAE;AAFF,KAAb;AAID,GALM,MAKA;AACL,SAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,KAArB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/BY,MAAAA,OAAO,CAACV,IAAR,CAAa;AACXY,QAAAA,SAAS,EAAElB,MAAM,CAACqB,SAAP,CAAiBrB,MAAM,CAACQ,QAAxB,CADA;AAEXW,QAAAA,WAAW,EAAEnB,MAAM,CAACsB,WAAP,CAAmBtB,MAAM,CAACQ,QAAP,GAAkB,CAArC;AAFF,OAAb;AAKAR,MAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD;AACF;;AAED,SAAOQ,OAAP;AACD,CA9BD;;AAgCA,MAAMO,WAAW,GAAG,CAACvB,MAAD,EAASC,KAAT,EAAgBc,UAAhB,KAA+B;AACjD;AAEA,QAAMS,MAAM,GAAG,EAAf;;AACA,MAAIvB,KAAK,GAAG,CAAZ,EAAe;AACb,WAAOuB,MAAP;AACD;;AAED,MAAIT,UAAU,CAACE,CAAf,EAAkB;AAChBO,IAAAA,MAAM,CAAClB,IAAP,CAAY;AACVmB,MAAAA,YAAY,EAAE,CAAC,CADL;AAEVC,MAAAA,YAAY,EAAE,CAFJ;AAGVC,MAAAA,IAAI,EAAE;AAHI,KAAZ;AAKD,GAND,MAMO,IAAIZ,UAAU,CAACK,CAAf,EAAkB;AACvBI,IAAAA,MAAM,CAAClB,IAAP,CAAY;AACVmB,MAAAA,YAAY,EAAE,CAAC,CADL;AAEVC,MAAAA,YAAY,EAAE,CAFJ;AAGVC,MAAAA,IAAI,EAAE;AAHI,KAAZ;AAKD,GANM,MAMA;AACL,SAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,KAArB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/BoB,MAAAA,MAAM,CAAClB,IAAP,CAAY;AACVmB,QAAAA,YAAY,EAAEzB,MAAM,CAACsB,WAAP,CAAmBtB,MAAM,CAACQ,QAA1B,CADJ;AAEVkB,QAAAA,YAAY,EAAE1B,MAAM,CAACsB,WAAP,CAAmBtB,MAAM,CAACQ,QAAP,GAAkB,CAArC,CAFJ;AAGVmB,QAAAA,IAAI,EAAE3B,MAAM,CAACqB,SAAP,CAAiBrB,MAAM,CAACQ,QAAP,GAAkB,CAAnC;AAHI,OAAZ;AAMAR,MAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD;AACF;;AAED,SAAOgB,MAAP;AACD,CAjCD;;AAmCA,MAAMI,aAAa,GAAG,CAAC5B,MAAD,EAASC,KAAT,KAAmB;AACvC;AAEA,QAAM4B,QAAQ,GAAG,EAAjB;;AACA,MAAI5B,KAAK,GAAG,CAAZ,EAAe;AACb,WAAO4B,QAAP;AACD;;AAED,OAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIH,KAArB,EAA4BG,CAAC,EAA7B,EAAiC;AAC/ByB,IAAAA,QAAQ,CAACvB,IAAT,CAAc;AAAEqB,MAAAA,IAAI,EAAE3B,MAAM,CAACqB,SAAP,CAAiBrB,MAAM,CAACQ,QAAxB;AAAR,KAAd;AAEAR,IAAAA,MAAM,CAACQ,QAAP;AACD;;AAED,SAAOqB,QAAP;AACD,CAfD;;AAiBA,MAAMC,cAAc,GAAG,CAAC9B,MAAD,EAAS+B,qBAAT,KAAmC;AACxD;AAEA,QAAMC,IAAI,GAAGhC,MAAM,CAACsB,WAAP,CAAmB,CAAnB,CAAb;;AACA,MAAIU,IAAI,KAAK,CAAC,CAAd,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,QAAMC,KAAK,GAAG;AACZD,IAAAA,IADY;AAEZE,IAAAA,OAAO,EAAElC,MAAM,CAACqB,SAAP,CAAiB,CAAjB;AAFG,GAAd;AAKA,QAAMc,KAAK,GAAGnC,MAAM,CAACqB,SAAP,CAAiB,CAAjB,CAAd;AACArB,EAAAA,MAAM,CAACQ,QAAP,GAAkB,CAAlB,CAdwD,CAgBxD;AACA;;AAEA,QAAMO,UAAU,GAAG;AACjBqB,IAAAA,CAAC,EAAE,CAACD,KAAK,GAAI,KAAK,CAAf,IAAqB,CADP;AAEjBE,IAAAA,CAAC,EAAE,CAACF,KAAK,GAAI,KAAK,CAAf,IAAqB,CAFP;AAGjBG,IAAAA,CAAC,EAAE,CAACH,KAAK,GAAI,KAAK,CAAf,IAAqB,CAHP;AAIjBlB,IAAAA,CAAC,EAAE,CAACkB,KAAK,GAAI,KAAK,CAAf,IAAqB,CAJP;AAKjBf,IAAAA,CAAC,EAAE,CAACe,KAAK,GAAI,KAAK,CAAf,IAAqB;AALP,GAAnB;;AAQA,MAAIF,KAAK,CAACC,OAAN,KAAkB,CAAtB,EAAyB;AACvBnB,IAAAA,UAAU,CAACwB,CAAX,GAAe,CAACJ,KAAK,GAAI,KAAK,CAAf,IAAqB,CAApC;AACD,GA7BuD,CA+BxD;;;AAEA,MAAIK,cAAJ;;AACA,MAAIzB,UAAU,CAACE,CAAf,EAAkB;AAChBuB,IAAAA,cAAc,GAAG,CAAjB;AACD,GAFD,MAEO,IAAIzB,UAAU,CAACK,CAAf,EAAkB;AACvBoB,IAAAA,cAAc,GAAG,CAAjB;AACD,GAFM,MAEA;AACLA,IAAAA,cAAc,GAAGxC,MAAM,CAACyC,YAAP,CAAoBzC,MAAM,CAACQ,QAA3B,CAAjB;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD,GAzCuD,CA2CxD;;;AAEAyB,EAAAA,KAAK,CAAC9B,MAAN,GAAeJ,WAAW,CAACC,MAAD,EAASwC,cAAT,EAAyBT,qBAAzB,CAA1B;;AAEA,MAAIhB,UAAU,CAACqB,CAAf,EAAkB;AAChBzB,IAAAA,MAAM,CAACX,MAAD,EAASiC,KAAK,CAAC9B,MAAf,CAAN;AACD;;AAED,MAAIY,UAAU,CAACsB,CAAf,EAAkB;AAChBxB,IAAAA,MAAM,CAACb,MAAD,EAASiC,KAAK,CAAC9B,MAAf,CAAN;AACD,GArDuD,CAuDxD;;;AAEA,MAAIuC,eAAJ;;AACA,MAAI3B,UAAU,CAACE,CAAf,EAAkB;AAChByB,IAAAA,eAAe,GAAG,CAAlB;AACD,GAFD,MAEO,IAAI3B,UAAU,CAACK,CAAf,EAAkB;AACvBsB,IAAAA,eAAe,GAAG,CAAlB;AACD,GAFM,MAEA;AACLA,IAAAA,eAAe,GAAG1C,MAAM,CAACyC,YAAP,CAAoBzC,MAAM,CAACQ,QAA3B,CAAlB;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD,GAjEuD,CAmExD;;;AAEAyB,EAAAA,KAAK,CAACjB,OAAN,GAAgBF,YAAY,CAACd,MAAD,EAAS0C,eAAT,EAA0B3B,UAA1B,CAA5B,CArEwD,CAuExD;;AAEA,MAAI4B,cAAJ;;AACA,MAAI5B,UAAU,CAACE,CAAf,EAAkB;AAChB0B,IAAAA,cAAc,GAAG,CAAjB;AACD,GAFD,MAEO,IAAI5B,UAAU,CAACK,CAAf,EAAkB;AACvBuB,IAAAA,cAAc,GAAG,CAAjB;AACD,GAFM,MAEA;AACLA,IAAAA,cAAc,GAAG3C,MAAM,CAACyC,YAAP,CAAoBzC,MAAM,CAACQ,QAA3B,CAAjB;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB;AACD,GAjFuD,CAmFxD;;;AAEAyB,EAAAA,KAAK,CAACT,MAAN,GAAeD,WAAW,CAACvB,MAAD,EAAS2C,cAAT,EAAyB5B,UAAzB,CAA1B,CArFwD,CAuFxD;;AAEA,MAAIkB,KAAK,CAACC,OAAN,KAAkB,CAAlB,IAAuBlC,MAAM,CAACQ,QAAP,GAAkBR,MAAM,CAAC4C,MAApD,EAA4D;AAC1D,UAAMC,gBAAgB,GAAG7C,MAAM,CAACyC,YAAP,CAAoBzC,MAAM,CAACQ,QAA3B,CAAzB;AACAR,IAAAA,MAAM,CAACQ,QAAP,IAAmB,CAAnB,CAF0D,CAI1D;;AAEAyB,IAAAA,KAAK,CAACJ,QAAN,GAAiBD,aAAa,CAAC5B,MAAD,EAAS6C,gBAAT,CAA9B,CAN0D,CAQ1D;AACD,GATD,MASO;AACLZ,IAAAA,KAAK,CAACJ,QAAN,GAAiB,EAAjB;AACD;;AAED,SAAOI,KAAP;AACD,CAvGD;;AAyGAa,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyB;AACvBC,EAAAA,SAAS,CAAEjD,MAAF,EAAU;AACjB,WAAO8B,cAAc,CAAC9B,MAAD;AAAS;AAA4B,SAArC,CAArB;AACD,GAHsB;;AAKvBkD,EAAAA,QAAQ,CAAElD,MAAF,EAAU;AAChB,WAAO8B,cAAc,CAAC9B,MAAD;AAAS;AAA4B,QAArC,CAArB;AACD;;AAPsB,CAAzB","sourcesContent":["'use strict'\n\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\n\nclass Point {\n  constructor () {\n    this.x = 0\n    this.y = 0\n    this.z = null\n    this.m = null\n  }\n}\n\nconst parsePoints = (buffer, count, isGeometryPoint) => {\n  // s2.1.5 + s2.1.6\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\n  // while a GEOMETRY POINT is ordered x then y.\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\n\n  const points = []\n  if (count < 1) {\n    return points\n  }\n\n  if (isGeometryPoint) {\n    // GEOMETRY POINT (s2.1.6): x then y.\n    for (let i = 1; i <= count; i++) {\n      const point = new Point()\n      points.push(point)\n      point.x = buffer.readDoubleLE(buffer.position)\n      point.y = buffer.readDoubleLE(buffer.position + 8)\n      buffer.position += 16\n    }\n  } else {\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\n    for (let i = 1; i <= count; i++) {\n      const point = new Point()\n      points.push(point)\n      point.lat = buffer.readDoubleLE(buffer.position)\n      point.lng = buffer.readDoubleLE(buffer.position + 8)\n\n      // For backwards compatibility, preserve the coordinate inversion in x and y.\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\n      point.x = point.lat\n      point.y = point.lng\n\n      buffer.position += 16\n    }\n  }\n\n  return points\n}\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n\n  const figures = []\n  if (count < 1) {\n    return figures\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      })\n\n      buffer.position += 5\n    }\n  }\n\n  return figures\n}\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n\n  const shapes = []\n  if (count < 1) {\n    return shapes\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    })\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      })\n\n      buffer.position += 9\n    }\n  }\n\n  return shapes\n}\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n\n  const segments = []\n  if (count < 1) {\n    return segments\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({ type: buffer.readUInt8(buffer.position) })\n\n    buffer.position++\n  }\n\n  return segments\n}\n\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\n  // s2.1.1 + s.2.1.2\n\n  const srid = buffer.readInt32LE(0)\n  if (srid === -1) {\n    return null\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  }\n\n  const flags = buffer.readUInt8(5)\n  buffer.position = 6\n\n  // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & (1 << 0)) > 0,\n    M: (flags & (1 << 1)) > 0,\n    V: (flags & (1 << 2)) > 0,\n    P: (flags & (1 << 3)) > 0,\n    L: (flags & (1 << 4)) > 0\n  }\n\n  if (value.version === 2) {\n    properties.H = (flags & (1 << 3)) > 0\n  }\n\n  // console.log(\"properties\", properties);\n\n  let numberOfPoints\n  if (properties.P) {\n    numberOfPoints = 1\n  } else if (properties.L) {\n    numberOfPoints = 2\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfPoints\", numberOfPoints)\n\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints)\n\n  if (properties.Z) {\n    parseZ(buffer, value.points)\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points)\n  }\n\n  // console.log(\"points\", points)\n\n  let numberOfFigures\n  if (properties.P) {\n    numberOfFigures = 1\n  } else if (properties.L) {\n    numberOfFigures = 1\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfFigures\", numberOfFigures)\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties)\n\n  // console.log(\"figures\", figures)\n\n  let numberOfShapes\n  if (properties.P) {\n    numberOfShapes = 1\n  } else if (properties.L) {\n    numberOfShapes = 1\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfShapes\", numberOfShapes)\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties)\n\n  // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n\n    // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments)\n\n    // console.log(\"segments\", segments)\n  } else {\n    value.segments = []\n  }\n\n  return value\n}\n\nmodule.exports.PARSERS = {\n  geography (buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */false)\n  },\n\n  geometry (buffer) {\n    return parseGeography(buffer, /* isUsingGeometryPoints: */true)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}