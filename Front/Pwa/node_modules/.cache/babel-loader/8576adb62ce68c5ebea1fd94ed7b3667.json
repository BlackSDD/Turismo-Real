{"ast":null,"code":"'use strict';\n/* const FIGURE = {\r\n  INTERIOR_RING: 0x00,\r\n  STROKE: 0x01,\r\n  EXTERIOR_RING: 0x02\r\n};\r\n\r\nconst FIGURE_V2 = {\r\n  POINT: 0x00,\r\n  LINE: 0x01,\r\n  ARC: 0x02,\r\n  COMPOSITE_CURVE: 0x03\r\n};\r\n\r\nconst SHAPE = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07\r\n};\r\n\r\nconst SHAPE_V2 = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07,\r\n  CIRCULAR_STRING: 0x08,\r\n  COMPOUND_CURVE: 0x09,\r\n  CURVE_POLYGON: 0x0A,\r\n  FULL_GLOBE: 0x0B\r\n};\r\n\r\nconst SEGMENT = {\r\n  LINE: 0x00,\r\n  ARC: 0x01,\r\n  FIRST_LINE: 0x02,\r\n  FIRST_ARC: 0x03\r\n}; */\n\nclass Point {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.z = null;\n    this.m = null;\n  }\n\n}\n\nconst parsePoints = (buffer, count, isGeometryPoint) => {\n  // s2.1.5 + s2.1.6\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\n  // while a GEOMETRY POINT is ordered x then y.\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\n  const points = [];\n\n  if (count < 1) {\n    return points;\n  }\n\n  if (isGeometryPoint) {\n    // GEOMETRY POINT (s2.1.6): x then y.\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.x = buffer.readDoubleLE(buffer.position);\n      point.y = buffer.readDoubleLE(buffer.position + 8);\n      buffer.position += 16;\n    }\n  } else {\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\n    for (let i = 1; i <= count; i++) {\n      const point = new Point();\n      points.push(point);\n      point.lat = buffer.readDoubleLE(buffer.position);\n      point.lng = buffer.readDoubleLE(buffer.position + 8); // For backwards compatibility, preserve the coordinate inversion in x and y.\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\n\n      point.x = point.lat;\n      point.y = point.lng;\n      buffer.position += 16;\n    }\n  }\n\n  return points;\n};\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n  if (points < 1) {\n    return;\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position);\n    buffer.position += 8;\n  });\n};\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n  const figures = [];\n\n  if (count < 1) {\n    return figures;\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      });\n      buffer.position += 5;\n    }\n  }\n\n  return figures;\n};\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n  const shapes = [];\n\n  if (count < 1) {\n    return shapes;\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    });\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    });\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      });\n      buffer.position += 9;\n    }\n  }\n\n  return shapes;\n};\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n  const segments = [];\n\n  if (count < 1) {\n    return segments;\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)\n    });\n    buffer.position++;\n  }\n\n  return segments;\n};\n\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\n  // s2.1.1 + s.2.1.2\n  const srid = buffer.readInt32LE(0);\n\n  if (srid === -1) {\n    return null;\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  };\n  const flags = buffer.readUInt8(5);\n  buffer.position = 6; // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & 1 << 0) > 0,\n    M: (flags & 1 << 1) > 0,\n    V: (flags & 1 << 2) > 0,\n    P: (flags & 1 << 3) > 0,\n    L: (flags & 1 << 4) > 0\n  };\n\n  if (value.version === 2) {\n    properties.H = (flags & 1 << 3) > 0;\n  } // console.log(\"properties\", properties);\n\n\n  let numberOfPoints;\n\n  if (properties.P) {\n    numberOfPoints = 1;\n  } else if (properties.L) {\n    numberOfPoints = 2;\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfPoints\", numberOfPoints)\n\n\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);\n\n  if (properties.Z) {\n    parseZ(buffer, value.points);\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points);\n  } // console.log(\"points\", points)\n\n\n  let numberOfFigures;\n\n  if (properties.P) {\n    numberOfFigures = 1;\n  } else if (properties.L) {\n    numberOfFigures = 1;\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfFigures\", numberOfFigures)\n\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties); // console.log(\"figures\", figures)\n\n  let numberOfShapes;\n\n  if (properties.P) {\n    numberOfShapes = 1;\n  } else if (properties.L) {\n    numberOfShapes = 1;\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4;\n  } // console.log(\"numberOfShapes\", numberOfShapes)\n\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties); // console.log( \"shapes\", shapes)\n\n  if (value.version === 2 && buffer.position < buffer.length) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position);\n    buffer.position += 4; // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments); // console.log(\"segments\", segments)\n  } else {\n    value.segments = [];\n  }\n\n  return value;\n};\n\nmodule.exports.PARSERS = {\n  geography(buffer) {\n    return parseGeography(buffer,\n    /* isUsingGeometryPoints: */\n    false);\n  },\n\n  geometry(buffer) {\n    return parseGeography(buffer,\n    /* isUsingGeometryPoints: */\n    true);\n  }\n\n};","map":{"version":3,"sources":["B:/Duoc/Portafolio_de_titulo/Git/Turismo-Real/Front/Pwa/node_modules/mssql/lib/udt.js"],"names":["Point","constructor","x","y","z","m","parsePoints","buffer","count","isGeometryPoint","points","i","point","push","readDoubleLE","position","lat","lng","parseZ","forEach","parseM","parseFigures","properties","figures","P","attribute","pointOffset","L","readUInt8","readInt32LE","parseShapes","shapes","parentOffset","figureOffset","type","parseSegments","segments","parseGeography","isUsingGeometryPoints","srid","value","version","flags","Z","M","V","H","numberOfPoints","readUInt32LE","numberOfFigures","numberOfShapes","length","numberOfSegments","module","exports","PARSERS","geography","geometry"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n/* const FIGURE = {\r\n  INTERIOR_RING: 0x00,\r\n  STROKE: 0x01,\r\n  EXTERIOR_RING: 0x02\r\n};\r\n\r\nconst FIGURE_V2 = {\r\n  POINT: 0x00,\r\n  LINE: 0x01,\r\n  ARC: 0x02,\r\n  COMPOSITE_CURVE: 0x03\r\n};\r\n\r\nconst SHAPE = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07\r\n};\r\n\r\nconst SHAPE_V2 = {\r\n  POINT: 0x01,\r\n  LINESTRING: 0x02,\r\n  POLYGON: 0x03,\r\n  MULTIPOINT: 0x04,\r\n  MULTILINESTRING: 0x05,\r\n  MULTIPOLYGON: 0x06,\r\n  GEOMETRY_COLLECTION: 0x07,\r\n  CIRCULAR_STRING: 0x08,\r\n  COMPOUND_CURVE: 0x09,\r\n  CURVE_POLYGON: 0x0A,\r\n  FULL_GLOBE: 0x0B\r\n};\r\n\r\nconst SEGMENT = {\r\n  LINE: 0x00,\r\n  ARC: 0x01,\r\n  FIRST_LINE: 0x02,\r\n  FIRST_ARC: 0x03\r\n}; */\r\n\r\nclass Point {\r\n  constructor () {\r\n    this.x = 0\r\n    this.y = 0\r\n    this.z = null\r\n    this.m = null\r\n  }\r\n}\r\n\r\nconst parsePoints = (buffer, count, isGeometryPoint) => {\r\n  // s2.1.5 + s2.1.6\r\n  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),\r\n  // while a GEOMETRY POINT is ordered x then y.\r\n  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].\r\n\r\n  const points = []\r\n  if (count < 1) {\r\n    return points\r\n  }\r\n\r\n  if (isGeometryPoint) {\r\n    // GEOMETRY POINT (s2.1.6): x then y.\r\n    for (let i = 1; i <= count; i++) {\r\n      const point = new Point()\r\n      points.push(point)\r\n      point.x = buffer.readDoubleLE(buffer.position)\r\n      point.y = buffer.readDoubleLE(buffer.position + 8)\r\n      buffer.position += 16\r\n    }\r\n  } else {\r\n    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).\r\n    for (let i = 1; i <= count; i++) {\r\n      const point = new Point()\r\n      points.push(point)\r\n      point.lat = buffer.readDoubleLE(buffer.position)\r\n      point.lng = buffer.readDoubleLE(buffer.position + 8)\r\n\r\n      // For backwards compatibility, preserve the coordinate inversion in x and y.\r\n      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.\r\n      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531\r\n      point.x = point.lat\r\n      point.y = point.lng\r\n\r\n      buffer.position += 16\r\n    }\r\n  }\r\n\r\n  return points\r\n}\r\n\r\nconst parseZ = (buffer, points) => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  if (points < 1) {\r\n    return\r\n  }\r\n\r\n  points.forEach(point => {\r\n    point.z = buffer.readDoubleLE(buffer.position)\r\n    buffer.position += 8\r\n  })\r\n}\r\n\r\nconst parseM = (buffer, points) => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  if (points < 1) {\r\n    return\r\n  }\r\n\r\n  points.forEach(point => {\r\n    point.m = buffer.readDoubleLE(buffer.position)\r\n    buffer.position += 8\r\n  })\r\n}\r\n\r\nconst parseFigures = (buffer, count, properties) => {\r\n  // s2.1.3\r\n\r\n  const figures = []\r\n  if (count < 1) {\r\n    return figures\r\n  }\r\n\r\n  if (properties.P) {\r\n    figures.push({\r\n      attribute: 0x01,\r\n      pointOffset: 0\r\n    })\r\n  } else if (properties.L) {\r\n    figures.push({\r\n      attribute: 0x01,\r\n      pointOffset: 0\r\n    })\r\n  } else {\r\n    for (let i = 1; i <= count; i++) {\r\n      figures.push({\r\n        attribute: buffer.readUInt8(buffer.position),\r\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\r\n      })\r\n\r\n      buffer.position += 5\r\n    }\r\n  }\r\n\r\n  return figures\r\n}\r\n\r\nconst parseShapes = (buffer, count, properties) => {\r\n  // s2.1.4\r\n\r\n  const shapes = []\r\n  if (count < 1) {\r\n    return shapes\r\n  }\r\n\r\n  if (properties.P) {\r\n    shapes.push({\r\n      parentOffset: -1,\r\n      figureOffset: 0,\r\n      type: 0x01\r\n    })\r\n  } else if (properties.L) {\r\n    shapes.push({\r\n      parentOffset: -1,\r\n      figureOffset: 0,\r\n      type: 0x02\r\n    })\r\n  } else {\r\n    for (let i = 1; i <= count; i++) {\r\n      shapes.push({\r\n        parentOffset: buffer.readInt32LE(buffer.position),\r\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\r\n        type: buffer.readUInt8(buffer.position + 8)\r\n      })\r\n\r\n      buffer.position += 9\r\n    }\r\n  }\r\n\r\n  return shapes\r\n}\r\n\r\nconst parseSegments = (buffer, count) => {\r\n  // s2.1.7\r\n\r\n  const segments = []\r\n  if (count < 1) {\r\n    return segments\r\n  }\r\n\r\n  for (let i = 1; i <= count; i++) {\r\n    segments.push({ type: buffer.readUInt8(buffer.position) })\r\n\r\n    buffer.position++\r\n  }\r\n\r\n  return segments\r\n}\r\n\r\nconst parseGeography = (buffer, isUsingGeometryPoints) => {\r\n  // s2.1.1 + s.2.1.2\r\n\r\n  const srid = buffer.readInt32LE(0)\r\n  if (srid === -1) {\r\n    return null\r\n  }\r\n\r\n  const value = {\r\n    srid,\r\n    version: buffer.readUInt8(4)\r\n  }\r\n\r\n  const flags = buffer.readUInt8(5)\r\n  buffer.position = 6\r\n\r\n  // console.log(\"srid\", srid)\r\n  // console.log(\"version\", version)\r\n\r\n  const properties = {\r\n    Z: (flags & (1 << 0)) > 0,\r\n    M: (flags & (1 << 1)) > 0,\r\n    V: (flags & (1 << 2)) > 0,\r\n    P: (flags & (1 << 3)) > 0,\r\n    L: (flags & (1 << 4)) > 0\r\n  }\r\n\r\n  if (value.version === 2) {\r\n    properties.H = (flags & (1 << 3)) > 0\r\n  }\r\n\r\n  // console.log(\"properties\", properties);\r\n\r\n  let numberOfPoints\r\n  if (properties.P) {\r\n    numberOfPoints = 1\r\n  } else if (properties.L) {\r\n    numberOfPoints = 2\r\n  } else {\r\n    numberOfPoints = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfPoints\", numberOfPoints)\r\n\r\n  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints)\r\n\r\n  if (properties.Z) {\r\n    parseZ(buffer, value.points)\r\n  }\r\n\r\n  if (properties.M) {\r\n    parseM(buffer, value.points)\r\n  }\r\n\r\n  // console.log(\"points\", points)\r\n\r\n  let numberOfFigures\r\n  if (properties.P) {\r\n    numberOfFigures = 1\r\n  } else if (properties.L) {\r\n    numberOfFigures = 1\r\n  } else {\r\n    numberOfFigures = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfFigures\", numberOfFigures)\r\n\r\n  value.figures = parseFigures(buffer, numberOfFigures, properties)\r\n\r\n  // console.log(\"figures\", figures)\r\n\r\n  let numberOfShapes\r\n  if (properties.P) {\r\n    numberOfShapes = 1\r\n  } else if (properties.L) {\r\n    numberOfShapes = 1\r\n  } else {\r\n    numberOfShapes = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n  }\r\n\r\n  // console.log(\"numberOfShapes\", numberOfShapes)\r\n\r\n  value.shapes = parseShapes(buffer, numberOfShapes, properties)\r\n\r\n  // console.log( \"shapes\", shapes)\r\n\r\n  if (value.version === 2 && buffer.position < buffer.length) {\r\n    const numberOfSegments = buffer.readUInt32LE(buffer.position)\r\n    buffer.position += 4\r\n\r\n    // console.log(\"numberOfSegments\", numberOfSegments)\r\n\r\n    value.segments = parseSegments(buffer, numberOfSegments)\r\n\r\n    // console.log(\"segments\", segments)\r\n  } else {\r\n    value.segments = []\r\n  }\r\n\r\n  return value\r\n}\r\n\r\nmodule.exports.PARSERS = {\r\n  geography (buffer) {\r\n    return parseGeography(buffer, /* isUsingGeometryPoints: */false)\r\n  },\r\n\r\n  geometry (buffer) {\r\n    return parseGeography(buffer, /* isUsingGeometryPoints: */true)\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}